// ==UserScript==
// @name         万宝楼韭菜助手
// @namespace    leek
// @version      1.0.10
// @author       吴彦祖
// @description  万宝楼物品搜索辅助
// @license MIT
// @match        https://jx3.seasunwbl.com/*
// @icon         https://jx3.seasunwbl.com/favicon.ico
// @connect      aijx3.cn
// @grant        unsafeWindow
// @grant        GM_addElement
// @run-at       document-start
// ==/UserScript==

(function () {
  'use strict';
  async function patchScript(scriptNode) {
    try {
      scriptNode.remove();
      const replacements = [
        {
          pattern: /=new (\w{1,2})\.default\(\{viewStore/,
          inject: '=window.buyerFilter=new $1.default({viewStore',
        },
        {
          pattern: /"重置"\),(\w{1,2})\.default\.createElement/,
          inject: '"重置"),window.searchButton=$1.default.createElement',
        },
        {
          pattern: ',this.setOrderType=',
          inject: ',window.buyerStore=this,this.setOrderType=',
        },
      ];

      const scriptUrl = scriptNode.src;
      const response = await fetch(scriptUrl);
      if (!response.ok) {
        console.error(`Failed to fetch script: ${response.statusText}`);
        return;
      }

      let scriptCode = await response.text();
      let modifiedCount = 0;
      let expectedModifications = replacements.length;

      for (const { pattern, inject } of replacements) {
        const matches = scriptCode.match(pattern); // 检查是否有匹配的项
        if (matches) {
          scriptCode = scriptCode.replace(pattern, inject);
          modifiedCount += 1;
        }
      }

      if (modifiedCount < expectedModifications) {
        console.error('脚本注入失败，万宝楼可能更新拉！');
        return;
      }else{
        console.log('脚本注入成功');
        startLeekApp();
      }

      const newScriptNode = document.createElement('script');
      newScriptNode.textContent = scriptCode;
      document.body.appendChild(newScriptNode);
    } catch (error) {
      console.error('脚本注入注入失败:', error);
    }
  }

  new MutationObserver((mutationsList, obs) => {
    mutationsList.forEach((mutationRecord) => {
      for (const node of mutationRecord.addedNodes) {
        if (node.src?.includes('/chunk/buyer/index')) {
          obs.disconnect();
          patchScript(node);
          break;
        }
      }
    });
  }).observe(document, { childList: true, subtree: true });

  function startLeekApp(){

    GM_addElement(document.body, 'div', {
      id: 'leek-app',
    });

    GM_addElement(document.head, 'style', {
      textContent: `
      .leek-count{padding:0 3px;font-weight:700;color:red;letter-spacing:3px}.leek-search .leek-search-sticky{position:sticky;top:0;z-index:10;background-color:#fff}.leek-search .leek-search-history{display:flex;flex-direction:column;padding-block-end:32px}.leek-search .leek-search-history .leek-search-history-title{display:flex;justify-content:space-between;height:40px}.leek-search .leek-search-history .leek-search-history-title h4{margin:0;padding:0}.leek-search .leek-search-history .leek-search-history-title .leek-search-history-clear{cursor:pointer;width:32px;height:32px;display:flex;justify-content:center;align-items:center}.leek-search .leek-search-history .leek-search-history-content{display:flex}.leek-search .leek-search-history .leek-search-history-content .leek-search-history-tag{cursor:pointer}.leek-select-item{display:flex;justify-content:space-between}.leek-search-select-popup .ant-select-item-option-state{display:none}.leek-btn-start{position:fixed;top:200px;right:max(calc((100% - 1160px)/2 - 90px),50px);font-size:80px;width:80px;height:80px;cursor:pointer;overflow:hidden;display:flex;z-index:9999;transform:translate(0);transform-origin:center bottom}.leek-growing{animation:leek-growAnimation .8s ease forwards}@keyframes leek-growAnimation{0%{transform:scale(0) translateY(0)}to{transform:scale(1) translateY(0)}}@keyframes leek-pullOutAnimation{0%{transform:translate(0)}50%{transform:translateY(-20px);animation-timing-function:ease-in-out}70%{transform:translateY(-50px);animation-timing-function:ease-in-out}to{transform:translateY(-120vh);animation-timing-function:ease-in}}.leek-fly-out{animation:leek-pullOutAnimation .6s ease forwards}

     `,
    });

    var __defProp = Object.defineProperty, __getOwnPropNames = Object.getOwnPropertyNames, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: value
}) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, "symbol" != typeof key ? key + "" : key, value), require_index = ((cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
        exports: {}
    }).exports, mod), mod.exports;
})({
    "index.js"(exports, module) {
        function makeMap(str, expectsLowerCase) {
            const set2 = new Set(str.split(","));
            return val => set2.has(val);
        }
        !function polyfill() {
            const relList = document.createElement("link").relList;
            if (!(relList && relList.supports && relList.supports("modulepreload"))) {
                for (const link of document.querySelectorAll('link[rel="modulepreload"]')) processPreload(link);
                new MutationObserver((mutations => {
                    for (const mutation of mutations) if ("childList" === mutation.type) for (const node2 of mutation.addedNodes) "LINK" === node2.tagName && "modulepreload" === node2.rel && processPreload(node2);
                })).observe(document, {
                    childList: !0,
                    subtree: !0
                });
            }
            function getFetchOpts(link) {
                const fetchOpts = {};
                return link.integrity && (fetchOpts.integrity = link.integrity), link.referrerPolicy && (fetchOpts.referrerPolicy = link.referrerPolicy), 
                "use-credentials" === link.crossOrigin ? fetchOpts.credentials = "include" : "anonymous" === link.crossOrigin ? fetchOpts.credentials = "omit" : fetchOpts.credentials = "same-origin", 
                fetchOpts;
            }
            function processPreload(link) {
                if (link.ep) return;
                link.ep = !0;
                const fetchOpts = getFetchOpts(link);
                fetch(link.href, fetchOpts);
            }
        }();
        const EMPTY_OBJ = {}, EMPTY_ARR = [], NOOP = () => {}, NO = () => !1, isOn$1 = key2 => 111 === key2.charCodeAt(0) && 110 === key2.charCodeAt(1) && (key2.charCodeAt(2) > 122 || key2.charCodeAt(2) < 97), isModelListener = key2 => key2.startsWith("onUpdate:"), extend = Object.assign, remove = (arr, el) => {
            const i2 = arr.indexOf(el);
            i2 > -1 && arr.splice(i2, 1);
        }, hasOwnProperty$g = Object.prototype.hasOwnProperty, hasOwn$1 = (val, key2) => hasOwnProperty$g.call(val, key2), isArray$2 = Array.isArray, isMap$1 = val => "[object Map]" === toTypeString(val), isSet$1 = val => "[object Set]" === toTypeString(val), isFunction$2 = val => "function" == typeof val, isString$1 = val => "string" == typeof val, isSymbol$1 = val => "symbol" == typeof val, isObject$3 = val => null !== val && "object" == typeof val, isPromise = val => (isObject$3(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch), objectToString$1 = Object.prototype.toString, toTypeString = value => objectToString$1.call(value), toRawType = value => toTypeString(value).slice(8, -1), isPlainObject$1 = val => "[object Object]" === toTypeString(val), isIntegerKey = key2 => isString$1(key2) && "NaN" !== key2 && "-" !== key2[0] && "" + parseInt(key2, 10) === key2, isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), cacheStringFunction$1 = fn => {
            const cache = Object.create(null);
            return str => cache[str] || (cache[str] = fn(str));
        }, camelizeRE$1 = /-(\w)/g, camelize$1 = cacheStringFunction$1((str => str.replace(camelizeRE$1, ((_2, c2) => c2 ? c2.toUpperCase() : "")))), hyphenateRE$1 = /\B([A-Z])/g, hyphenate$1 = cacheStringFunction$1((str => str.replace(hyphenateRE$1, "-$1").toLowerCase())), capitalize$1 = cacheStringFunction$1((str => str.charAt(0).toUpperCase() + str.slice(1))), toHandlerKey = cacheStringFunction$1((str => str ? `on${capitalize$1(str)}` : "")), hasChanged = (value, oldValue) => !Object.is(value, oldValue), invokeArrayFns = (fns, ...arg) => {
            for (let i2 = 0; i2 < fns.length; i2++) fns[i2](...arg);
        }, def = (obj, key2, value, writable = !1) => {
            Object.defineProperty(obj, key2, {
                configurable: !0,
                enumerable: !1,
                writable: writable,
                value: value
            });
        }, looseToNumber = val => {
            const n2 = parseFloat(val);
            return isNaN(n2) ? val : n2;
        }, toNumber$1 = val => {
            const n2 = isString$1(val) ? Number(val) : NaN;
            return isNaN(n2) ? val : n2;
        };
        let _globalThis;
        const getGlobalThis = () => _globalThis || (_globalThis = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
        function normalizeStyle$1(value) {
            if (isArray$2(value)) {
                const res = {};
                for (let i2 = 0; i2 < value.length; i2++) {
                    const item = value[i2], normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle$1(item);
                    if (normalized) for (const key2 in normalized) res[key2] = normalized[key2];
                }
                return res;
            }
            if (isString$1(value) || isObject$3(value)) return value;
        }
        const listDelimiterRE = /;(?![^(]*\))/g, propertyDelimiterRE = /:([^]+)/, styleCommentRE = /\/\*[^]*?\*\//g;
        function parseStringStyle(cssText) {
            const ret = {};
            return cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item => {
                if (item) {
                    const tmp = item.split(propertyDelimiterRE);
                    tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
                }
            })), ret;
        }
        function normalizeClass(value) {
            let res = "";
            if (isString$1(value)) res = value; else if (isArray$2(value)) for (let i2 = 0; i2 < value.length; i2++) {
                const normalized = normalizeClass(value[i2]);
                normalized && (res += normalized + " ");
            } else if (isObject$3(value)) for (const name in value) value[name] && (res += name + " ");
            return res.trim();
        }
        const isSpecialBooleanAttr = makeMap("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");
        function includeBooleanAttr(value) {
            return !!value || "" === value;
        }
        const isRef$1 = val => !(!val || !0 !== val.__v_isRef), toDisplayString = val => isString$1(val) ? val : null == val ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val), replacer = (_key, val) => isRef$1(val) ? replacer(_key, val.value) : isMap$1(val) ? {
            [`Map(${val.size})`]: [ ...val.entries() ].reduce(((entries, [key2, val2], i2) => (entries[stringifySymbol(key2, i2) + " =>"] = val2, 
            entries)), {})
        } : isSet$1(val) ? {
            [`Set(${val.size})`]: [ ...val.values() ].map((v2 => stringifySymbol(v2)))
        } : isSymbol$1(val) ? stringifySymbol(val) : !isObject$3(val) || isArray$2(val) || isPlainObject$1(val) ? val : String(val), stringifySymbol = (v2, i2 = "") => {
            var _a;
            return isSymbol$1(v2) ? `Symbol(${null != (_a = v2.description) ? _a : i2})` : v2;
        };
        let activeEffectScope, activeEffect;
        class EffectScope {
            constructor(detached = !1) {
                this.detached = detached, this._active = !0, this.effects = [], this.cleanups = [], 
                this.parent = activeEffectScope, !detached && activeEffectScope && (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1);
            }
            get active() {
                return this._active;
            }
            run(fn) {
                if (this._active) {
                    const currentEffectScope = activeEffectScope;
                    try {
                        return activeEffectScope = this, fn();
                    } finally {
                        activeEffectScope = currentEffectScope;
                    }
                }
            }
            on() {
                activeEffectScope = this;
            }
            off() {
                activeEffectScope = this.parent;
            }
            stop(fromParent) {
                if (this._active) {
                    let i2, l2;
                    for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) this.effects[i2].stop();
                    for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) this.cleanups[i2]();
                    if (this.scopes) for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) this.scopes[i2].stop(!0);
                    if (!this.detached && this.parent && !fromParent) {
                        const last2 = this.parent.scopes.pop();
                        last2 && last2 !== this && (this.parent.scopes[this.index] = last2, last2.index = this.index);
                    }
                    this.parent = void 0, this._active = !1;
                }
            }
        }
        function recordEffectScope(effect2, scope = activeEffectScope) {
            scope && scope.active && scope.effects.push(effect2);
        }
        function getCurrentScope() {
            return activeEffectScope;
        }
        class ReactiveEffect {
            constructor(fn, trigger2, scheduler, scope) {
                this.fn = fn, this.trigger = trigger2, this.scheduler = scheduler, this.active = !0, 
                this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, 
                this._depsLength = 0, recordEffectScope(this, scope);
            }
            get dirty() {
                if (2 === this._dirtyLevel || 3 === this._dirtyLevel) {
                    this._dirtyLevel = 1, pauseTracking();
                    for (let i2 = 0; i2 < this._depsLength; i2++) {
                        const dep = this.deps[i2];
                        if (dep.computed && (triggerComputed(dep.computed), this._dirtyLevel >= 4)) break;
                    }
                    1 === this._dirtyLevel && (this._dirtyLevel = 0), resetTracking();
                }
                return this._dirtyLevel >= 4;
            }
            set dirty(v2) {
                this._dirtyLevel = v2 ? 4 : 0;
            }
            run() {
                if (this._dirtyLevel = 0, !this.active) return this.fn();
                let lastShouldTrack = shouldTrack, lastEffect = activeEffect;
                try {
                    return shouldTrack = !0, activeEffect = this, this._runnings++, preCleanupEffect(this), 
                    this.fn();
                } finally {
                    postCleanupEffect(this), this._runnings--, activeEffect = lastEffect, shouldTrack = lastShouldTrack;
                }
            }
            stop() {
                this.active && (preCleanupEffect(this), postCleanupEffect(this), this.onStop && this.onStop(), 
                this.active = !1);
            }
        }
        function triggerComputed(computed2) {
            return computed2.value;
        }
        function preCleanupEffect(effect2) {
            effect2._trackId++, effect2._depsLength = 0;
        }
        function postCleanupEffect(effect2) {
            if (effect2.deps.length > effect2._depsLength) {
                for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) cleanupDepEffect(effect2.deps[i2], effect2);
                effect2.deps.length = effect2._depsLength;
            }
        }
        function cleanupDepEffect(dep, effect2) {
            const trackId = dep.get(effect2);
            void 0 !== trackId && effect2._trackId !== trackId && (dep.delete(effect2), 0 === dep.size && dep.cleanup());
        }
        let shouldTrack = !0, pauseScheduleStack = 0;
        const trackStack = [];
        function pauseTracking() {
            trackStack.push(shouldTrack), shouldTrack = !1;
        }
        function resetTracking() {
            const last2 = trackStack.pop();
            shouldTrack = void 0 === last2 || last2;
        }
        function pauseScheduling() {
            pauseScheduleStack++;
        }
        function resetScheduling() {
            for (pauseScheduleStack--; !pauseScheduleStack && queueEffectSchedulers.length; ) queueEffectSchedulers.shift()();
        }
        function trackEffect(effect2, dep, debuggerEventExtraInfo) {
            if (dep.get(effect2) !== effect2._trackId) {
                dep.set(effect2, effect2._trackId);
                const oldDep = effect2.deps[effect2._depsLength];
                oldDep !== dep ? (oldDep && cleanupDepEffect(oldDep, effect2), effect2.deps[effect2._depsLength++] = dep) : effect2._depsLength++;
            }
        }
        const queueEffectSchedulers = [];
        function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
            pauseScheduling();
            for (const effect2 of dep.keys()) {
                let tracking;
                effect2._dirtyLevel < dirtyLevel && (null != tracking ? tracking : tracking = dep.get(effect2) === effect2._trackId) && (effect2._shouldSchedule || (effect2._shouldSchedule = 0 === effect2._dirtyLevel), 
                effect2._dirtyLevel = dirtyLevel), effect2._shouldSchedule && (null != tracking ? tracking : tracking = dep.get(effect2) === effect2._trackId) && (effect2.trigger(), 
                effect2._runnings && !effect2.allowRecurse || 2 === effect2._dirtyLevel || (effect2._shouldSchedule = !1, 
                effect2.scheduler && queueEffectSchedulers.push(effect2.scheduler)));
            }
            resetScheduling();
        }
        const createDep = (cleanup2, computed2) => {
            const dep = new Map;
            return dep.cleanup = cleanup2, dep.computed = computed2, dep;
        }, targetMap = new WeakMap, ITERATE_KEY = Symbol(""), MAP_KEY_ITERATE_KEY = Symbol("");
        function track(target, type, key2) {
            if (shouldTrack && activeEffect) {
                let depsMap = targetMap.get(target);
                depsMap || targetMap.set(target, depsMap = new Map);
                let dep = depsMap.get(key2);
                dep || depsMap.set(key2, dep = createDep((() => depsMap.delete(key2)))), trackEffect(activeEffect, dep);
            }
        }
        function trigger(target, type, key2, newValue, oldValue, oldTarget) {
            const depsMap = targetMap.get(target);
            if (!depsMap) return;
            let deps = [];
            if ("clear" === type) deps = [ ...depsMap.values() ]; else if ("length" === key2 && isArray$2(target)) {
                const newLength = Number(newValue);
                depsMap.forEach(((dep, key22) => {
                    ("length" === key22 || !isSymbol$1(key22) && key22 >= newLength) && deps.push(dep);
                }));
            } else switch (void 0 !== key2 && deps.push(depsMap.get(key2)), type) {
              case "add":
                isArray$2(target) ? isIntegerKey(key2) && deps.push(depsMap.get("length")) : (deps.push(depsMap.get(ITERATE_KEY)), 
                isMap$1(target) && deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)));
                break;

              case "delete":
                isArray$2(target) || (deps.push(depsMap.get(ITERATE_KEY)), isMap$1(target) && deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)));
                break;

              case "set":
                isMap$1(target) && deps.push(depsMap.get(ITERATE_KEY));
            }
            pauseScheduling();
            for (const dep of deps) dep && triggerEffects(dep, 4);
            resetScheduling();
        }
        function getDepFromReactive(object, key2) {
            const depsMap = targetMap.get(object);
            return depsMap && depsMap.get(key2);
        }
        const isNonTrackableKeys = makeMap("__proto__,__v_isRef,__isVue"), builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter((key2 => "arguments" !== key2 && "caller" !== key2)).map((key2 => Symbol[key2])).filter(isSymbol$1)), arrayInstrumentations = createArrayInstrumentations();
        function createArrayInstrumentations() {
            const instrumentations = {};
            return [ "includes", "indexOf", "lastIndexOf" ].forEach((key2 => {
                instrumentations[key2] = function(...args) {
                    const arr = toRaw(this);
                    for (let i2 = 0, l2 = this.length; i2 < l2; i2++) track(arr, "get", i2 + "");
                    const res = arr[key2](...args);
                    return -1 === res || !1 === res ? arr[key2](...args.map(toRaw)) : res;
                };
            })), [ "push", "pop", "shift", "unshift", "splice" ].forEach((key2 => {
                instrumentations[key2] = function(...args) {
                    pauseTracking(), pauseScheduling();
                    const res = toRaw(this)[key2].apply(this, args);
                    return resetScheduling(), resetTracking(), res;
                };
            })), instrumentations;
        }
        function hasOwnProperty$f(key2) {
            isSymbol$1(key2) || (key2 = String(key2));
            const obj = toRaw(this);
            return track(obj, "has", key2), obj.hasOwnProperty(key2);
        }
        class BaseReactiveHandler {
            constructor(_isReadonly = !1, _isShallow = !1) {
                this._isReadonly = _isReadonly, this._isShallow = _isShallow;
            }
            get(target, key2, receiver) {
                const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
                if ("__v_isReactive" === key2) return !isReadonly2;
                if ("__v_isReadonly" === key2) return isReadonly2;
                if ("__v_isShallow" === key2) return isShallow2;
                if ("__v_raw" === key2) return receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver) ? target : void 0;
                const targetIsArray = isArray$2(target);
                if (!isReadonly2) {
                    if (targetIsArray && hasOwn$1(arrayInstrumentations, key2)) return Reflect.get(arrayInstrumentations, key2, receiver);
                    if ("hasOwnProperty" === key2) return hasOwnProperty$f;
                }
                const res = Reflect.get(target, key2, receiver);
                return (isSymbol$1(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) ? res : (isReadonly2 || track(target, "get", key2), 
                isShallow2 ? res : isRef(res) ? targetIsArray && isIntegerKey(key2) ? res : res.value : isObject$3(res) ? isReadonly2 ? readonly(res) : reactive(res) : res);
            }
        }
        class MutableReactiveHandler extends BaseReactiveHandler {
            constructor(isShallow2 = !1) {
                super(!1, isShallow2);
            }
            set(target, key2, value, receiver) {
                let oldValue = target[key2];
                if (!this._isShallow) {
                    const isOldValueReadonly = isReadonly(oldValue);
                    if (isShallow(value) || isReadonly(value) || (oldValue = toRaw(oldValue), value = toRaw(value)), 
                    !isArray$2(target) && isRef(oldValue) && !isRef(value)) return !isOldValueReadonly && (oldValue.value = value, 
                    !0);
                }
                const hadKey = isArray$2(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$1(target, key2), result = Reflect.set(target, key2, value, receiver);
                return target === toRaw(receiver) && (hadKey ? hasChanged(value, oldValue) && trigger(target, "set", key2, value) : trigger(target, "add", key2, value)), 
                result;
            }
            deleteProperty(target, key2) {
                const hadKey = hasOwn$1(target, key2);
                target[key2];
                const result = Reflect.deleteProperty(target, key2);
                return result && hadKey && trigger(target, "delete", key2, void 0), result;
            }
            has(target, key2) {
                const result = Reflect.has(target, key2);
                return isSymbol$1(key2) && builtInSymbols.has(key2) || track(target, "has", key2), 
                result;
            }
            ownKeys(target) {
                return track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY), Reflect.ownKeys(target);
            }
        }
        class ReadonlyReactiveHandler extends BaseReactiveHandler {
            constructor(isShallow2 = !1) {
                super(!0, isShallow2);
            }
            set(target, key2) {
                return !0;
            }
            deleteProperty(target, key2) {
                return !0;
            }
        }
        const mutableHandlers = new MutableReactiveHandler, readonlyHandlers = new ReadonlyReactiveHandler, shallowReactiveHandlers = new MutableReactiveHandler(!0), toShallow = value => value, getProto = v2 => Reflect.getPrototypeOf(v2);
        function get$2(target, key2, isReadonly2 = !1, isShallow2 = !1) {
            const rawTarget = toRaw(target = target.__v_raw), rawKey = toRaw(key2);
            isReadonly2 || (hasChanged(key2, rawKey) && track(rawTarget, "get", key2), track(rawTarget, "get", rawKey));
            const {has: has2} = getProto(rawTarget), wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
            return has2.call(rawTarget, key2) ? wrap(target.get(key2)) : has2.call(rawTarget, rawKey) ? wrap(target.get(rawKey)) : void (target !== rawTarget && target.get(key2));
        }
        function has(key2, isReadonly2 = !1) {
            const target = this.__v_raw, rawTarget = toRaw(target), rawKey = toRaw(key2);
            return isReadonly2 || (hasChanged(key2, rawKey) && track(rawTarget, "has", key2), 
            track(rawTarget, "has", rawKey)), key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
        }
        function size(target, isReadonly2 = !1) {
            return target = target.__v_raw, !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY), 
            Reflect.get(target, "size", target);
        }
        function add(value, _isShallow = !1) {
            _isShallow || isShallow(value) || isReadonly(value) || (value = toRaw(value));
            const target = toRaw(this);
            return getProto(target).has.call(target, value) || (target.add(value), trigger(target, "add", value, value)), 
            this;
        }
        function set$1(key2, value, _isShallow = !1) {
            _isShallow || isShallow(value) || isReadonly(value) || (value = toRaw(value));
            const target = toRaw(this), {has: has2, get: get2} = getProto(target);
            let hadKey = has2.call(target, key2);
            hadKey || (key2 = toRaw(key2), hadKey = has2.call(target, key2));
            const oldValue = get2.call(target, key2);
            return target.set(key2, value), hadKey ? hasChanged(value, oldValue) && trigger(target, "set", key2, value) : trigger(target, "add", key2, value), 
            this;
        }
        function deleteEntry(key2) {
            const target = toRaw(this), {has: has2, get: get2} = getProto(target);
            let hadKey = has2.call(target, key2);
            hadKey || (key2 = toRaw(key2), hadKey = has2.call(target, key2)), get2 && get2.call(target, key2);
            const result = target.delete(key2);
            return hadKey && trigger(target, "delete", key2, void 0), result;
        }
        function clear() {
            const target = toRaw(this), hadItems = 0 !== target.size, result = target.clear();
            return hadItems && trigger(target, "clear", void 0, void 0), result;
        }
        function createForEach(isReadonly2, isShallow2) {
            return function forEach(callback, thisArg) {
                const observed = this, target = observed.__v_raw, rawTarget = toRaw(target), wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
                return !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY), target.forEach(((value, key2) => callback.call(thisArg, wrap(value), wrap(key2), observed)));
            };
        }
        function createIterableMethod(method, isReadonly2, isShallow2) {
            return function(...args) {
                const target = this.__v_raw, rawTarget = toRaw(target), targetIsMap = isMap$1(rawTarget), isPair = "entries" === method || method === Symbol.iterator && targetIsMap, isKeyOnly = "keys" === method && targetIsMap, innerIterator = target[method](...args), wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive$1;
                return !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY), 
                {
                    next() {
                        const {value: value, done: done} = innerIterator.next();
                        return done ? {
                            value: value,
                            done: done
                        } : {
                            value: isPair ? [ wrap(value[0]), wrap(value[1]) ] : wrap(value),
                            done: done
                        };
                    },
                    [Symbol.iterator]() {
                        return this;
                    }
                };
            };
        }
        function createReadonlyMethod(type) {
            return function(...args) {
                return "delete" !== type && ("clear" === type ? void 0 : this);
            };
        }
        function createInstrumentations() {
            const mutableInstrumentations2 = {
                get(key2) {
                    return get$2(this, key2);
                },
                get size() {
                    return size(this);
                },
                has: has,
                add: add,
                set: set$1,
                delete: deleteEntry,
                clear: clear,
                forEach: createForEach(!1, !1)
            }, shallowInstrumentations2 = {
                get(key2) {
                    return get$2(this, key2, !1, !0);
                },
                get size() {
                    return size(this);
                },
                has: has,
                add(value) {
                    return add.call(this, value, !0);
                },
                set(key2, value) {
                    return set$1.call(this, key2, value, !0);
                },
                delete: deleteEntry,
                clear: clear,
                forEach: createForEach(!1, !0)
            }, readonlyInstrumentations2 = {
                get(key2) {
                    return get$2(this, key2, !0);
                },
                get size() {
                    return size(this, !0);
                },
                has(key2) {
                    return has.call(this, key2, !0);
                },
                add: createReadonlyMethod("add"),
                set: createReadonlyMethod("set"),
                delete: createReadonlyMethod("delete"),
                clear: createReadonlyMethod("clear"),
                forEach: createForEach(!0, !1)
            }, shallowReadonlyInstrumentations2 = {
                get(key2) {
                    return get$2(this, key2, !0, !0);
                },
                get size() {
                    return size(this, !0);
                },
                has(key2) {
                    return has.call(this, key2, !0);
                },
                add: createReadonlyMethod("add"),
                set: createReadonlyMethod("set"),
                delete: createReadonlyMethod("delete"),
                clear: createReadonlyMethod("clear"),
                forEach: createForEach(!0, !0)
            };
            return [ "keys", "values", "entries", Symbol.iterator ].forEach((method => {
                mutableInstrumentations2[method] = createIterableMethod(method, !1, !1), readonlyInstrumentations2[method] = createIterableMethod(method, !0, !1), 
                shallowInstrumentations2[method] = createIterableMethod(method, !1, !0), shallowReadonlyInstrumentations2[method] = createIterableMethod(method, !0, !0);
            })), [ mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2 ];
        }
        const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = createInstrumentations();
        function createInstrumentationGetter(isReadonly2, shallow) {
            const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
            return (target, key2, receiver) => "__v_isReactive" === key2 ? !isReadonly2 : "__v_isReadonly" === key2 ? isReadonly2 : "__v_raw" === key2 ? target : Reflect.get(hasOwn$1(instrumentations, key2) && key2 in target ? instrumentations : target, key2, receiver);
        }
        const mutableCollectionHandlers = {
            get: createInstrumentationGetter(!1, !1)
        }, shallowCollectionHandlers = {
            get: createInstrumentationGetter(!1, !0)
        }, readonlyCollectionHandlers = {
            get: createInstrumentationGetter(!0, !1)
        }, reactiveMap = new WeakMap, shallowReactiveMap = new WeakMap, readonlyMap = new WeakMap, shallowReadonlyMap = new WeakMap;
        function targetTypeMap(rawType) {
            switch (rawType) {
              case "Object":
              case "Array":
                return 1;

              case "Map":
              case "Set":
              case "WeakMap":
              case "WeakSet":
                return 2;

              default:
                return 0;
            }
        }
        function getTargetType(value) {
            return value.__v_skip || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
        }
        function reactive(target) {
            return isReadonly(target) ? target : createReactiveObject(target, !1, mutableHandlers, mutableCollectionHandlers, reactiveMap);
        }
        function shallowReactive(target) {
            return createReactiveObject(target, !1, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
        }
        function readonly(target) {
            return createReactiveObject(target, !0, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
        }
        function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
            if (!isObject$3(target)) return target;
            if (target.__v_raw && (!isReadonly2 || !target.__v_isReactive)) return target;
            const existingProxy = proxyMap.get(target);
            if (existingProxy) return existingProxy;
            const targetType = getTargetType(target);
            if (0 === targetType) return target;
            const proxy = new Proxy(target, 2 === targetType ? collectionHandlers : baseHandlers);
            return proxyMap.set(target, proxy), proxy;
        }
        function isReactive(value) {
            return isReadonly(value) ? isReactive(value.__v_raw) : !(!value || !value.__v_isReactive);
        }
        function isReadonly(value) {
            return !(!value || !value.__v_isReadonly);
        }
        function isShallow(value) {
            return !(!value || !value.__v_isShallow);
        }
        function isProxy(value) {
            return !!value && !!value.__v_raw;
        }
        function toRaw(observed) {
            const raw = observed && observed.__v_raw;
            return raw ? toRaw(raw) : observed;
        }
        function markRaw(value) {
            return Object.isExtensible(value) && def(value, "__v_skip", !0), value;
        }
        const toReactive$1 = value => isObject$3(value) ? reactive(value) : value, toReadonly = value => isObject$3(value) ? readonly(value) : value;
        class ComputedRefImpl {
            constructor(getter, _setter, isReadonly2, isSSR) {
                this.getter = getter, this._setter = _setter, this.dep = void 0, this.__v_isRef = !0, 
                this.__v_isReadonly = !1, this.effect = new ReactiveEffect((() => getter(this._value)), (() => triggerRefValue(this, 2 === this.effect._dirtyLevel ? 2 : 3))), 
                this.effect.computed = this, this.effect.active = this._cacheable = !isSSR, this.__v_isReadonly = isReadonly2;
            }
            get value() {
                const self2 = toRaw(this);
                return self2._cacheable && !self2.effect.dirty || !hasChanged(self2._value, self2._value = self2.effect.run()) || triggerRefValue(self2, 4), 
                trackRefValue(self2), self2.effect._dirtyLevel >= 2 && triggerRefValue(self2, 2), 
                self2._value;
            }
            set value(newValue) {
                this._setter(newValue);
            }
            get _dirty() {
                return this.effect.dirty;
            }
            set _dirty(v2) {
                this.effect.dirty = v2;
            }
        }
        function computed$1(getterOrOptions, debugOptions, isSSR = !1) {
            let getter, setter;
            const onlyGetter = isFunction$2(getterOrOptions);
            onlyGetter ? (getter = getterOrOptions, setter = NOOP) : (getter = getterOrOptions.get, 
            setter = getterOrOptions.set);
            return new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
        }
        function trackRefValue(ref2) {
            var _a;
            shouldTrack && activeEffect && (ref2 = toRaw(ref2), trackEffect(activeEffect, null != (_a = ref2.dep) ? _a : ref2.dep = createDep((() => ref2.dep = void 0), ref2 instanceof ComputedRefImpl ? ref2 : void 0)));
        }
        function triggerRefValue(ref2, dirtyLevel = 4, newVal, oldVal) {
            const dep = (ref2 = toRaw(ref2)).dep;
            dep && triggerEffects(dep, dirtyLevel);
        }
        function isRef(r2) {
            return !(!r2 || !0 !== r2.__v_isRef);
        }
        function ref(value) {
            return createRef$1(value, !1);
        }
        function shallowRef(value) {
            return createRef$1(value, !0);
        }
        function createRef$1(rawValue, shallow) {
            return isRef(rawValue) ? rawValue : new RefImpl(rawValue, shallow);
        }
        class RefImpl {
            constructor(value, __v_isShallow) {
                this.__v_isShallow = __v_isShallow, this.dep = void 0, this.__v_isRef = !0, this._rawValue = __v_isShallow ? value : toRaw(value), 
                this._value = __v_isShallow ? value : toReactive$1(value);
            }
            get value() {
                return trackRefValue(this), this._value;
            }
            set value(newVal) {
                const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
                newVal = useDirectValue ? newVal : toRaw(newVal), hasChanged(newVal, this._rawValue) && (this._rawValue, 
                this._rawValue = newVal, this._value = useDirectValue ? newVal : toReactive$1(newVal), 
                triggerRefValue(this, 4));
            }
        }
        function triggerRef(ref2) {
            triggerRefValue(ref2, 4);
        }
        function unref(ref2) {
            return isRef(ref2) ? ref2.value : ref2;
        }
        const shallowUnwrapHandlers = {
            get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
            set: (target, key2, value, receiver) => {
                const oldValue = target[key2];
                return isRef(oldValue) && !isRef(value) ? (oldValue.value = value, !0) : Reflect.set(target, key2, value, receiver);
            }
        };
        function proxyRefs(objectWithRefs) {
            return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
        }
        function toRefs(object) {
            const ret = isArray$2(object) ? new Array(object.length) : {};
            for (const key2 in object) ret[key2] = propertyToRef(object, key2);
            return ret;
        }
        class ObjectRefImpl {
            constructor(_object, _key, _defaultValue) {
                this._object = _object, this._key = _key, this._defaultValue = _defaultValue, this.__v_isRef = !0;
            }
            get value() {
                const val = this._object[this._key];
                return void 0 === val ? this._defaultValue : val;
            }
            set value(newVal) {
                this._object[this._key] = newVal;
            }
            get dep() {
                return getDepFromReactive(toRaw(this._object), this._key);
            }
        }
        class GetterRefImpl {
            constructor(_getter) {
                this._getter = _getter, this.__v_isRef = !0, this.__v_isReadonly = !0;
            }
            get value() {
                return this._getter();
            }
        }
        function toRef(source, key2, defaultValue) {
            return isRef(source) ? source : isFunction$2(source) ? new GetterRefImpl(source) : isObject$3(source) && arguments.length > 1 ? propertyToRef(source, key2, defaultValue) : ref(source);
        }
        function propertyToRef(source, key2, defaultValue) {
            const val = source[key2];
            return isRef(val) ? val : new ObjectRefImpl(source, key2, defaultValue);
        }
        function callWithErrorHandling(fn, instance, type, args) {
            try {
                return args ? fn(...args) : fn();
            } catch (err) {
                handleError(err, instance, type);
            }
        }
        function callWithAsyncErrorHandling(fn, instance, type, args) {
            if (isFunction$2(fn)) {
                const res = callWithErrorHandling(fn, instance, type, args);
                return res && isPromise(res) && res.catch((err => {
                    handleError(err, instance, type);
                })), res;
            }
            if (isArray$2(fn)) {
                const values = [];
                for (let i2 = 0; i2 < fn.length; i2++) values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
                return values;
            }
        }
        function handleError(err, instance, type, throwInDev = !0) {
            const contextVNode = instance ? instance.vnode : null;
            if (instance) {
                let cur = instance.parent;
                const exposedInstance = instance.proxy, errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
                for (;cur; ) {
                    const errorCapturedHooks = cur.ec;
                    if (errorCapturedHooks) for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) if (!1 === errorCapturedHooks[i2](err, exposedInstance, errorInfo)) return;
                    cur = cur.parent;
                }
                const appErrorHandler = instance.appContext.config.errorHandler;
                if (appErrorHandler) return pauseTracking(), callWithErrorHandling(appErrorHandler, null, 10, [ err, exposedInstance, errorInfo ]), 
                void resetTracking();
            }
            logError(err, type, contextVNode, throwInDev);
        }
        function logError(err, type, contextVNode, throwInDev = !0) {}
        let isFlushing = !1, isFlushPending = !1;
        const queue = [];
        let flushIndex = 0;
        const pendingPostFlushCbs = [];
        let activePostFlushCbs = null, postFlushIndex = 0;
        const resolvedPromise = Promise.resolve();
        let currentFlushPromise = null;
        function nextTick(fn) {
            const p2 = currentFlushPromise || resolvedPromise;
            return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
        }
        function findInsertionIndex(id) {
            let start = flushIndex + 1, end = queue.length;
            for (;start < end; ) {
                const middle = start + end >>> 1, middleJob = queue[middle], middleJobId = getId(middleJob);
                middleJobId < id || middleJobId === id && middleJob.pre ? start = middle + 1 : end = middle;
            }
            return start;
        }
        function queueJob(job) {
            queue.length && queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex) || (null == job.id ? queue.push(job) : queue.splice(findInsertionIndex(job.id), 0, job), 
            queueFlush());
        }
        function queueFlush() {
            isFlushing || isFlushPending || (isFlushPending = !0, currentFlushPromise = resolvedPromise.then(flushJobs));
        }
        function invalidateJob(job) {
            const i2 = queue.indexOf(job);
            i2 > flushIndex && queue.splice(i2, 1);
        }
        function queuePostFlushCb(cb) {
            isArray$2(cb) ? pendingPostFlushCbs.push(...cb) : activePostFlushCbs && activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex) || pendingPostFlushCbs.push(cb), 
            queueFlush();
        }
        function flushPreFlushCbs(instance, seen, i2 = (isFlushing ? flushIndex + 1 : 0)) {
            for (;i2 < queue.length; i2++) {
                const cb = queue[i2];
                if (cb && cb.pre) {
                    if (instance && cb.id !== instance.uid) continue;
                    queue.splice(i2, 1), i2--, cb();
                }
            }
        }
        function flushPostFlushCbs(seen) {
            if (pendingPostFlushCbs.length) {
                const deduped = [ ...new Set(pendingPostFlushCbs) ].sort(((a2, b2) => getId(a2) - getId(b2)));
                if (pendingPostFlushCbs.length = 0, activePostFlushCbs) return void activePostFlushCbs.push(...deduped);
                for (activePostFlushCbs = deduped, postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
                    const cb = activePostFlushCbs[postFlushIndex];
                    !1 !== cb.active && cb();
                }
                activePostFlushCbs = null, postFlushIndex = 0;
            }
        }
        const getId = job => null == job.id ? 1 / 0 : job.id, comparator = (a2, b2) => {
            const diff = getId(a2) - getId(b2);
            if (0 === diff) {
                if (a2.pre && !b2.pre) return -1;
                if (b2.pre && !a2.pre) return 1;
            }
            return diff;
        };
        function flushJobs(seen) {
            isFlushPending = !1, isFlushing = !0, queue.sort(comparator);
            try {
                for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
                    const job = queue[flushIndex];
                    job && !1 !== job.active && callWithErrorHandling(job, job.i, job.i ? 15 : 14);
                }
            } finally {
                flushIndex = 0, queue.length = 0, flushPostFlushCbs(), isFlushing = !1, currentFlushPromise = null, 
                (queue.length || pendingPostFlushCbs.length) && flushJobs();
            }
        }
        let currentRenderingInstance = null, currentScopeId = null;
        function setCurrentRenderingInstance(instance) {
            const prev2 = currentRenderingInstance;
            return currentRenderingInstance = instance, currentScopeId = instance && instance.type.__scopeId || null, 
            prev2;
        }
        function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
            if (!ctx) return fn;
            if (fn._n) return fn;
            const renderFnWithContext = (...args) => {
                renderFnWithContext._d && setBlockTracking(-1);
                const prevInstance = setCurrentRenderingInstance(ctx);
                let res;
                try {
                    res = fn(...args);
                } finally {
                    setCurrentRenderingInstance(prevInstance), renderFnWithContext._d && setBlockTracking(1);
                }
                return res;
            };
            return renderFnWithContext._n = !0, renderFnWithContext._c = !0, renderFnWithContext._d = !0, 
            renderFnWithContext;
        }
        function withDirectives(vnode, directives) {
            if (null === currentRenderingInstance) return vnode;
            const instance = getComponentPublicInstance(currentRenderingInstance), bindings = vnode.dirs || (vnode.dirs = []);
            for (let i2 = 0; i2 < directives.length; i2++) {
                let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
                dir && (isFunction$2(dir) && (dir = {
                    mounted: dir,
                    updated: dir
                }), dir.deep && traverse(value), bindings.push({
                    dir: dir,
                    instance: instance,
                    value: value,
                    oldValue: void 0,
                    arg: arg,
                    modifiers: modifiers
                }));
            }
            return vnode;
        }
        function invokeDirectiveHook(vnode, prevVNode, instance, name) {
            const bindings = vnode.dirs, oldBindings = prevVNode && prevVNode.dirs;
            for (let i2 = 0; i2 < bindings.length; i2++) {
                const binding = bindings[i2];
                oldBindings && (binding.oldValue = oldBindings[i2].value);
                let hook = binding.dir[name];
                hook && (pauseTracking(), callWithAsyncErrorHandling(hook, instance, 8, [ vnode.el, binding, vnode, prevVNode ]), 
                resetTracking());
            }
        }
        const leaveCbKey = Symbol("_leaveCb"), enterCbKey$1 = Symbol("_enterCb");
        function useTransitionState() {
            const state = {
                isMounted: !1,
                isLeaving: !1,
                isUnmounting: !1,
                leavingVNodes: new Map
            };
            return onMounted((() => {
                state.isMounted = !0;
            })), onBeforeUnmount((() => {
                state.isUnmounting = !0;
            })), state;
        }
        const TransitionHookValidator = [ Function, Array ], BaseTransitionPropsValidators = {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: TransitionHookValidator,
            onEnter: TransitionHookValidator,
            onAfterEnter: TransitionHookValidator,
            onEnterCancelled: TransitionHookValidator,
            onBeforeLeave: TransitionHookValidator,
            onLeave: TransitionHookValidator,
            onAfterLeave: TransitionHookValidator,
            onLeaveCancelled: TransitionHookValidator,
            onBeforeAppear: TransitionHookValidator,
            onAppear: TransitionHookValidator,
            onAfterAppear: TransitionHookValidator,
            onAppearCancelled: TransitionHookValidator
        }, recursiveGetSubtree = instance => {
            const subTree = instance.subTree;
            return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
        }, BaseTransition = {
            name: "BaseTransition",
            props: BaseTransitionPropsValidators,
            setup(props2, {slots: slots}) {
                const instance = getCurrentInstance(), state = useTransitionState();
                return () => {
                    const children = slots.default && getTransitionRawChildren(slots.default(), !0);
                    if (!children || !children.length) return;
                    let child = children[0];
                    if (children.length > 1) for (const c2 of children) if (c2.type !== Comment) {
                        child = c2;
                        break;
                    }
                    const rawProps = toRaw(props2), {mode: mode} = rawProps;
                    if (state.isLeaving) return emptyPlaceholder(child);
                    const innerChild = getKeepAliveChild(child);
                    if (!innerChild) return emptyPlaceholder(child);
                    let enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance, (hooks => enterHooks = hooks));
                    setTransitionHooks(innerChild, enterHooks);
                    const oldChild = instance.subTree, oldInnerChild = oldChild && getKeepAliveChild(oldChild);
                    if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
                        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                        if (setTransitionHooks(oldInnerChild, leavingHooks), "out-in" === mode && innerChild.type !== Comment) return state.isLeaving = !0, 
                        leavingHooks.afterLeave = () => {
                            state.isLeaving = !1, !1 !== instance.update.active && (instance.effect.dirty = !0, 
                            instance.update());
                        }, emptyPlaceholder(child);
                        "in-out" === mode && innerChild.type !== Comment && (leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                            getLeavingNodesForType(state, oldInnerChild)[String(oldInnerChild.key)] = oldInnerChild, 
                            el[leaveCbKey] = () => {
                                earlyRemove(), el[leaveCbKey] = void 0, delete enterHooks.delayedLeave;
                            }, enterHooks.delayedLeave = delayedLeave;
                        });
                    }
                    return child;
                };
            }
        };
        function getLeavingNodesForType(state, vnode) {
            const {leavingVNodes: leavingVNodes} = state;
            let leavingVNodesCache = leavingVNodes.get(vnode.type);
            return leavingVNodesCache || (leavingVNodesCache = Object.create(null), leavingVNodes.set(vnode.type, leavingVNodesCache)), 
            leavingVNodesCache;
        }
        function resolveTransitionHooks(vnode, props2, state, instance, postClone) {
            const {appear: appear, mode: mode, persisted: persisted = !1, onBeforeEnter: onBeforeEnter, onEnter: onEnter, onAfterEnter: onAfterEnter, onEnterCancelled: onEnterCancelled, onBeforeLeave: onBeforeLeave, onLeave: onLeave, onAfterLeave: onAfterLeave, onLeaveCancelled: onLeaveCancelled, onBeforeAppear: onBeforeAppear, onAppear: onAppear, onAfterAppear: onAfterAppear, onAppearCancelled: onAppearCancelled} = props2, key2 = String(vnode.key), leavingVNodesCache = getLeavingNodesForType(state, vnode), callHook2 = (hook, args) => {
                hook && callWithAsyncErrorHandling(hook, instance, 9, args);
            }, callAsyncHook = (hook, args) => {
                const done = args[1];
                callHook2(hook, args), isArray$2(hook) ? hook.every((hook2 => hook2.length <= 1)) && done() : hook.length <= 1 && done();
            }, hooks = {
                mode: mode,
                persisted: persisted,
                beforeEnter(el) {
                    let hook = onBeforeEnter;
                    if (!state.isMounted) {
                        if (!appear) return;
                        hook = onBeforeAppear || onBeforeEnter;
                    }
                    el[leaveCbKey] && el[leaveCbKey](!0);
                    const leavingVNode = leavingVNodesCache[key2];
                    leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey] && leavingVNode.el[leaveCbKey](), 
                    callHook2(hook, [ el ]);
                },
                enter(el) {
                    let hook = onEnter, afterHook = onAfterEnter, cancelHook = onEnterCancelled;
                    if (!state.isMounted) {
                        if (!appear) return;
                        hook = onAppear || onEnter, afterHook = onAfterAppear || onAfterEnter, cancelHook = onAppearCancelled || onEnterCancelled;
                    }
                    let called = !1;
                    const done = el[enterCbKey$1] = cancelled => {
                        called || (called = !0, callHook2(cancelled ? cancelHook : afterHook, [ el ]), hooks.delayedLeave && hooks.delayedLeave(), 
                        el[enterCbKey$1] = void 0);
                    };
                    hook ? callAsyncHook(hook, [ el, done ]) : done();
                },
                leave(el, remove2) {
                    const key22 = String(vnode.key);
                    if (el[enterCbKey$1] && el[enterCbKey$1](!0), state.isUnmounting) return remove2();
                    callHook2(onBeforeLeave, [ el ]);
                    let called = !1;
                    const done = el[leaveCbKey] = cancelled => {
                        called || (called = !0, remove2(), callHook2(cancelled ? onLeaveCancelled : onAfterLeave, [ el ]), 
                        el[leaveCbKey] = void 0, leavingVNodesCache[key22] === vnode && delete leavingVNodesCache[key22]);
                    };
                    leavingVNodesCache[key22] = vnode, onLeave ? callAsyncHook(onLeave, [ el, done ]) : done();
                },
                clone(vnode2) {
                    const hooks2 = resolveTransitionHooks(vnode2, props2, state, instance, postClone);
                    return postClone && postClone(hooks2), hooks2;
                }
            };
            return hooks;
        }
        function emptyPlaceholder(vnode) {
            if (isKeepAlive(vnode)) return (vnode = cloneVNode(vnode)).children = null, vnode;
        }
        function getKeepAliveChild(vnode) {
            if (!isKeepAlive(vnode)) return vnode;
            const {shapeFlag: shapeFlag, children: children} = vnode;
            if (children) {
                if (16 & shapeFlag) return children[0];
                if (32 & shapeFlag && isFunction$2(children.default)) return children.default();
            }
        }
        function setTransitionHooks(vnode, hooks) {
            6 & vnode.shapeFlag && vnode.component ? setTransitionHooks(vnode.component.subTree, hooks) : 128 & vnode.shapeFlag ? (vnode.ssContent.transition = hooks.clone(vnode.ssContent), 
            vnode.ssFallback.transition = hooks.clone(vnode.ssFallback)) : vnode.transition = hooks;
        }
        function getTransitionRawChildren(children, keepComment = !1, parentKey) {
            let ret = [], keyedFragmentCount = 0;
            for (let i2 = 0; i2 < children.length; i2++) {
                let child = children[i2];
                const key2 = null == parentKey ? child.key : String(parentKey) + String(null != child.key ? child.key : i2);
                child.type === Fragment ? (128 & child.patchFlag && keyedFragmentCount++, ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key2))) : (keepComment || child.type !== Comment) && ret.push(null != key2 ? cloneVNode(child, {
                    key: key2
                }) : child);
            }
            if (keyedFragmentCount > 1) for (let i2 = 0; i2 < ret.length; i2++) ret[i2].patchFlag = -2;
            return ret;
        }
        function defineComponent(options, extraOptions) {
            return isFunction$2(options) ? (() => extend({
                name: options.name
            }, extraOptions, {
                setup: options
            }))() : options;
        }
        const isAsyncWrapper = i2 => !!i2.type.__asyncLoader, isKeepAlive = vnode => vnode.type.__isKeepAlive;
        function onActivated(hook, target) {
            registerKeepAliveHook(hook, "a", target);
        }
        function onDeactivated(hook, target) {
            registerKeepAliveHook(hook, "da", target);
        }
        function registerKeepAliveHook(hook, type, target = currentInstance) {
            const wrappedHook = hook.__wdc || (hook.__wdc = () => {
                let current = target;
                for (;current; ) {
                    if (current.isDeactivated) return;
                    current = current.parent;
                }
                return hook();
            });
            if (injectHook(type, wrappedHook, target), target) {
                let current = target.parent;
                for (;current && current.parent; ) isKeepAlive(current.parent.vnode) && injectToKeepAliveRoot(wrappedHook, type, target, current), 
                current = current.parent;
            }
        }
        function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
            const injected = injectHook(type, hook, keepAliveRoot, !0);
            onUnmounted((() => {
                remove(keepAliveRoot[type], injected);
            }), target);
        }
        function injectHook(type, hook, target = currentInstance, prepend = !1) {
            if (target) {
                const hooks = target[type] || (target[type] = []), wrappedHook = hook.__weh || (hook.__weh = (...args) => {
                    pauseTracking();
                    const reset = setCurrentInstance(target), res = callWithAsyncErrorHandling(hook, target, type, args);
                    return reset(), resetTracking(), res;
                });
                return prepend ? hooks.unshift(wrappedHook) : hooks.push(wrappedHook), wrappedHook;
            }
        }
        const createHook = lifecycle => (hook, target = currentInstance) => {
            isInSSRComponentSetup && "sp" !== lifecycle || injectHook(lifecycle, ((...args) => hook(...args)), target);
        }, onBeforeMount = createHook("bm"), onMounted = createHook("m"), onBeforeUpdate = createHook("bu"), onUpdated = createHook("u"), onBeforeUnmount = createHook("bum"), onUnmounted = createHook("um"), onServerPrefetch = createHook("sp"), onRenderTriggered = createHook("rtg"), onRenderTracked = createHook("rtc");
        function onErrorCaptured(hook, target = currentInstance) {
            injectHook("ec", hook, target);
        }
        const DIRECTIVES = "directives", NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
        function resolveDirective(name) {
            return resolveAsset(DIRECTIVES, name);
        }
        function resolveAsset(type, name, warnMissing = !0, maybeSelfReference = !1) {
            const instance = currentRenderingInstance || currentInstance;
            if (instance) {
                const Component = instance.type, res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
                return !res && maybeSelfReference ? Component : res;
            }
        }
        function resolve(registry, name) {
            return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize$1(camelize$1(name))]);
        }
        function renderList(source, renderItem, cache, index2) {
            let ret;
            const cached2 = cache;
            if (isArray$2(source) || isString$1(source)) {
                ret = new Array(source.length);
                for (let i2 = 0, l2 = source.length; i2 < l2; i2++) ret[i2] = renderItem(source[i2], i2, void 0, cached2);
            } else if ("number" == typeof source) {
                ret = new Array(source);
                for (let i2 = 0; i2 < source; i2++) ret[i2] = renderItem(i2 + 1, i2, void 0, cached2);
            } else if (isObject$3(source)) if (source[Symbol.iterator]) ret = Array.from(source, ((item, i2) => renderItem(item, i2, void 0, cached2))); else {
                const keys2 = Object.keys(source);
                ret = new Array(keys2.length);
                for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
                    const key2 = keys2[i2];
                    ret[i2] = renderItem(source[key2], key2, i2, cached2);
                }
            } else ret = [];
            return ret;
        }
        const getPublicInstance = i2 => i2 ? isStatefulComponent(i2) ? getComponentPublicInstance(i2) : getPublicInstance(i2.parent) : null, publicPropertiesMap = extend(Object.create(null), {
            $: i2 => i2,
            $el: i2 => i2.vnode.el,
            $data: i2 => i2.data,
            $props: i2 => i2.props,
            $attrs: i2 => i2.attrs,
            $slots: i2 => i2.slots,
            $refs: i2 => i2.refs,
            $parent: i2 => getPublicInstance(i2.parent),
            $root: i2 => getPublicInstance(i2.root),
            $emit: i2 => i2.emit,
            $options: i2 => resolveMergedOptions(i2),
            $forceUpdate: i2 => i2.f || (i2.f = () => {
                i2.effect.dirty = !0, queueJob(i2.update);
            }),
            $nextTick: i2 => i2.n || (i2.n = nextTick.bind(i2.proxy)),
            $watch: i2 => instanceWatch.bind(i2)
        }), hasSetupBinding = (state, key2) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key2), PublicInstanceProxyHandlers = {
            get({_: instance}, key2) {
                if ("__v_skip" === key2) return !0;
                const {ctx: ctx, setupState: setupState, data: data, props: props2, accessCache: accessCache, type: type, appContext: appContext} = instance;
                let normalizedProps;
                if ("$" !== key2[0]) {
                    const n2 = accessCache[key2];
                    if (void 0 !== n2) switch (n2) {
                      case 1:
                        return setupState[key2];

                      case 2:
                        return data[key2];

                      case 4:
                        return ctx[key2];

                      case 3:
                        return props2[key2];
                    } else {
                        if (hasSetupBinding(setupState, key2)) return accessCache[key2] = 1, setupState[key2];
                        if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) return accessCache[key2] = 2, data[key2];
                        if ((normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key2)) return accessCache[key2] = 3, 
                        props2[key2];
                        if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) return accessCache[key2] = 4, ctx[key2];
                        shouldCacheAccess && (accessCache[key2] = 0);
                    }
                }
                const publicGetter = publicPropertiesMap[key2];
                let cssModule, globalProperties;
                return publicGetter ? ("$attrs" === key2 && track(instance.attrs, "get", ""), publicGetter(instance)) : (cssModule = type.__cssModules) && (cssModule = cssModule[key2]) ? cssModule : ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2) ? (accessCache[key2] = 4, 
                ctx[key2]) : (globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key2) ? globalProperties[key2] : void 0);
            },
            set({_: instance}, key2, value) {
                const {data: data, setupState: setupState, ctx: ctx} = instance;
                return hasSetupBinding(setupState, key2) ? (setupState[key2] = value, !0) : data !== EMPTY_OBJ && hasOwn$1(data, key2) ? (data[key2] = value, 
                !0) : !hasOwn$1(instance.props, key2) && (("$" !== key2[0] || !(key2.slice(1) in instance)) && (ctx[key2] = value, 
                !0));
            },
            has({_: {data: data, setupState: setupState, accessCache: accessCache, ctx: ctx, appContext: appContext, propsOptions: propsOptions}}, key2) {
                let normalizedProps;
                return !!accessCache[key2] || data !== EMPTY_OBJ && hasOwn$1(data, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key2) || hasOwn$1(ctx, key2) || hasOwn$1(publicPropertiesMap, key2) || hasOwn$1(appContext.config.globalProperties, key2);
            },
            defineProperty(target, key2, descriptor) {
                return null != descriptor.get ? target._.accessCache[key2] = 0 : hasOwn$1(descriptor, "value") && this.set(target, key2, descriptor.value, null), 
                Reflect.defineProperty(target, key2, descriptor);
            }
        };
        function normalizePropsOrEmits(props2) {
            return isArray$2(props2) ? props2.reduce(((normalized, p2) => (normalized[p2] = null, 
            normalized)), {}) : props2;
        }
        let shouldCacheAccess = !0;
        function applyOptions(instance) {
            const options = resolveMergedOptions(instance), publicThis = instance.proxy, ctx = instance.ctx;
            shouldCacheAccess = !1, options.beforeCreate && callHook$1(options.beforeCreate, instance, "bc");
            const {data: dataOptions, computed: computedOptions, methods: methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, created: created, beforeMount: beforeMount, mounted: mounted, beforeUpdate: beforeUpdate, updated: updated, activated: activated, deactivated: deactivated, beforeDestroy: beforeDestroy, beforeUnmount: beforeUnmount, destroyed: destroyed, unmounted: unmounted, render: render2, renderTracked: renderTracked, renderTriggered: renderTriggered, errorCaptured: errorCaptured, serverPrefetch: serverPrefetch, expose: expose, inheritAttrs: inheritAttrs, components: components, directives: directives, filters: filters} = options;
            if (injectOptions && resolveInjections(injectOptions, ctx, null), methods) for (const key2 in methods) {
                const methodHandler = methods[key2];
                isFunction$2(methodHandler) && (ctx[key2] = methodHandler.bind(publicThis));
            }
            if (dataOptions) {
                const data = dataOptions.call(publicThis, publicThis);
                isObject$3(data) && (instance.data = reactive(data));
            }
            if (shouldCacheAccess = !0, computedOptions) for (const key2 in computedOptions) {
                const opt = computedOptions[key2], get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP, set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP, c2 = computed({
                    get: get2,
                    set: set2
                });
                Object.defineProperty(ctx, key2, {
                    enumerable: !0,
                    configurable: !0,
                    get: () => c2.value,
                    set: v2 => c2.value = v2
                });
            }
            if (watchOptions) for (const key2 in watchOptions) createWatcher(watchOptions[key2], ctx, publicThis, key2);
            if (provideOptions) {
                const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
                Reflect.ownKeys(provides).forEach((key2 => {
                    provide(key2, provides[key2]);
                }));
            }
            function registerLifecycleHook(register, hook) {
                isArray$2(hook) ? hook.forEach((_hook => register(_hook.bind(publicThis)))) : hook && register(hook.bind(publicThis));
            }
            if (created && callHook$1(created, instance, "c"), registerLifecycleHook(onBeforeMount, beforeMount), 
            registerLifecycleHook(onMounted, mounted), registerLifecycleHook(onBeforeUpdate, beforeUpdate), 
            registerLifecycleHook(onUpdated, updated), registerLifecycleHook(onActivated, activated), 
            registerLifecycleHook(onDeactivated, deactivated), registerLifecycleHook(onErrorCaptured, errorCaptured), 
            registerLifecycleHook(onRenderTracked, renderTracked), registerLifecycleHook(onRenderTriggered, renderTriggered), 
            registerLifecycleHook(onBeforeUnmount, beforeUnmount), registerLifecycleHook(onUnmounted, unmounted), 
            registerLifecycleHook(onServerPrefetch, serverPrefetch), isArray$2(expose)) if (expose.length) {
                const exposed = instance.exposed || (instance.exposed = {});
                expose.forEach((key2 => {
                    Object.defineProperty(exposed, key2, {
                        get: () => publicThis[key2],
                        set: val => publicThis[key2] = val
                    });
                }));
            } else instance.exposed || (instance.exposed = {});
            render2 && instance.render === NOOP && (instance.render = render2), null != inheritAttrs && (instance.inheritAttrs = inheritAttrs), 
            components && (instance.components = components), directives && (instance.directives = directives);
        }
        function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
            isArray$2(injectOptions) && (injectOptions = normalizeInject(injectOptions));
            for (const key2 in injectOptions) {
                const opt = injectOptions[key2];
                let injected;
                injected = isObject$3(opt) ? "default" in opt ? inject(opt.from || key2, opt.default, !0) : inject(opt.from || key2) : inject(opt), 
                isRef(injected) ? Object.defineProperty(ctx, key2, {
                    enumerable: !0,
                    configurable: !0,
                    get: () => injected.value,
                    set: v2 => injected.value = v2
                }) : ctx[key2] = injected;
            }
        }
        function callHook$1(hook, instance, type) {
            callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2 => h2.bind(instance.proxy))) : hook.bind(instance.proxy), instance, type);
        }
        function createWatcher(raw, ctx, publicThis, key2) {
            const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
            if (isString$1(raw)) {
                const handler = ctx[raw];
                isFunction$2(handler) && watch(getter, handler);
            } else if (isFunction$2(raw)) watch(getter, raw.bind(publicThis)); else if (isObject$3(raw)) if (isArray$2(raw)) raw.forEach((r2 => createWatcher(r2, ctx, publicThis, key2))); else {
                const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
                isFunction$2(handler) && watch(getter, handler, raw);
            }
        }
        function resolveMergedOptions(instance) {
            const base = instance.type, {mixins: mixins, extends: extendsOptions} = base, {mixins: globalMixins, optionsCache: cache, config: {optionMergeStrategies: optionMergeStrategies}} = instance.appContext, cached2 = cache.get(base);
            let resolved;
            return cached2 ? resolved = cached2 : globalMixins.length || mixins || extendsOptions ? (resolved = {}, 
            globalMixins.length && globalMixins.forEach((m2 => mergeOptions(resolved, m2, optionMergeStrategies, !0))), 
            mergeOptions(resolved, base, optionMergeStrategies)) : resolved = base, isObject$3(base) && cache.set(base, resolved), 
            resolved;
        }
        function mergeOptions(to, from2, strats, asMixin = !1) {
            const {mixins: mixins, extends: extendsOptions} = from2;
            extendsOptions && mergeOptions(to, extendsOptions, strats, !0), mixins && mixins.forEach((m2 => mergeOptions(to, m2, strats, !0)));
            for (const key2 in from2) if (asMixin && "expose" === key2) ; else {
                const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
                to[key2] = strat ? strat(to[key2], from2[key2]) : from2[key2];
            }
            return to;
        }
        const internalOptionMergeStrats = {
            data: mergeDataFn,
            props: mergeEmitsOrPropsOptions,
            emits: mergeEmitsOrPropsOptions,
            methods: mergeObjectOptions,
            computed: mergeObjectOptions,
            beforeCreate: mergeAsArray,
            created: mergeAsArray,
            beforeMount: mergeAsArray,
            mounted: mergeAsArray,
            beforeUpdate: mergeAsArray,
            updated: mergeAsArray,
            beforeDestroy: mergeAsArray,
            beforeUnmount: mergeAsArray,
            destroyed: mergeAsArray,
            unmounted: mergeAsArray,
            activated: mergeAsArray,
            deactivated: mergeAsArray,
            errorCaptured: mergeAsArray,
            serverPrefetch: mergeAsArray,
            components: mergeObjectOptions,
            directives: mergeObjectOptions,
            watch: mergeWatchOptions,
            provide: mergeDataFn,
            inject: mergeInject
        };
        function mergeDataFn(to, from2) {
            return from2 ? to ? function mergedDataFn() {
                return extend(isFunction$2(to) ? to.call(this, this) : to, isFunction$2(from2) ? from2.call(this, this) : from2);
            } : from2 : to;
        }
        function mergeInject(to, from2) {
            return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
        }
        function normalizeInject(raw) {
            if (isArray$2(raw)) {
                const res = {};
                for (let i2 = 0; i2 < raw.length; i2++) res[raw[i2]] = raw[i2];
                return res;
            }
            return raw;
        }
        function mergeAsArray(to, from2) {
            return to ? [ ...new Set([].concat(to, from2)) ] : from2;
        }
        function mergeObjectOptions(to, from2) {
            return to ? extend(Object.create(null), to, from2) : from2;
        }
        function mergeEmitsOrPropsOptions(to, from2) {
            return to ? isArray$2(to) && isArray$2(from2) ? [ ...new Set([ ...to, ...from2 ]) ] : extend(Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(null != from2 ? from2 : {})) : from2;
        }
        function mergeWatchOptions(to, from2) {
            if (!to) return from2;
            if (!from2) return to;
            const merged = extend(Object.create(null), to);
            for (const key2 in from2) merged[key2] = mergeAsArray(to[key2], from2[key2]);
            return merged;
        }
        function createAppContext() {
            return {
                app: null,
                config: {
                    isNativeTag: NO,
                    performance: !1,
                    globalProperties: {},
                    optionMergeStrategies: {},
                    errorHandler: void 0,
                    warnHandler: void 0,
                    compilerOptions: {}
                },
                mixins: [],
                components: {},
                directives: {},
                provides: Object.create(null),
                optionsCache: new WeakMap,
                propsCache: new WeakMap,
                emitsCache: new WeakMap
            };
        }
        let uid$1 = 0;
        function createAppAPI(render2, hydrate) {
            return function createApp2(rootComponent, rootProps = null) {
                isFunction$2(rootComponent) || (rootComponent = extend({}, rootComponent)), null == rootProps || isObject$3(rootProps) || (rootProps = null);
                const context = createAppContext(), installedPlugins = new WeakSet;
                let isMounted = !1;
                const app = context.app = {
                    _uid: uid$1++,
                    _component: rootComponent,
                    _props: rootProps,
                    _container: null,
                    _context: context,
                    _instance: null,
                    version: version$1,
                    get config() {
                        return context.config;
                    },
                    set config(v2) {},
                    use: (plugin, ...options) => (installedPlugins.has(plugin) || (plugin && isFunction$2(plugin.install) ? (installedPlugins.add(plugin), 
                    plugin.install(app, ...options)) : isFunction$2(plugin) && (installedPlugins.add(plugin), 
                    plugin(app, ...options))), app),
                    mixin: mixin => (context.mixins.includes(mixin) || context.mixins.push(mixin), app),
                    component: (name, component) => component ? (context.components[name] = component, 
                    app) : context.components[name],
                    directive: (name, directive) => directive ? (context.directives[name] = directive, 
                    app) : context.directives[name],
                    mount(rootContainer, isHydrate, namespace) {
                        if (!isMounted) {
                            const vnode = createVNode(rootComponent, rootProps);
                            return vnode.appContext = context, !0 === namespace ? namespace = "svg" : !1 === namespace && (namespace = void 0), 
                            isHydrate && hydrate ? hydrate(vnode, rootContainer) : render2(vnode, rootContainer, namespace), 
                            isMounted = !0, app._container = rootContainer, rootContainer.__vue_app__ = app, 
                            getComponentPublicInstance(vnode.component);
                        }
                    },
                    unmount() {
                        isMounted && (render2(null, app._container), delete app._container.__vue_app__);
                    },
                    provide: (key2, value) => (context.provides[key2] = value, app),
                    runWithContext(fn) {
                        const lastApp = currentApp;
                        currentApp = app;
                        try {
                            return fn();
                        } finally {
                            currentApp = lastApp;
                        }
                    }
                };
                return app;
            };
        }
        let currentApp = null;
        function provide(key2, value) {
            if (currentInstance) {
                let provides = currentInstance.provides;
                const parentProvides = currentInstance.parent && currentInstance.parent.provides;
                parentProvides === provides && (provides = currentInstance.provides = Object.create(parentProvides)), 
                provides[key2] = value;
            } else ;
        }
        function inject(key2, defaultValue, treatDefaultAsFactory = !1) {
            const instance = currentInstance || currentRenderingInstance;
            if (instance || currentApp) {
                const provides = currentApp ? currentApp._context.provides : instance ? null == instance.parent ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
                if (provides && key2 in provides) return provides[key2];
                if (arguments.length > 1) return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
            }
        }
        const internalObjectProto = {}, createInternalObject = () => Object.create(internalObjectProto), isInternalObject = obj => Object.getPrototypeOf(obj) === internalObjectProto;
        function initProps(instance, rawProps, isStateful, isSSR = !1) {
            const props2 = {}, attrs = createInternalObject();
            instance.propsDefaults = Object.create(null), setFullProps(instance, rawProps, props2, attrs);
            for (const key2 in instance.propsOptions[0]) key2 in props2 || (props2[key2] = void 0);
            isStateful ? instance.props = isSSR ? props2 : shallowReactive(props2) : instance.type.props ? instance.props = props2 : instance.props = attrs, 
            instance.attrs = attrs;
        }
        function updateProps(instance, rawProps, rawPrevProps, optimized) {
            const {props: props2, attrs: attrs, vnode: {patchFlag: patchFlag}} = instance, rawCurrentProps = toRaw(props2), [options] = instance.propsOptions;
            let hasAttrsChanged = !1;
            if (!(optimized || patchFlag > 0) || 16 & patchFlag) {
                let kebabKey;
                setFullProps(instance, rawProps, props2, attrs) && (hasAttrsChanged = !0);
                for (const key2 in rawCurrentProps) rawProps && (hasOwn$1(rawProps, key2) || (kebabKey = hyphenate$1(key2)) !== key2 && hasOwn$1(rawProps, kebabKey)) || (options ? !rawPrevProps || void 0 === rawPrevProps[key2] && void 0 === rawPrevProps[kebabKey] || (props2[key2] = resolvePropValue$1(options, rawCurrentProps, key2, void 0, instance, !0)) : delete props2[key2]);
                if (attrs !== rawCurrentProps) for (const key2 in attrs) rawProps && hasOwn$1(rawProps, key2) || (delete attrs[key2], 
                hasAttrsChanged = !0);
            } else if (8 & patchFlag) {
                const propsToUpdate = instance.vnode.dynamicProps;
                for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                    let key2 = propsToUpdate[i2];
                    if (isEmitListener(instance.emitsOptions, key2)) continue;
                    const value = rawProps[key2];
                    if (options) if (hasOwn$1(attrs, key2)) value !== attrs[key2] && (attrs[key2] = value, 
                    hasAttrsChanged = !0); else {
                        const camelizedKey = camelize$1(key2);
                        props2[camelizedKey] = resolvePropValue$1(options, rawCurrentProps, camelizedKey, value, instance, !1);
                    } else value !== attrs[key2] && (attrs[key2] = value, hasAttrsChanged = !0);
                }
            }
            hasAttrsChanged && trigger(instance.attrs, "set", "");
        }
        function setFullProps(instance, rawProps, props2, attrs) {
            const [options, needCastKeys] = instance.propsOptions;
            let rawCastValues, hasAttrsChanged = !1;
            if (rawProps) for (let key2 in rawProps) {
                if (isReservedProp(key2)) continue;
                const value = rawProps[key2];
                let camelKey;
                options && hasOwn$1(options, camelKey = camelize$1(key2)) ? needCastKeys && needCastKeys.includes(camelKey) ? (rawCastValues || (rawCastValues = {}))[camelKey] = value : props2[camelKey] = value : isEmitListener(instance.emitsOptions, key2) || key2 in attrs && value === attrs[key2] || (attrs[key2] = value, 
                hasAttrsChanged = !0);
            }
            if (needCastKeys) {
                const rawCurrentProps = toRaw(props2), castValues = rawCastValues || EMPTY_OBJ;
                for (let i2 = 0; i2 < needCastKeys.length; i2++) {
                    const key2 = needCastKeys[i2];
                    props2[key2] = resolvePropValue$1(options, rawCurrentProps, key2, castValues[key2], instance, !hasOwn$1(castValues, key2));
                }
            }
            return hasAttrsChanged;
        }
        function resolvePropValue$1(options, props2, key2, value, instance, isAbsent) {
            const opt = options[key2];
            if (null != opt) {
                const hasDefault = hasOwn$1(opt, "default");
                if (hasDefault && void 0 === value) {
                    const defaultValue = opt.default;
                    if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
                        const {propsDefaults: propsDefaults} = instance;
                        if (key2 in propsDefaults) value = propsDefaults[key2]; else {
                            const reset = setCurrentInstance(instance);
                            value = propsDefaults[key2] = defaultValue.call(null, props2), reset();
                        }
                    } else value = defaultValue;
                }
                opt[0] && (isAbsent && !hasDefault ? value = !1 : !opt[1] || "" !== value && value !== hyphenate$1(key2) || (value = !0));
            }
            return value;
        }
        const mixinPropsCache = new WeakMap;
        function normalizePropsOptions(comp, appContext, asMixin = !1) {
            const cache = asMixin ? mixinPropsCache : appContext.propsCache, cached2 = cache.get(comp);
            if (cached2) return cached2;
            const raw = comp.props, normalized = {}, needCastKeys = [];
            let hasExtends = !1;
            if (!isFunction$2(comp)) {
                const extendProps = raw2 => {
                    hasExtends = !0;
                    const [props2, keys2] = normalizePropsOptions(raw2, appContext, !0);
                    extend(normalized, props2), keys2 && needCastKeys.push(...keys2);
                };
                !asMixin && appContext.mixins.length && appContext.mixins.forEach(extendProps), 
                comp.extends && extendProps(comp.extends), comp.mixins && comp.mixins.forEach(extendProps);
            }
            if (!raw && !hasExtends) return isObject$3(comp) && cache.set(comp, EMPTY_ARR), 
            EMPTY_ARR;
            if (isArray$2(raw)) for (let i2 = 0; i2 < raw.length; i2++) {
                const normalizedKey = camelize$1(raw[i2]);
                validatePropName(normalizedKey) && (normalized[normalizedKey] = EMPTY_OBJ);
            } else if (raw) for (const key2 in raw) {
                const normalizedKey = camelize$1(key2);
                if (validatePropName(normalizedKey)) {
                    const opt = raw[key2], prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? {
                        type: opt
                    } : extend({}, opt), propType = prop.type;
                    let shouldCast = !1, shouldCastTrue = !0;
                    if (isArray$2(propType)) for (let index2 = 0; index2 < propType.length; ++index2) {
                        const type = propType[index2], typeName = isFunction$2(type) && type.name;
                        if ("Boolean" === typeName) {
                            shouldCast = !0;
                            break;
                        }
                        "String" === typeName && (shouldCastTrue = !1);
                    } else shouldCast = isFunction$2(propType) && "Boolean" === propType.name;
                    prop[0] = shouldCast, prop[1] = shouldCastTrue, (shouldCast || hasOwn$1(prop, "default")) && needCastKeys.push(normalizedKey);
                }
            }
            const res = [ normalized, needCastKeys ];
            return isObject$3(comp) && cache.set(comp, res), res;
        }
        function validatePropName(key2) {
            return "$" !== key2[0] && !isReservedProp(key2);
        }
        const isInternalKey = key2 => "_" === key2[0] || "$stable" === key2, normalizeSlotValue = value => isArray$2(value) ? value.map(normalizeVNode) : [ normalizeVNode(value) ], normalizeSlot = (key2, rawSlot, ctx) => {
            if (rawSlot._n) return rawSlot;
            const normalized = withCtx(((...args) => normalizeSlotValue(rawSlot(...args))), ctx);
            return normalized._c = !1, normalized;
        }, normalizeObjectSlots = (rawSlots, slots, instance) => {
            const ctx = rawSlots._ctx;
            for (const key2 in rawSlots) {
                if (isInternalKey(key2)) continue;
                const value = rawSlots[key2];
                if (isFunction$2(value)) slots[key2] = normalizeSlot(key2, value, ctx); else if (null != value) {
                    const normalized = normalizeSlotValue(value);
                    slots[key2] = () => normalized;
                }
            }
        }, normalizeVNodeSlots = (instance, children) => {
            const normalized = normalizeSlotValue(children);
            instance.slots.default = () => normalized;
        }, assignSlots = (slots, children, optimized) => {
            for (const key2 in children) (optimized || "_" !== key2) && (slots[key2] = children[key2]);
        }, initSlots = (instance, children, optimized) => {
            const slots = instance.slots = createInternalObject();
            if (32 & instance.vnode.shapeFlag) {
                const type = children._;
                type ? (assignSlots(slots, children, optimized), optimized && def(slots, "_", type, !0)) : normalizeObjectSlots(children, slots);
            } else children && normalizeVNodeSlots(instance, children);
        }, updateSlots = (instance, children, optimized) => {
            const {vnode: vnode, slots: slots} = instance;
            let needDeletionCheck = !0, deletionComparisonTarget = EMPTY_OBJ;
            if (32 & vnode.shapeFlag) {
                const type = children._;
                type ? optimized && 1 === type ? needDeletionCheck = !1 : assignSlots(slots, children, optimized) : (needDeletionCheck = !children.$stable, 
                normalizeObjectSlots(children, slots)), deletionComparisonTarget = children;
            } else children && (normalizeVNodeSlots(instance, children), deletionComparisonTarget = {
                default: 1
            });
            if (needDeletionCheck) for (const key2 in slots) isInternalKey(key2) || null != deletionComparisonTarget[key2] || delete slots[key2];
        };
        function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = !1) {
            if (isArray$2(rawRef)) return void rawRef.forEach(((r2, i2) => setRef(r2, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount)));
            if (isAsyncWrapper(vnode) && !isUnmount) return;
            const refValue = 4 & vnode.shapeFlag ? getComponentPublicInstance(vnode.component) : vnode.el, value = isUnmount ? null : refValue, {i: owner, r: ref3} = rawRef, oldRef = oldRawRef && oldRawRef.r, refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs, setupState = owner.setupState;
            if (null != oldRef && oldRef !== ref3 && (isString$1(oldRef) ? (refs[oldRef] = null, 
            hasOwn$1(setupState, oldRef) && (setupState[oldRef] = null)) : isRef(oldRef) && (oldRef.value = null)), 
            isFunction$2(ref3)) callWithErrorHandling(ref3, owner, 12, [ value, refs ]); else {
                const _isString = isString$1(ref3), _isRef = isRef(ref3);
                if (_isString || _isRef) {
                    const doSet = () => {
                        if (rawRef.f) {
                            const existing = _isString ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                            isUnmount ? isArray$2(existing) && remove(existing, refValue) : isArray$2(existing) ? existing.includes(refValue) || existing.push(refValue) : _isString ? (refs[ref3] = [ refValue ], 
                            hasOwn$1(setupState, ref3) && (setupState[ref3] = refs[ref3])) : (ref3.value = [ refValue ], 
                            rawRef.k && (refs[rawRef.k] = ref3.value));
                        } else _isString ? (refs[ref3] = value, hasOwn$1(setupState, ref3) && (setupState[ref3] = value)) : _isRef && (ref3.value = value, 
                        rawRef.k && (refs[rawRef.k] = value));
                    };
                    value ? (doSet.id = -1, queuePostRenderEffect(doSet, parentSuspense)) : doSet();
                }
            }
        }
        const TeleportEndKey = Symbol("_vte"), isTeleport = type => type.__isTeleport, isTeleportDisabled = props2 => props2 && (props2.disabled || "" === props2.disabled), isTargetSVG = target => "undefined" != typeof SVGElement && target instanceof SVGElement, isTargetMathML = target => "function" == typeof MathMLElement && target instanceof MathMLElement, resolveTarget = (props2, select) => {
            const targetSelector = props2 && props2.to;
            if (isString$1(targetSelector)) {
                if (select) {
                    return select(targetSelector);
                }
                return null;
            }
            return targetSelector;
        };
        function moveTeleport(vnode, container, parentAnchor, {o: {insert: insert}, m: move}, moveType = 2) {
            0 === moveType && insert(vnode.targetAnchor, container, parentAnchor);
            const {el: el, anchor: anchor, shapeFlag: shapeFlag, children: children, props: props2} = vnode, isReorder = 2 === moveType;
            if (isReorder && insert(el, container, parentAnchor), (!isReorder || isTeleportDisabled(props2)) && 16 & shapeFlag) for (let i2 = 0; i2 < children.length; i2++) move(children[i2], container, parentAnchor, 2);
            isReorder && insert(anchor, container, parentAnchor);
        }
        function hydrateTeleport(node2, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {o: {nextSibling: nextSibling, parentNode: parentNode, querySelector: querySelector, insert: insert, createText: createText}}, hydrateChildren) {
            const target = vnode.target = resolveTarget(vnode.props, querySelector);
            if (target) {
                const targetNode = target._lpa || target.firstChild;
                if (16 & vnode.shapeFlag) if (isTeleportDisabled(vnode.props)) vnode.anchor = hydrateChildren(nextSibling(node2), vnode, parentNode(node2), parentComponent, parentSuspense, slotScopeIds, optimized), 
                vnode.targetStart = targetNode, vnode.targetAnchor = targetNode && nextSibling(targetNode); else {
                    vnode.anchor = nextSibling(node2);
                    let targetAnchor = targetNode;
                    for (;targetAnchor; ) {
                        if (targetAnchor && 8 === targetAnchor.nodeType) if ("teleport start anchor" === targetAnchor.data) vnode.targetStart = targetAnchor; else if ("teleport anchor" === targetAnchor.data) {
                            vnode.targetAnchor = targetAnchor, target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                            break;
                        }
                        targetAnchor = nextSibling(targetAnchor);
                    }
                    vnode.targetAnchor || prepareAnchor(target, vnode, createText, insert), hydrateChildren(targetNode && nextSibling(targetNode), vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                updateCssVars(vnode);
            }
            return vnode.anchor && nextSibling(vnode.anchor);
        }
        const Teleport = {
            name: "Teleport",
            __isTeleport: !0,
            process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
                const {mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: {insert: insert, querySelector: querySelector, createText: createText, createComment: createComment}} = internals, disabled = isTeleportDisabled(n2.props);
                let {shapeFlag: shapeFlag, children: children, dynamicChildren: dynamicChildren} = n2;
                if (null == n1) {
                    const placeholder = n2.el = createText(""), mainAnchor = n2.anchor = createText("");
                    insert(placeholder, container, anchor), insert(mainAnchor, container, anchor);
                    const target = n2.target = resolveTarget(n2.props, querySelector), targetAnchor = prepareAnchor(target, n2, createText, insert);
                    target && ("svg" === namespace || isTargetSVG(target) ? namespace = "svg" : ("mathml" === namespace || isTargetMathML(target)) && (namespace = "mathml"));
                    const mount = (container2, anchor2) => {
                        16 & shapeFlag && mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    };
                    disabled ? mount(container, mainAnchor) : target && mount(target, targetAnchor);
                } else {
                    n2.el = n1.el, n2.targetStart = n1.targetStart;
                    const mainAnchor = n2.anchor = n1.anchor, target = n2.target = n1.target, targetAnchor = n2.targetAnchor = n1.targetAnchor, wasDisabled = isTeleportDisabled(n1.props), currentContainer = wasDisabled ? container : target, currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
                    if ("svg" === namespace || isTargetSVG(target) ? namespace = "svg" : ("mathml" === namespace || isTargetMathML(target)) && (namespace = "mathml"), 
                    dynamicChildren ? (patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace, slotScopeIds), 
                    traverseStaticChildren(n1, n2, !0)) : optimized || patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, !1), 
                    disabled) wasDisabled ? n2.props && n1.props && n2.props.to !== n1.props.to && (n2.props.to = n1.props.to) : moveTeleport(n2, container, mainAnchor, internals, 1); else if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                        const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                        nextTarget && moveTeleport(n2, nextTarget, null, internals, 0);
                    } else wasDisabled && moveTeleport(n2, target, targetAnchor, internals, 1);
                }
                updateCssVars(n2);
            },
            remove(vnode, parentComponent, parentSuspense, {um: unmount, o: {remove: hostRemove}}, doRemove) {
                const {shapeFlag: shapeFlag, children: children, anchor: anchor, targetStart: targetStart, targetAnchor: targetAnchor, target: target, props: props2} = vnode;
                if (target && (hostRemove(targetStart), hostRemove(targetAnchor)), doRemove && hostRemove(anchor), 
                16 & shapeFlag) {
                    const shouldRemove = doRemove || !isTeleportDisabled(props2);
                    for (let i2 = 0; i2 < children.length; i2++) {
                        const child = children[i2];
                        unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
                    }
                }
            },
            move: moveTeleport,
            hydrate: hydrateTeleport
        };
        function updateCssVars(vnode) {
            const ctx = vnode.ctx;
            if (ctx && ctx.ut) {
                let node2 = vnode.children[0].el;
                for (;node2 && node2 !== vnode.targetAnchor; ) 1 === node2.nodeType && node2.setAttribute("data-v-owner", ctx.uid), 
                node2 = node2.nextSibling;
                ctx.ut();
            }
        }
        function prepareAnchor(target, vnode, createText, insert) {
            const targetStart = vnode.targetStart = createText(""), targetAnchor = vnode.targetAnchor = createText("");
            return targetStart[TeleportEndKey] = targetAnchor, target && (insert(targetStart, target), 
            insert(targetAnchor, target)), targetAnchor;
        }
        const queuePostRenderEffect = queueEffectWithSuspense;
        function createRenderer(options) {
            return baseCreateRenderer(options);
        }
        function baseCreateRenderer(options, createHydrationFns) {
            getGlobalThis().__VUE__ = !0;
            const {insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent} = options, patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
                if (n1 === n2) return;
                n1 && !isSameVNodeType(n1, n2) && (anchor = getNextHostNode(n1), unmount(n1, parentComponent, parentSuspense, !0), 
                n1 = null), -2 === n2.patchFlag && (optimized = !1, n2.dynamicChildren = null);
                const {type: type, ref: ref3, shapeFlag: shapeFlag} = n2;
                switch (type) {
                  case Text:
                    processText(n1, n2, container, anchor);
                    break;

                  case Comment:
                    processCommentNode(n1, n2, container, anchor);
                    break;

                  case Static:
                    null == n1 && mountStaticNode(n2, container, anchor, namespace);
                    break;

                  case Fragment:
                    processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    break;

                  default:
                    1 & shapeFlag ? processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) : 6 & shapeFlag ? processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) : (64 & shapeFlag || 128 & shapeFlag) && type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals);
                }
                null != ref3 && parentComponent && setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
            }, processText = (n1, n2, container, anchor) => {
                if (null == n1) hostInsert(n2.el = hostCreateText(n2.children), container, anchor); else {
                    const el = n2.el = n1.el;
                    n2.children !== n1.children && hostSetText(el, n2.children);
                }
            }, processCommentNode = (n1, n2, container, anchor) => {
                null == n1 ? hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor) : n2.el = n1.el;
            }, mountStaticNode = (n2, container, anchor, namespace) => {
                [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace, n2.el, n2.anchor);
            }, moveStaticNode = ({el: el, anchor: anchor}, container, nextSibling) => {
                let next2;
                for (;el && el !== anchor; ) next2 = hostNextSibling(el), hostInsert(el, container, nextSibling), 
                el = next2;
                hostInsert(anchor, container, nextSibling);
            }, removeStaticNode = ({el: el, anchor: anchor}) => {
                let next2;
                for (;el && el !== anchor; ) next2 = hostNextSibling(el), hostRemove(el), el = next2;
                hostRemove(anchor);
            }, processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                "svg" === n2.type ? namespace = "svg" : "math" === n2.type && (namespace = "mathml"), 
                null == n1 ? mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) : patchElement(n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            }, mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                let el, vnodeHook;
                const {props: props2, shapeFlag: shapeFlag, transition: transition, dirs: dirs} = vnode;
                if (el = vnode.el = hostCreateElement(vnode.type, namespace, props2 && props2.is, props2), 
                8 & shapeFlag ? hostSetElementText(el, vnode.children) : 16 & shapeFlag && mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace), slotScopeIds, optimized), 
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "created"), setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent), 
                props2) {
                    for (const key2 in props2) "value" === key2 || isReservedProp(key2) || hostPatchProp(el, key2, null, props2[key2], namespace, parentComponent);
                    "value" in props2 && hostPatchProp(el, "value", null, props2.value, namespace), 
                    (vnodeHook = props2.onVnodeBeforeMount) && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
                dirs && invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
                const needCallTransitionHooks = needTransition(parentSuspense, transition);
                needCallTransitionHooks && transition.beforeEnter(el), hostInsert(el, container, anchor), 
                ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) && queuePostRenderEffect((() => {
                    vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode), needCallTransitionHooks && transition.enter(el), 
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
                }), parentSuspense);
            }, setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
                if (scopeId && hostSetScopeId(el, scopeId), slotScopeIds) for (let i2 = 0; i2 < slotScopeIds.length; i2++) hostSetScopeId(el, slotScopeIds[i2]);
                if (parentComponent) {
                    if (vnode === parentComponent.subTree) {
                        const parentVNode = parentComponent.vnode;
                        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
                    }
                }
            }, mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
                for (let i2 = start; i2 < children.length; i2++) {
                    const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
                    patch(null, child, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                }
            }, patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                const el = n2.el = n1.el;
                let {patchFlag: patchFlag, dynamicChildren: dynamicChildren, dirs: dirs} = n2;
                patchFlag |= 16 & n1.patchFlag;
                const oldProps = n1.props || EMPTY_OBJ, newProps = n2.props || EMPTY_OBJ;
                let vnodeHook;
                if (parentComponent && toggleRecurse(parentComponent, !1), (vnodeHook = newProps.onVnodeBeforeUpdate) && invokeVNodeHook(vnodeHook, parentComponent, n2, n1), 
                dirs && invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate"), parentComponent && toggleRecurse(parentComponent, !0), 
                (oldProps.innerHTML && null == newProps.innerHTML || oldProps.textContent && null == newProps.textContent) && hostSetElementText(el, ""), 
                dynamicChildren ? patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds) : optimized || patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace), slotScopeIds, !1), 
                patchFlag > 0) {
                    if (16 & patchFlag) patchProps(el, oldProps, newProps, parentComponent, namespace); else if (2 & patchFlag && oldProps.class !== newProps.class && hostPatchProp(el, "class", null, newProps.class, namespace), 
                    4 & patchFlag && hostPatchProp(el, "style", oldProps.style, newProps.style, namespace), 
                    8 & patchFlag) {
                        const propsToUpdate = n2.dynamicProps;
                        for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                            const key2 = propsToUpdate[i2], prev2 = oldProps[key2], next2 = newProps[key2];
                            next2 === prev2 && "value" !== key2 || hostPatchProp(el, key2, prev2, next2, namespace, parentComponent);
                        }
                    }
                    1 & patchFlag && n1.children !== n2.children && hostSetElementText(el, n2.children);
                } else optimized || null != dynamicChildren || patchProps(el, oldProps, newProps, parentComponent, namespace);
                ((vnodeHook = newProps.onVnodeUpdated) || dirs) && queuePostRenderEffect((() => {
                    vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1), dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
                }), parentSuspense);
            }, patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
                for (let i2 = 0; i2 < newChildren.length; i2++) {
                    const oldVNode = oldChildren[i2], newVNode = newChildren[i2], container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || 70 & oldVNode.shapeFlag) ? hostParentNode(oldVNode.el) : fallbackContainer;
                    patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, !0);
                }
            }, patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
                if (oldProps !== newProps) {
                    if (oldProps !== EMPTY_OBJ) for (const key2 in oldProps) isReservedProp(key2) || key2 in newProps || hostPatchProp(el, key2, oldProps[key2], null, namespace, parentComponent);
                    for (const key2 in newProps) {
                        if (isReservedProp(key2)) continue;
                        const next2 = newProps[key2], prev2 = oldProps[key2];
                        next2 !== prev2 && "value" !== key2 && hostPatchProp(el, key2, prev2, next2, namespace, parentComponent);
                    }
                    "value" in newProps && hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
                }
            }, processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(""), fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
                let {patchFlag: patchFlag, dynamicChildren: dynamicChildren, slotScopeIds: fragmentSlotScopeIds} = n2;
                fragmentSlotScopeIds && (slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds), 
                null == n1 ? (hostInsert(fragmentStartAnchor, container, anchor), hostInsert(fragmentEndAnchor, container, anchor), 
                mountChildren(n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized)) : patchFlag > 0 && 64 & patchFlag && dynamicChildren && n1.dynamicChildren ? (patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace, slotScopeIds), 
                (null != n2.key || parentComponent && n2 === parentComponent.subTree) && traverseStaticChildren(n1, n2, !0)) : patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
            }, processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                n2.slotScopeIds = slotScopeIds, null == n1 ? 512 & n2.shapeFlag ? parentComponent.ctx.activate(n2, container, anchor, namespace, optimized) : mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace, optimized) : updateComponent(n1, n2, optimized);
            }, mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
                const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
                if (isKeepAlive(initialVNode) && (instance.ctx.renderer = internals), setupComponent(instance, !1, optimized), 
                instance.asyncDep) {
                    if (parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized), 
                    !initialVNode.el) {
                        const placeholder = instance.subTree = createVNode(Comment);
                        processCommentNode(null, placeholder, container, anchor);
                    }
                } else setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
            }, updateComponent = (n1, n2, optimized) => {
                const instance = n2.component = n1.component;
                if (shouldUpdateComponent(n1, n2, optimized)) {
                    if (instance.asyncDep && !instance.asyncResolved) return void updateComponentPreRender(instance, n2, optimized);
                    instance.next = n2, invalidateJob(instance.update), instance.effect.dirty = !0, 
                    instance.update();
                } else n2.el = n1.el, instance.vnode = n2;
            }, setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
                const componentUpdateFn = () => {
                    if (instance.isMounted) {
                        let {next: next2, bu: bu, u: u2, parent: parent2, vnode: vnode} = instance;
                        {
                            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                            if (nonHydratedAsyncRoot) return next2 && (next2.el = vnode.el, updateComponentPreRender(instance, next2, optimized)), 
                            void nonHydratedAsyncRoot.asyncDep.then((() => {
                                instance.isUnmounted || componentUpdateFn();
                            }));
                        }
                        let vnodeHook, originNext = next2;
                        toggleRecurse(instance, !1), next2 ? (next2.el = vnode.el, updateComponentPreRender(instance, next2, optimized)) : next2 = vnode, 
                        bu && invokeArrayFns(bu), (vnodeHook = next2.props && next2.props.onVnodeBeforeUpdate) && invokeVNodeHook(vnodeHook, parent2, next2, vnode), 
                        toggleRecurse(instance, !0);
                        const nextTree = renderComponentRoot(instance), prevTree = instance.subTree;
                        instance.subTree = nextTree, patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, namespace), 
                        next2.el = nextTree.el, null === originNext && updateHOCHostEl(instance, nextTree.el), 
                        u2 && queuePostRenderEffect(u2, parentSuspense), (vnodeHook = next2.props && next2.props.onVnodeUpdated) && queuePostRenderEffect((() => invokeVNodeHook(vnodeHook, parent2, next2, vnode)), parentSuspense);
                    } else {
                        let vnodeHook;
                        const {el: el, props: props2} = initialVNode, {bm: bm, m: m2, parent: parent2} = instance, isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                        if (toggleRecurse(instance, !1), bm && invokeArrayFns(bm), !isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount) && invokeVNodeHook(vnodeHook, parent2, initialVNode), 
                        toggleRecurse(instance, !0), el && hydrateNode) {
                            const hydrateSubTree = () => {
                                instance.subTree = renderComponentRoot(instance), hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                            };
                            isAsyncWrapperVNode ? initialVNode.type.__asyncLoader().then((() => !instance.isUnmounted && hydrateSubTree())) : hydrateSubTree();
                        } else {
                            const subTree = instance.subTree = renderComponentRoot(instance);
                            patch(null, subTree, container, anchor, instance, parentSuspense, namespace), initialVNode.el = subTree.el;
                        }
                        if (m2 && queuePostRenderEffect(m2, parentSuspense), !isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
                            const scopedInitialVNode = initialVNode;
                            queuePostRenderEffect((() => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode)), parentSuspense);
                        }
                        (256 & initialVNode.shapeFlag || parent2 && isAsyncWrapper(parent2.vnode) && 256 & parent2.vnode.shapeFlag) && instance.a && queuePostRenderEffect(instance.a, parentSuspense), 
                        instance.isMounted = !0, initialVNode = container = anchor = null;
                    }
                }, effect2 = instance.effect = new ReactiveEffect(componentUpdateFn, NOOP, (() => queueJob(update)), instance.scope), update = instance.update = () => {
                    effect2.dirty && effect2.run();
                };
                update.i = instance, update.id = instance.uid, toggleRecurse(instance, !0), update();
            }, updateComponentPreRender = (instance, nextVNode, optimized) => {
                nextVNode.component = instance;
                const prevProps = instance.vnode.props;
                instance.vnode = nextVNode, instance.next = null, updateProps(instance, nextVNode.props, prevProps, optimized), 
                updateSlots(instance, nextVNode.children, optimized), pauseTracking(), flushPreFlushCbs(instance), 
                resetTracking();
            }, patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = !1) => {
                const c1 = n1 && n1.children, prevShapeFlag = n1 ? n1.shapeFlag : 0, c2 = n2.children, {patchFlag: patchFlag, shapeFlag: shapeFlag} = n2;
                if (patchFlag > 0) {
                    if (128 & patchFlag) return void patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                    if (256 & patchFlag) return void patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                }
                8 & shapeFlag ? (16 & prevShapeFlag && unmountChildren(c1, parentComponent, parentSuspense), 
                c2 !== c1 && hostSetElementText(container, c2)) : 16 & prevShapeFlag ? 16 & shapeFlag ? patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) : unmountChildren(c1, parentComponent, parentSuspense, !0) : (8 & prevShapeFlag && hostSetElementText(container, ""), 
                16 & shapeFlag && mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized));
            }, patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                c2 = c2 || EMPTY_ARR;
                const oldLength = (c1 = c1 || EMPTY_ARR).length, newLength = c2.length, commonLength = Math.min(oldLength, newLength);
                let i2;
                for (i2 = 0; i2 < commonLength; i2++) {
                    const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
                    patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized);
                }
                oldLength > newLength ? unmountChildren(c1, parentComponent, parentSuspense, !0, !1, commonLength) : mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, commonLength);
            }, patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
                let i2 = 0;
                const l2 = c2.length;
                let e1 = c1.length - 1, e2 = l2 - 1;
                for (;i2 <= e1 && i2 <= e2; ) {
                    const n1 = c1[i2], n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
                    if (!isSameVNodeType(n1, n2)) break;
                    patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized), 
                    i2++;
                }
                for (;i2 <= e1 && i2 <= e2; ) {
                    const n1 = c1[e1], n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
                    if (!isSameVNodeType(n1, n2)) break;
                    patch(n1, n2, container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized), 
                    e1--, e2--;
                }
                if (i2 > e1) {
                    if (i2 <= e2) {
                        const nextPos = e2 + 1, anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                        for (;i2 <= e2; ) patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized), 
                        i2++;
                    }
                } else if (i2 > e2) for (;i2 <= e1; ) unmount(c1[i2], parentComponent, parentSuspense, !0), 
                i2++; else {
                    const s1 = i2, s2 = i2, keyToNewIndexMap = new Map;
                    for (i2 = s2; i2 <= e2; i2++) {
                        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
                        null != nextChild.key && keyToNewIndexMap.set(nextChild.key, i2);
                    }
                    let j2, patched = 0;
                    const toBePatched = e2 - s2 + 1;
                    let moved = !1, maxNewIndexSoFar = 0;
                    const newIndexToOldIndexMap = new Array(toBePatched);
                    for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
                    for (i2 = s1; i2 <= e1; i2++) {
                        const prevChild = c1[i2];
                        if (patched >= toBePatched) {
                            unmount(prevChild, parentComponent, parentSuspense, !0);
                            continue;
                        }
                        let newIndex;
                        if (null != prevChild.key) newIndex = keyToNewIndexMap.get(prevChild.key); else for (j2 = s2; j2 <= e2; j2++) if (0 === newIndexToOldIndexMap[j2 - s2] && isSameVNodeType(prevChild, c2[j2])) {
                            newIndex = j2;
                            break;
                        }
                        void 0 === newIndex ? unmount(prevChild, parentComponent, parentSuspense, !0) : (newIndexToOldIndexMap[newIndex - s2] = i2 + 1, 
                        newIndex >= maxNewIndexSoFar ? maxNewIndexSoFar = newIndex : moved = !0, patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace, slotScopeIds, optimized), 
                        patched++);
                    }
                    const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
                    for (j2 = increasingNewIndexSequence.length - 1, i2 = toBePatched - 1; i2 >= 0; i2--) {
                        const nextIndex = s2 + i2, nextChild = c2[nextIndex], anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                        0 === newIndexToOldIndexMap[i2] ? patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) : moved && (j2 < 0 || i2 !== increasingNewIndexSequence[j2] ? move(nextChild, container, anchor, 2) : j2--);
                    }
                }
            }, move = (vnode, container, anchor, moveType, parentSuspense = null) => {
                const {el: el, type: type, transition: transition, children: children, shapeFlag: shapeFlag} = vnode;
                if (6 & shapeFlag) return void move(vnode.component.subTree, container, anchor, moveType);
                if (128 & shapeFlag) return void vnode.suspense.move(container, anchor, moveType);
                if (64 & shapeFlag) return void type.move(vnode, container, anchor, internals);
                if (type === Fragment) {
                    hostInsert(el, container, anchor);
                    for (let i2 = 0; i2 < children.length; i2++) move(children[i2], container, anchor, moveType);
                    return void hostInsert(vnode.anchor, container, anchor);
                }
                if (type === Static) return void moveStaticNode(vnode, container, anchor);
                if (2 !== moveType && 1 & shapeFlag && transition) if (0 === moveType) transition.beforeEnter(el), 
                hostInsert(el, container, anchor), queuePostRenderEffect((() => transition.enter(el)), parentSuspense); else {
                    const {leave: leave, delayLeave: delayLeave, afterLeave: afterLeave} = transition, remove22 = () => hostInsert(el, container, anchor), performLeave = () => {
                        leave(el, (() => {
                            remove22(), afterLeave && afterLeave();
                        }));
                    };
                    delayLeave ? delayLeave(el, remove22, performLeave) : performLeave();
                } else hostInsert(el, container, anchor);
            }, unmount = (vnode, parentComponent, parentSuspense, doRemove = !1, optimized = !1) => {
                const {type: type, props: props2, ref: ref3, children: children, dynamicChildren: dynamicChildren, shapeFlag: shapeFlag, patchFlag: patchFlag, dirs: dirs, cacheIndex: cacheIndex} = vnode;
                if (-2 === patchFlag && (optimized = !1), null != ref3 && setRef(ref3, null, parentSuspense, vnode, !0), 
                null != cacheIndex && (parentComponent.renderCache[cacheIndex] = void 0), 256 & shapeFlag) return void parentComponent.ctx.deactivate(vnode);
                const shouldInvokeDirs = 1 & shapeFlag && dirs, shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
                let vnodeHook;
                if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount) && invokeVNodeHook(vnodeHook, parentComponent, vnode), 
                6 & shapeFlag) unmountComponent(vnode.component, parentSuspense, doRemove); else {
                    if (128 & shapeFlag) return void vnode.suspense.unmount(parentSuspense, doRemove);
                    shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount"), 
                    64 & shapeFlag ? vnode.type.remove(vnode, parentComponent, parentSuspense, internals, doRemove) : dynamicChildren && !dynamicChildren.hasOnce && (type !== Fragment || patchFlag > 0 && 64 & patchFlag) ? unmountChildren(dynamicChildren, parentComponent, parentSuspense, !1, !0) : (type === Fragment && 384 & patchFlag || !optimized && 16 & shapeFlag) && unmountChildren(children, parentComponent, parentSuspense), 
                    doRemove && remove2(vnode);
                }
                (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) && queuePostRenderEffect((() => {
                    vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode), shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
                }), parentSuspense);
            }, remove2 = vnode => {
                const {type: type, el: el, anchor: anchor, transition: transition} = vnode;
                if (type === Fragment) return void removeFragment(el, anchor);
                if (type === Static) return void removeStaticNode(vnode);
                const performRemove = () => {
                    hostRemove(el), transition && !transition.persisted && transition.afterLeave && transition.afterLeave();
                };
                if (1 & vnode.shapeFlag && transition && !transition.persisted) {
                    const {leave: leave, delayLeave: delayLeave} = transition, performLeave = () => leave(el, performRemove);
                    delayLeave ? delayLeave(vnode.el, performRemove, performLeave) : performLeave();
                } else performRemove();
            }, removeFragment = (cur, end) => {
                let next2;
                for (;cur !== end; ) next2 = hostNextSibling(cur), hostRemove(cur), cur = next2;
                hostRemove(end);
            }, unmountComponent = (instance, parentSuspense, doRemove) => {
                const {bum: bum, scope: scope, update: update, subTree: subTree, um: um, m: m2, a: a2} = instance;
                invalidateMount(m2), invalidateMount(a2), bum && invokeArrayFns(bum), scope.stop(), 
                update && (update.active = !1, unmount(subTree, instance, parentSuspense, doRemove)), 
                um && queuePostRenderEffect(um, parentSuspense), queuePostRenderEffect((() => {
                    instance.isUnmounted = !0;
                }), parentSuspense), parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId && (parentSuspense.deps--, 
                0 === parentSuspense.deps && parentSuspense.resolve());
            }, unmountChildren = (children, parentComponent, parentSuspense, doRemove = !1, optimized = !1, start = 0) => {
                for (let i2 = start; i2 < children.length; i2++) unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
            }, getNextHostNode = vnode => {
                if (6 & vnode.shapeFlag) return getNextHostNode(vnode.component.subTree);
                if (128 & vnode.shapeFlag) return vnode.suspense.next();
                const el = hostNextSibling(vnode.anchor || vnode.el), teleportEnd = el && el[TeleportEndKey];
                return teleportEnd ? hostNextSibling(teleportEnd) : el;
            };
            let isFlushing2 = !1;
            const render2 = (vnode, container, namespace) => {
                null == vnode ? container._vnode && unmount(container._vnode, null, null, !0) : patch(container._vnode || null, vnode, container, null, null, null, namespace), 
                container._vnode = vnode, isFlushing2 || (isFlushing2 = !0, flushPreFlushCbs(), 
                flushPostFlushCbs(), isFlushing2 = !1);
            }, internals = {
                p: patch,
                um: unmount,
                m: move,
                r: remove2,
                mt: mountComponent,
                mc: mountChildren,
                pc: patchChildren,
                pbc: patchBlockChildren,
                n: getNextHostNode,
                o: options
            };
            let hydrate, hydrateNode;
            return {
                render: render2,
                hydrate: hydrate,
                createApp: createAppAPI(render2, hydrate)
            };
        }
        function resolveChildrenNamespace({type: type, props: props2}, currentNamespace) {
            return "svg" === currentNamespace && "foreignObject" === type || "mathml" === currentNamespace && "annotation-xml" === type && props2 && props2.encoding && props2.encoding.includes("html") ? void 0 : currentNamespace;
        }
        function toggleRecurse({effect: effect2, update: update}, allowed) {
            effect2.allowRecurse = update.allowRecurse = allowed;
        }
        function needTransition(parentSuspense, transition) {
            return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        }
        function traverseStaticChildren(n1, n2, shallow = !1) {
            const ch1 = n1.children, ch2 = n2.children;
            if (isArray$2(ch1) && isArray$2(ch2)) for (let i2 = 0; i2 < ch1.length; i2++) {
                const c1 = ch1[i2];
                let c2 = ch2[i2];
                1 & c2.shapeFlag && !c2.dynamicChildren && ((c2.patchFlag <= 0 || 32 === c2.patchFlag) && (c2 = ch2[i2] = cloneIfMounted(ch2[i2]), 
                c2.el = c1.el), shallow || -2 === c2.patchFlag || traverseStaticChildren(c1, c2)), 
                c2.type === Text && (c2.el = c1.el);
            }
        }
        function getSequence(arr) {
            const p2 = arr.slice(), result = [ 0 ];
            let i2, j2, u2, v2, c2;
            const len = arr.length;
            for (i2 = 0; i2 < len; i2++) {
                const arrI = arr[i2];
                if (0 !== arrI) {
                    if (j2 = result[result.length - 1], arr[j2] < arrI) {
                        p2[i2] = j2, result.push(i2);
                        continue;
                    }
                    for (u2 = 0, v2 = result.length - 1; u2 < v2; ) c2 = u2 + v2 >> 1, arr[result[c2]] < arrI ? u2 = c2 + 1 : v2 = c2;
                    arrI < arr[result[u2]] && (u2 > 0 && (p2[i2] = result[u2 - 1]), result[u2] = i2);
                }
            }
            for (u2 = result.length, v2 = result[u2 - 1]; u2-- > 0; ) result[u2] = v2, v2 = p2[v2];
            return result;
        }
        function locateNonHydratedAsyncRoot(instance) {
            const subComponent = instance.subTree.component;
            if (subComponent) return subComponent.asyncDep && !subComponent.asyncResolved ? subComponent : locateNonHydratedAsyncRoot(subComponent);
        }
        function invalidateMount(hooks) {
            if (hooks) for (let i2 = 0; i2 < hooks.length; i2++) hooks[i2].active = !1;
        }
        const ssrContextKey = Symbol.for("v-scx"), useSSRContext = () => inject(ssrContextKey);
        function watchEffect(effect2, options) {
            return doWatch(effect2, null, options);
        }
        const INITIAL_WATCHER_VALUE = {};
        function watch(source, cb, options) {
            return doWatch(source, cb, options);
        }
        function doWatch(source, cb, {immediate: immediate, deep: deep, flush: flush, once: once, onTrack: onTrack, onTrigger: onTrigger} = EMPTY_OBJ) {
            if (cb && once) {
                const _cb = cb;
                cb = (...args) => {
                    _cb(...args), unwatch();
                };
            }
            const instance = currentInstance, reactiveGetter = source2 => !0 === deep ? source2 : traverse(source2, !1 === deep ? 1 : void 0);
            let getter, cleanup2, forceTrigger = !1, isMultiSource = !1;
            if (isRef(source) ? (getter = () => source.value, forceTrigger = isShallow(source)) : isReactive(source) ? (getter = () => reactiveGetter(source), 
            forceTrigger = !0) : isArray$2(source) ? (isMultiSource = !0, forceTrigger = source.some((s2 => isReactive(s2) || isShallow(s2))), 
            getter = () => source.map((s2 => isRef(s2) ? s2.value : isReactive(s2) ? reactiveGetter(s2) : isFunction$2(s2) ? callWithErrorHandling(s2, instance, 2) : void 0))) : getter = isFunction$2(source) ? cb ? () => callWithErrorHandling(source, instance, 2) : () => (cleanup2 && cleanup2(), 
            callWithAsyncErrorHandling(source, instance, 3, [ onCleanup ])) : NOOP, cb && deep) {
                const baseGetter = getter;
                getter = () => traverse(baseGetter());
            }
            let ssrCleanup, onCleanup = fn => {
                cleanup2 = effect2.onStop = () => {
                    callWithErrorHandling(fn, instance, 4), cleanup2 = effect2.onStop = void 0;
                };
            };
            if (isInSSRComponentSetup) {
                if (onCleanup = NOOP, cb ? immediate && callWithAsyncErrorHandling(cb, instance, 3, [ getter(), isMultiSource ? [] : void 0, onCleanup ]) : getter(), 
                "sync" !== flush) return NOOP;
                {
                    const ctx = useSSRContext();
                    ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
                }
            }
            let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
            const job = () => {
                if (effect2.active && effect2.dirty) if (cb) {
                    const newValue = effect2.run();
                    (deep || forceTrigger || (isMultiSource ? newValue.some(((v2, i2) => hasChanged(v2, oldValue[i2]))) : hasChanged(newValue, oldValue))) && (cleanup2 && cleanup2(), 
                    callWithAsyncErrorHandling(cb, instance, 3, [ newValue, oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, onCleanup ]), 
                    oldValue = newValue);
                } else effect2.run();
            };
            let scheduler;
            job.allowRecurse = !!cb, "sync" === flush ? scheduler = job : "post" === flush ? scheduler = () => queuePostRenderEffect(job, instance && instance.suspense) : (job.pre = !0, 
            instance && (job.id = instance.uid), scheduler = () => queueJob(job));
            const effect2 = new ReactiveEffect(getter, NOOP, scheduler), scope = getCurrentScope(), unwatch = () => {
                effect2.stop(), scope && remove(scope.effects, effect2);
            };
            return cb ? immediate ? job() : oldValue = effect2.run() : "post" === flush ? queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense) : effect2.run(), 
            ssrCleanup && ssrCleanup.push(unwatch), unwatch;
        }
        function instanceWatch(source, value, options) {
            const publicThis = this.proxy, getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
            let cb;
            isFunction$2(value) ? cb = value : (cb = value.handler, options = value);
            const reset = setCurrentInstance(this), res = doWatch(getter, cb.bind(publicThis), options);
            return reset(), res;
        }
        function createPathGetter(ctx, path) {
            const segments = path.split(".");
            return () => {
                let cur = ctx;
                for (let i2 = 0; i2 < segments.length && cur; i2++) cur = cur[segments[i2]];
                return cur;
            };
        }
        function traverse(value, depth = 1 / 0, seen) {
            if (depth <= 0 || !isObject$3(value) || value.__v_skip) return value;
            if ((seen = seen || new Set).has(value)) return value;
            if (seen.add(value), depth--, isRef(value)) traverse(value.value, depth, seen); else if (isArray$2(value)) for (let i2 = 0; i2 < value.length; i2++) traverse(value[i2], depth, seen); else if (isSet$1(value) || isMap$1(value)) value.forEach((v2 => {
                traverse(v2, depth, seen);
            })); else if (isPlainObject$1(value)) {
                for (const key2 in value) traverse(value[key2], depth, seen);
                for (const key2 of Object.getOwnPropertySymbols(value)) Object.prototype.propertyIsEnumerable.call(value, key2) && traverse(value[key2], depth, seen);
            }
            return value;
        }
        const getModelModifiers = (props2, modelName) => "modelValue" === modelName || "model-value" === modelName ? props2.modelModifiers : props2[`${modelName}Modifiers`] || props2[`${camelize$1(modelName)}Modifiers`] || props2[`${hyphenate$1(modelName)}Modifiers`];
        function emit(instance, event, ...rawArgs) {
            if (instance.isUnmounted) return;
            const props2 = instance.vnode.props || EMPTY_OBJ;
            let args = rawArgs;
            const isModelListener2 = event.startsWith("update:"), modifiers = isModelListener2 && getModelModifiers(props2, event.slice(7));
            let handlerName;
            modifiers && (modifiers.trim && (args = rawArgs.map((a2 => isString$1(a2) ? a2.trim() : a2))), 
            modifiers.number && (args = rawArgs.map(looseToNumber)));
            let handler = props2[handlerName = toHandlerKey(event)] || props2[handlerName = toHandlerKey(camelize$1(event))];
            !handler && isModelListener2 && (handler = props2[handlerName = toHandlerKey(hyphenate$1(event))]), 
            handler && callWithAsyncErrorHandling(handler, instance, 6, args);
            const onceHandler = props2[handlerName + "Once"];
            if (onceHandler) {
                if (instance.emitted) {
                    if (instance.emitted[handlerName]) return;
                } else instance.emitted = {};
                instance.emitted[handlerName] = !0, callWithAsyncErrorHandling(onceHandler, instance, 6, args);
            }
        }
        function normalizeEmitsOptions(comp, appContext, asMixin = !1) {
            const cache = appContext.emitsCache, cached2 = cache.get(comp);
            if (void 0 !== cached2) return cached2;
            const raw = comp.emits;
            let normalized = {}, hasExtends = !1;
            if (!isFunction$2(comp)) {
                const extendEmits = raw2 => {
                    const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, !0);
                    normalizedFromExtend && (hasExtends = !0, extend(normalized, normalizedFromExtend));
                };
                !asMixin && appContext.mixins.length && appContext.mixins.forEach(extendEmits), 
                comp.extends && extendEmits(comp.extends), comp.mixins && comp.mixins.forEach(extendEmits);
            }
            return raw || hasExtends ? (isArray$2(raw) ? raw.forEach((key2 => normalized[key2] = null)) : extend(normalized, raw), 
            isObject$3(comp) && cache.set(comp, normalized), normalized) : (isObject$3(comp) && cache.set(comp, null), 
            null);
        }
        function isEmitListener(options, key2) {
            return !(!options || !isOn$1(key2)) && (key2 = key2.slice(2).replace(/Once$/, ""), 
            hasOwn$1(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$1(options, hyphenate$1(key2)) || hasOwn$1(options, key2));
        }
        function renderComponentRoot(instance) {
            const {type: Component, vnode: vnode, proxy: proxy, withProxy: withProxy, propsOptions: [propsOptions], slots: slots, attrs: attrs, emit: emit2, render: render2, renderCache: renderCache, props: props2, data: data, setupState: setupState, ctx: ctx, inheritAttrs: inheritAttrs} = instance, prev2 = setCurrentRenderingInstance(instance);
            let result, fallthroughAttrs;
            try {
                if (4 & vnode.shapeFlag) {
                    const proxyToUse = withProxy || proxy, thisProxy = proxyToUse;
                    result = normalizeVNode(render2.call(thisProxy, proxyToUse, renderCache, props2, setupState, data, ctx)), 
                    fallthroughAttrs = attrs;
                } else {
                    const render22 = Component;
                    0, result = normalizeVNode(render22.length > 1 ? render22(props2, {
                        attrs: attrs,
                        slots: slots,
                        emit: emit2
                    }) : render22(props2, null)), fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
                }
            } catch (err) {
                blockStack.length = 0, handleError(err, instance, 1), result = createVNode(Comment);
            }
            let root2 = result;
            if (fallthroughAttrs && !1 !== inheritAttrs) {
                const keys2 = Object.keys(fallthroughAttrs), {shapeFlag: shapeFlag} = root2;
                keys2.length && 7 & shapeFlag && (propsOptions && keys2.some(isModelListener) && (fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions)), 
                root2 = cloneVNode(root2, fallthroughAttrs, !1, !0));
            }
            return vnode.dirs && (root2 = cloneVNode(root2, null, !1, !0), root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs), 
            vnode.transition && (root2.transition = vnode.transition), result = root2, setCurrentRenderingInstance(prev2), 
            result;
        }
        const getFunctionalFallthrough = attrs => {
            let res;
            for (const key2 in attrs) ("class" === key2 || "style" === key2 || isOn$1(key2)) && ((res || (res = {}))[key2] = attrs[key2]);
            return res;
        }, filterModelListeners = (attrs, props2) => {
            const res = {};
            for (const key2 in attrs) isModelListener(key2) && key2.slice(9) in props2 || (res[key2] = attrs[key2]);
            return res;
        };
        function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
            const {props: prevProps, children: prevChildren, component: component} = prevVNode, {props: nextProps, children: nextChildren, patchFlag: patchFlag} = nextVNode, emits = component.emitsOptions;
            if (nextVNode.dirs || nextVNode.transition) return !0;
            if (!(optimized && patchFlag >= 0)) return !(!prevChildren && !nextChildren || nextChildren && nextChildren.$stable) || prevProps !== nextProps && (prevProps ? !nextProps || hasPropsChanged(prevProps, nextProps, emits) : !!nextProps);
            if (1024 & patchFlag) return !0;
            if (16 & patchFlag) return prevProps ? hasPropsChanged(prevProps, nextProps, emits) : !!nextProps;
            if (8 & patchFlag) {
                const dynamicProps = nextVNode.dynamicProps;
                for (let i2 = 0; i2 < dynamicProps.length; i2++) {
                    const key2 = dynamicProps[i2];
                    if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) return !0;
                }
            }
            return !1;
        }
        function hasPropsChanged(prevProps, nextProps, emitsOptions) {
            const nextKeys = Object.keys(nextProps);
            if (nextKeys.length !== Object.keys(prevProps).length) return !0;
            for (let i2 = 0; i2 < nextKeys.length; i2++) {
                const key2 = nextKeys[i2];
                if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) return !0;
            }
            return !1;
        }
        function updateHOCHostEl({vnode: vnode, parent: parent2}, el) {
            for (;parent2; ) {
                const root2 = parent2.subTree;
                if (root2.suspense && root2.suspense.activeBranch === vnode && (root2.el = vnode.el), 
                root2 !== vnode) break;
                (vnode = parent2.vnode).el = el, parent2 = parent2.parent;
            }
        }
        const isSuspense = type => type.__isSuspense;
        function queueEffectWithSuspense(fn, suspense) {
            suspense && suspense.pendingBranch ? isArray$2(fn) ? suspense.effects.push(...fn) : suspense.effects.push(fn) : queuePostFlushCb(fn);
        }
        const Fragment = Symbol.for("v-fgt"), Text = Symbol.for("v-txt"), Comment = Symbol.for("v-cmt"), Static = Symbol.for("v-stc"), blockStack = [];
        let currentBlock = null;
        function openBlock(disableTracking = !1) {
            blockStack.push(currentBlock = disableTracking ? null : []);
        }
        function closeBlock() {
            blockStack.pop(), currentBlock = blockStack[blockStack.length - 1] || null;
        }
        let isBlockTreeEnabled = 1;
        function setBlockTracking(value) {
            isBlockTreeEnabled += value, value < 0 && currentBlock && (currentBlock.hasOnce = !0);
        }
        function setupBlock(vnode) {
            return vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null, 
            closeBlock(), isBlockTreeEnabled > 0 && currentBlock && currentBlock.push(vnode), 
            vnode;
        }
        function createElementBlock(type, props2, children, patchFlag, dynamicProps, shapeFlag) {
            return setupBlock(createBaseVNode(type, props2, children, patchFlag, dynamicProps, shapeFlag, !0));
        }
        function createBlock(type, props2, children, patchFlag, dynamicProps) {
            return setupBlock(createVNode(type, props2, children, patchFlag, dynamicProps, !0));
        }
        function isVNode(value) {
            return !!value && !0 === value.__v_isVNode;
        }
        function isSameVNodeType(n1, n2) {
            return n1.type === n2.type && n1.key === n2.key;
        }
        const normalizeKey = ({key: key2}) => null != key2 ? key2 : null, normalizeRef = ({ref: ref3, ref_key: ref_key, ref_for: ref_for}) => ("number" == typeof ref3 && (ref3 = "" + ref3), 
        null != ref3 ? isString$1(ref3) || isRef(ref3) || isFunction$2(ref3) ? {
            i: currentRenderingInstance,
            r: ref3,
            k: ref_key,
            f: !!ref_for
        } : ref3 : null);
        function createBaseVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = (type === Fragment ? 0 : 1), isBlockNode = !1, needFullChildrenNormalization = !1) {
            const vnode = {
                __v_isVNode: !0,
                __v_skip: !0,
                type: type,
                props: props2,
                key: props2 && normalizeKey(props2),
                ref: props2 && normalizeRef(props2),
                scopeId: currentScopeId,
                slotScopeIds: null,
                children: children,
                component: null,
                suspense: null,
                ssContent: null,
                ssFallback: null,
                dirs: null,
                transition: null,
                el: null,
                anchor: null,
                target: null,
                targetStart: null,
                targetAnchor: null,
                staticCount: 0,
                shapeFlag: shapeFlag,
                patchFlag: patchFlag,
                dynamicProps: dynamicProps,
                dynamicChildren: null,
                appContext: null,
                ctx: currentRenderingInstance
            };
            return needFullChildrenNormalization ? (normalizeChildren(vnode, children), 128 & shapeFlag && type.normalize(vnode)) : children && (vnode.shapeFlag |= isString$1(children) ? 8 : 16), 
            isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || 6 & shapeFlag) && 32 !== vnode.patchFlag && currentBlock.push(vnode), 
            vnode;
        }
        const createVNode = _createVNode;
        function _createVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = !1) {
            if (type && type !== NULL_DYNAMIC_COMPONENT || (type = Comment), isVNode(type)) {
                const cloned = cloneVNode(type, props2, !0);
                return children && normalizeChildren(cloned, children), isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (6 & cloned.shapeFlag ? currentBlock[currentBlock.indexOf(type)] = cloned : currentBlock.push(cloned)), 
                cloned.patchFlag = -2, cloned;
            }
            if (isClassComponent(type) && (type = type.__vccOpts), props2) {
                props2 = guardReactiveProps(props2);
                let {class: klass, style: style} = props2;
                klass && !isString$1(klass) && (props2.class = normalizeClass(klass)), isObject$3(style) && (isProxy(style) && !isArray$2(style) && (style = extend({}, style)), 
                props2.style = normalizeStyle$1(style));
            }
            return createBaseVNode(type, props2, children, patchFlag, dynamicProps, isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$2(type) ? 2 : 0, isBlockNode, !0);
        }
        function guardReactiveProps(props2) {
            return props2 ? isProxy(props2) || isInternalObject(props2) ? extend({}, props2) : props2 : null;
        }
        function cloneVNode(vnode, extraProps, mergeRef = !1, cloneTransition = !1) {
            const {props: props2, ref: ref3, patchFlag: patchFlag, children: children, transition: transition} = vnode, mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2, cloned = {
                __v_isVNode: !0,
                __v_skip: !0,
                type: vnode.type,
                props: mergedProps,
                key: mergedProps && normalizeKey(mergedProps),
                ref: extraProps && extraProps.ref ? mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ ref3, normalizeRef(extraProps) ] : normalizeRef(extraProps) : ref3,
                scopeId: vnode.scopeId,
                slotScopeIds: vnode.slotScopeIds,
                children: children,
                target: vnode.target,
                targetStart: vnode.targetStart,
                targetAnchor: vnode.targetAnchor,
                staticCount: vnode.staticCount,
                shapeFlag: vnode.shapeFlag,
                patchFlag: extraProps && vnode.type !== Fragment ? -1 === patchFlag ? 16 : 16 | patchFlag : patchFlag,
                dynamicProps: vnode.dynamicProps,
                dynamicChildren: vnode.dynamicChildren,
                appContext: vnode.appContext,
                dirs: vnode.dirs,
                transition: transition,
                component: vnode.component,
                suspense: vnode.suspense,
                ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
                ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
                el: vnode.el,
                anchor: vnode.anchor,
                ctx: vnode.ctx,
                ce: vnode.ce
            };
            return transition && cloneTransition && setTransitionHooks(cloned, transition.clone(cloned)), 
            cloned;
        }
        function createTextVNode(text = " ", flag = 0) {
            return createVNode(Text, null, text, flag);
        }
        function normalizeVNode(child) {
            return null == child || "boolean" == typeof child ? createVNode(Comment) : isArray$2(child) ? createVNode(Fragment, null, child.slice()) : "object" == typeof child ? cloneIfMounted(child) : createVNode(Text, null, String(child));
        }
        function cloneIfMounted(child) {
            return null === child.el && -1 !== child.patchFlag || child.memo ? child : cloneVNode(child);
        }
        function normalizeChildren(vnode, children) {
            let type = 0;
            const {shapeFlag: shapeFlag} = vnode;
            if (null == children) children = null; else if (isArray$2(children)) type = 16; else if ("object" == typeof children) {
                if (65 & shapeFlag) {
                    const slot = children.default;
                    return void (slot && (slot._c && (slot._d = !1), normalizeChildren(vnode, slot()), 
                    slot._c && (slot._d = !0)));
                }
                {
                    type = 32;
                    const slotFlag = children._;
                    slotFlag || isInternalObject(children) ? 3 === slotFlag && currentRenderingInstance && (1 === currentRenderingInstance.slots._ ? children._ = 1 : (children._ = 2, 
                    vnode.patchFlag |= 1024)) : children._ctx = currentRenderingInstance;
                }
            } else isFunction$2(children) ? (children = {
                default: children,
                _ctx: currentRenderingInstance
            }, type = 32) : (children = String(children), 64 & shapeFlag ? (type = 16, children = [ createTextVNode(children) ]) : type = 8);
            vnode.children = children, vnode.shapeFlag |= type;
        }
        function mergeProps(...args) {
            const ret = {};
            for (let i2 = 0; i2 < args.length; i2++) {
                const toMerge = args[i2];
                for (const key2 in toMerge) if ("class" === key2) ret.class !== toMerge.class && (ret.class = normalizeClass([ ret.class, toMerge.class ])); else if ("style" === key2) ret.style = normalizeStyle$1([ ret.style, toMerge.style ]); else if (isOn$1(key2)) {
                    const existing = ret[key2], incoming = toMerge[key2];
                    !incoming || existing === incoming || isArray$2(existing) && existing.includes(incoming) || (ret[key2] = existing ? [].concat(existing, incoming) : incoming);
                } else "" !== key2 && (ret[key2] = toMerge[key2]);
            }
            return ret;
        }
        function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
            callWithAsyncErrorHandling(hook, instance, 7, [ vnode, prevVNode ]);
        }
        const emptyAppContext = createAppContext();
        let uid = 0;
        function createComponentInstance(vnode, parent2, suspense) {
            const type = vnode.type, appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext, instance = {
                uid: uid++,
                vnode: vnode,
                type: type,
                parent: parent2,
                appContext: appContext,
                root: null,
                next: null,
                subTree: null,
                effect: null,
                update: null,
                scope: new EffectScope(!0),
                render: null,
                proxy: null,
                exposed: null,
                exposeProxy: null,
                withProxy: null,
                provides: parent2 ? parent2.provides : Object.create(appContext.provides),
                accessCache: null,
                renderCache: [],
                components: null,
                directives: null,
                propsOptions: normalizePropsOptions(type, appContext),
                emitsOptions: normalizeEmitsOptions(type, appContext),
                emit: null,
                emitted: null,
                propsDefaults: EMPTY_OBJ,
                inheritAttrs: type.inheritAttrs,
                ctx: EMPTY_OBJ,
                data: EMPTY_OBJ,
                props: EMPTY_OBJ,
                attrs: EMPTY_OBJ,
                slots: EMPTY_OBJ,
                refs: EMPTY_OBJ,
                setupState: EMPTY_OBJ,
                setupContext: null,
                suspense: suspense,
                suspenseId: suspense ? suspense.pendingId : 0,
                asyncDep: null,
                asyncResolved: !1,
                isMounted: !1,
                isUnmounted: !1,
                isDeactivated: !1,
                bc: null,
                c: null,
                bm: null,
                m: null,
                bu: null,
                u: null,
                um: null,
                bum: null,
                da: null,
                a: null,
                rtg: null,
                rtc: null,
                ec: null,
                sp: null
            };
            return instance.ctx = {
                _: instance
            }, instance.root = parent2 ? parent2.root : instance, instance.emit = emit.bind(null, instance), 
            vnode.ce && vnode.ce(instance), instance;
        }
        let currentInstance = null;
        const getCurrentInstance = () => currentInstance || currentRenderingInstance;
        let internalSetCurrentInstance, setInSSRSetupState;
        {
            const g2 = getGlobalThis(), registerGlobalSetter = (key2, setter) => {
                let setters;
                return (setters = g2[key2]) || (setters = g2[key2] = []), setters.push(setter), 
                v2 => {
                    setters.length > 1 ? setters.forEach((set2 => set2(v2))) : setters[0](v2);
                };
            };
            internalSetCurrentInstance = registerGlobalSetter("__VUE_INSTANCE_SETTERS__", (v2 => currentInstance = v2)), 
            setInSSRSetupState = registerGlobalSetter("__VUE_SSR_SETTERS__", (v2 => isInSSRComponentSetup = v2));
        }
        const setCurrentInstance = instance => {
            const prev2 = currentInstance;
            return internalSetCurrentInstance(instance), instance.scope.on(), () => {
                instance.scope.off(), internalSetCurrentInstance(prev2);
            };
        }, unsetCurrentInstance = () => {
            currentInstance && currentInstance.scope.off(), internalSetCurrentInstance(null);
        };
        function isStatefulComponent(instance) {
            return 4 & instance.vnode.shapeFlag;
        }
        let compile$1, isInSSRComponentSetup = !1;
        function setupComponent(instance, isSSR = !1, optimized = !1) {
            isSSR && setInSSRSetupState(isSSR);
            const {props: props2, children: children} = instance.vnode, isStateful = isStatefulComponent(instance);
            initProps(instance, props2, isStateful, isSSR), initSlots(instance, children, optimized);
            const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
            return isSSR && setInSSRSetupState(!1), setupResult;
        }
        function setupStatefulComponent(instance, isSSR) {
            const Component = instance.type;
            instance.accessCache = Object.create(null), instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
            const {setup: setup} = Component;
            if (setup) {
                const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null, reset = setCurrentInstance(instance);
                pauseTracking();
                const setupResult = callWithErrorHandling(setup, instance, 0, [ instance.props, setupContext ]);
                if (resetTracking(), reset(), isPromise(setupResult)) {
                    if (setupResult.then(unsetCurrentInstance, unsetCurrentInstance), isSSR) return setupResult.then((resolvedResult => {
                        handleSetupResult(instance, resolvedResult, isSSR);
                    })).catch((e2 => {
                        handleError(e2, instance, 0);
                    }));
                    instance.asyncDep = setupResult;
                } else handleSetupResult(instance, setupResult, isSSR);
            } else finishComponentSetup(instance, isSSR);
        }
        function handleSetupResult(instance, setupResult, isSSR) {
            isFunction$2(setupResult) ? instance.type.__ssrInlineRender ? instance.ssrRender = setupResult : instance.render = setupResult : isObject$3(setupResult) && (instance.setupState = proxyRefs(setupResult)), 
            finishComponentSetup(instance, isSSR);
        }
        function finishComponentSetup(instance, isSSR, skipOptions) {
            const Component = instance.type;
            if (!instance.render) {
                if (!isSSR && compile$1 && !Component.render) {
                    const template = Component.template || resolveMergedOptions(instance).template;
                    if (template) {
                        const {isCustomElement: isCustomElement, compilerOptions: compilerOptions} = instance.appContext.config, {delimiters: delimiters, compilerOptions: componentCompilerOptions} = Component, finalCompilerOptions = extend(extend({
                            isCustomElement: isCustomElement,
                            delimiters: delimiters
                        }, compilerOptions), componentCompilerOptions);
                        Component.render = compile$1(template, finalCompilerOptions);
                    }
                }
                instance.render = Component.render || NOOP;
            }
            {
                const reset = setCurrentInstance(instance);
                pauseTracking();
                try {
                    applyOptions(instance);
                } finally {
                    resetTracking(), reset();
                }
            }
        }
        const attrsProxyHandlers = {
            get: (target, key2) => (track(target, "get", ""), target[key2])
        };
        function createSetupContext(instance) {
            const expose = exposed => {
                instance.exposed = exposed || {};
            };
            return {
                attrs: new Proxy(instance.attrs, attrsProxyHandlers),
                slots: instance.slots,
                emit: instance.emit,
                expose: expose
            };
        }
        function getComponentPublicInstance(instance) {
            return instance.exposed ? instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
                get: (target, key2) => key2 in target ? target[key2] : key2 in publicPropertiesMap ? publicPropertiesMap[key2](instance) : void 0,
                has: (target, key2) => key2 in target || key2 in publicPropertiesMap
            })) : instance.proxy;
        }
        function isClassComponent(value) {
            return isFunction$2(value) && "__vccOpts" in value;
        }
        const computed = (getterOrOptions, debugOptions) => computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
        function h$1(type, propsOrChildren, children) {
            const l2 = arguments.length;
            return 2 === l2 ? isObject$3(propsOrChildren) && !isArray$2(propsOrChildren) ? isVNode(propsOrChildren) ? createVNode(type, null, [ propsOrChildren ]) : createVNode(type, propsOrChildren) : createVNode(type, null, propsOrChildren) : (l2 > 3 ? children = Array.prototype.slice.call(arguments, 2) : 3 === l2 && isVNode(children) && (children = [ children ]), 
            createVNode(type, propsOrChildren, children));
        }
        const version$1 = "3.4.38", svgNS = "http://www.w3.org/2000/svg", mathmlNS = "http://www.w3.org/1998/Math/MathML", doc = "undefined" != typeof document ? document : null, templateContainer = doc && doc.createElement("template"), nodeOps = {
            insert: (child, parent2, anchor) => {
                parent2.insertBefore(child, anchor || null);
            },
            remove: child => {
                const parent2 = child.parentNode;
                parent2 && parent2.removeChild(child);
            },
            createElement: (tag, namespace, is, props2) => {
                const el = "svg" === namespace ? doc.createElementNS(svgNS, tag) : "mathml" === namespace ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, {
                    is: is
                }) : doc.createElement(tag);
                return "select" === tag && props2 && null != props2.multiple && el.setAttribute("multiple", props2.multiple), 
                el;
            },
            createText: text => doc.createTextNode(text),
            createComment: text => doc.createComment(text),
            setText: (node2, text) => {
                node2.nodeValue = text;
            },
            setElementText: (el, text) => {
                el.textContent = text;
            },
            parentNode: node2 => node2.parentNode,
            nextSibling: node2 => node2.nextSibling,
            querySelector: selector => doc.querySelector(selector),
            setScopeId(el, id) {
                el.setAttribute(id, "");
            },
            insertStaticContent(content, parent2, anchor, namespace, start, end) {
                const before = anchor ? anchor.previousSibling : parent2.lastChild;
                if (start && (start === end || start.nextSibling)) for (;parent2.insertBefore(start.cloneNode(!0), anchor), 
                start !== end && (start = start.nextSibling); ) ; else {
                    templateContainer.innerHTML = "svg" === namespace ? `<svg>${content}</svg>` : "mathml" === namespace ? `<math>${content}</math>` : content;
                    const template = templateContainer.content;
                    if ("svg" === namespace || "mathml" === namespace) {
                        const wrapper = template.firstChild;
                        for (;wrapper.firstChild; ) template.appendChild(wrapper.firstChild);
                        template.removeChild(wrapper);
                    }
                    parent2.insertBefore(template, anchor);
                }
                return [ before ? before.nextSibling : parent2.firstChild, anchor ? anchor.previousSibling : parent2.lastChild ];
            }
        }, TRANSITION = "transition", ANIMATION = "animation", vtcKey = Symbol("_vtc"), Transition = (props2, {slots: slots}) => h$1(BaseTransition, resolveTransitionProps(props2), slots);
        Transition.displayName = "Transition";
        const DOMTransitionPropsValidators = {
            name: String,
            type: String,
            css: {
                type: Boolean,
                default: !0
            },
            duration: [ String, Number, Object ],
            enterFromClass: String,
            enterActiveClass: String,
            enterToClass: String,
            appearFromClass: String,
            appearActiveClass: String,
            appearToClass: String,
            leaveFromClass: String,
            leaveActiveClass: String,
            leaveToClass: String
        }, TransitionPropsValidators = Transition.props = extend({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators), callHook = (hook, args = []) => {
            isArray$2(hook) ? hook.forEach((h2 => h2(...args))) : hook && hook(...args);
        }, hasExplicitCallback = hook => !!hook && (isArray$2(hook) ? hook.some((h2 => h2.length > 1)) : hook.length > 1);
        function resolveTransitionProps(rawProps) {
            const baseProps = {};
            for (const key2 in rawProps) key2 in DOMTransitionPropsValidators || (baseProps[key2] = rawProps[key2]);
            if (!1 === rawProps.css) return baseProps;
            const {name: name = "v", type: type, duration: duration, enterFromClass: enterFromClass = `${name}-enter-from`, enterActiveClass: enterActiveClass = `${name}-enter-active`, enterToClass: enterToClass = `${name}-enter-to`, appearFromClass: appearFromClass = enterFromClass, appearActiveClass: appearActiveClass = enterActiveClass, appearToClass: appearToClass = enterToClass, leaveFromClass: leaveFromClass = `${name}-leave-from`, leaveActiveClass: leaveActiveClass = `${name}-leave-active`, leaveToClass: leaveToClass = `${name}-leave-to`} = rawProps, durations = normalizeDuration(duration), enterDuration = durations && durations[0], leaveDuration = durations && durations[1], {onBeforeEnter: onBeforeEnter, onEnter: onEnter, onEnterCancelled: onEnterCancelled, onLeave: onLeave, onLeaveCancelled: onLeaveCancelled, onBeforeAppear: onBeforeAppear = onBeforeEnter, onAppear: onAppear = onEnter, onAppearCancelled: onAppearCancelled = onEnterCancelled} = baseProps, finishEnter = (el, isAppear, done) => {
                removeTransitionClass(el, isAppear ? appearToClass : enterToClass), removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass), 
                done && done();
            }, finishLeave = (el, done) => {
                el._isLeaving = !1, removeTransitionClass(el, leaveFromClass), removeTransitionClass(el, leaveToClass), 
                removeTransitionClass(el, leaveActiveClass), done && done();
            }, makeEnterHook = isAppear => (el, done) => {
                const hook = isAppear ? onAppear : onEnter, resolve2 = () => finishEnter(el, isAppear, done);
                callHook(hook, [ el, resolve2 ]), nextFrame((() => {
                    removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass), addTransitionClass(el, isAppear ? appearToClass : enterToClass), 
                    hasExplicitCallback(hook) || whenTransitionEnds(el, type, enterDuration, resolve2);
                }));
            };
            return extend(baseProps, {
                onBeforeEnter(el) {
                    callHook(onBeforeEnter, [ el ]), addTransitionClass(el, enterFromClass), addTransitionClass(el, enterActiveClass);
                },
                onBeforeAppear(el) {
                    callHook(onBeforeAppear, [ el ]), addTransitionClass(el, appearFromClass), addTransitionClass(el, appearActiveClass);
                },
                onEnter: makeEnterHook(!1),
                onAppear: makeEnterHook(!0),
                onLeave(el, done) {
                    el._isLeaving = !0;
                    const resolve2 = () => finishLeave(el, done);
                    addTransitionClass(el, leaveFromClass), addTransitionClass(el, leaveActiveClass), 
                    forceReflow(), nextFrame((() => {
                        el._isLeaving && (removeTransitionClass(el, leaveFromClass), addTransitionClass(el, leaveToClass), 
                        hasExplicitCallback(onLeave) || whenTransitionEnds(el, type, leaveDuration, resolve2));
                    })), callHook(onLeave, [ el, resolve2 ]);
                },
                onEnterCancelled(el) {
                    finishEnter(el, !1), callHook(onEnterCancelled, [ el ]);
                },
                onAppearCancelled(el) {
                    finishEnter(el, !0), callHook(onAppearCancelled, [ el ]);
                },
                onLeaveCancelled(el) {
                    finishLeave(el), callHook(onLeaveCancelled, [ el ]);
                }
            });
        }
        function normalizeDuration(duration) {
            if (null == duration) return null;
            if (isObject$3(duration)) return [ NumberOf(duration.enter), NumberOf(duration.leave) ];
            {
                const n2 = NumberOf(duration);
                return [ n2, n2 ];
            }
        }
        function NumberOf(val) {
            return toNumber$1(val);
        }
        function addTransitionClass(el, cls) {
            cls.split(/\s+/).forEach((c2 => c2 && el.classList.add(c2))), (el[vtcKey] || (el[vtcKey] = new Set)).add(cls);
        }
        function removeTransitionClass(el, cls) {
            cls.split(/\s+/).forEach((c2 => c2 && el.classList.remove(c2)));
            const _vtc = el[vtcKey];
            _vtc && (_vtc.delete(cls), _vtc.size || (el[vtcKey] = void 0));
        }
        function nextFrame(cb) {
            requestAnimationFrame((() => {
                requestAnimationFrame(cb);
            }));
        }
        let endId = 0;
        function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
            const id = el._endId = ++endId, resolveIfNotStale = () => {
                id === el._endId && resolve2();
            };
            if (explicitTimeout) return setTimeout(resolveIfNotStale, explicitTimeout);
            const {type: type, timeout: timeout, propCount: propCount} = getTransitionInfo(el, expectedType);
            if (!type) return resolve2();
            const endEvent = type + "end";
            let ended = 0;
            const end = () => {
                el.removeEventListener(endEvent, onEnd), resolveIfNotStale();
            }, onEnd = e2 => {
                e2.target === el && ++ended >= propCount && end();
            };
            setTimeout((() => {
                ended < propCount && end();
            }), timeout + 1), el.addEventListener(endEvent, onEnd);
        }
        function getTransitionInfo(el, expectedType) {
            const styles = window.getComputedStyle(el), getStyleProperties = key2 => (styles[key2] || "").split(", "), transitionDelays = getStyleProperties(`${TRANSITION}Delay`), transitionDurations = getStyleProperties(`${TRANSITION}Duration`), transitionTimeout = getTimeout(transitionDelays, transitionDurations), animationDelays = getStyleProperties(`${ANIMATION}Delay`), animationDurations = getStyleProperties(`${ANIMATION}Duration`), animationTimeout = getTimeout(animationDelays, animationDurations);
            let type = null, timeout = 0, propCount = 0;
            expectedType === TRANSITION ? transitionTimeout > 0 && (type = TRANSITION, timeout = transitionTimeout, 
            propCount = transitionDurations.length) : expectedType === ANIMATION ? animationTimeout > 0 && (type = ANIMATION, 
            timeout = animationTimeout, propCount = animationDurations.length) : (timeout = Math.max(transitionTimeout, animationTimeout), 
            type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null, 
            propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0);
            return {
                type: type,
                timeout: timeout,
                propCount: propCount,
                hasTransform: type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString())
            };
        }
        function getTimeout(delays, durations) {
            for (;delays.length < durations.length; ) delays = delays.concat(delays);
            return Math.max(...durations.map(((d2, i2) => toMs(d2) + toMs(delays[i2]))));
        }
        function toMs(s2) {
            return "auto" === s2 ? 0 : 1e3 * Number(s2.slice(0, -1).replace(",", "."));
        }
        function forceReflow() {
            return document.body.offsetHeight;
        }
        function patchClass(el, value, isSVG) {
            const transitionClasses = el[vtcKey];
            transitionClasses && (value = (value ? [ value, ...transitionClasses ] : [ ...transitionClasses ]).join(" ")), 
            null == value ? el.removeAttribute("class") : isSVG ? el.setAttribute("class", value) : el.className = value;
        }
        const vShowOriginalDisplay = Symbol("_vod"), vShowHidden = Symbol("_vsh"), vShow = {
            beforeMount(el, {value: value}, {transition: transition}) {
                el[vShowOriginalDisplay] = "none" === el.style.display ? "" : el.style.display, 
                transition && value ? transition.beforeEnter(el) : setDisplay(el, value);
            },
            mounted(el, {value: value}, {transition: transition}) {
                transition && value && transition.enter(el);
            },
            updated(el, {value: value, oldValue: oldValue}, {transition: transition}) {
                !value != !oldValue && (transition ? value ? (transition.beforeEnter(el), setDisplay(el, !0), 
                transition.enter(el)) : transition.leave(el, (() => {
                    setDisplay(el, !1);
                })) : setDisplay(el, value));
            },
            beforeUnmount(el, {value: value}) {
                setDisplay(el, value);
            }
        };
        function setDisplay(el, value) {
            el.style.display = value ? el[vShowOriginalDisplay] : "none", el[vShowHidden] = !value;
        }
        const CSS_VAR_TEXT = Symbol(""), displayRE = /(^|;)\s*display\s*:/;
        function patchStyle(el, prev2, next2) {
            const style = el.style, isCssString = isString$1(next2);
            let hasControlledDisplay = !1;
            if (next2 && !isCssString) {
                if (prev2) if (isString$1(prev2)) for (const prevStyle of prev2.split(";")) {
                    const key2 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                    null == next2[key2] && setStyle(style, key2, "");
                } else for (const key2 in prev2) null == next2[key2] && setStyle(style, key2, "");
                for (const key2 in next2) "display" === key2 && (hasControlledDisplay = !0), setStyle(style, key2, next2[key2]);
            } else if (isCssString) {
                if (prev2 !== next2) {
                    const cssVarText = style[CSS_VAR_TEXT];
                    cssVarText && (next2 += ";" + cssVarText), style.cssText = next2, hasControlledDisplay = displayRE.test(next2);
                }
            } else prev2 && el.removeAttribute("style");
            vShowOriginalDisplay in el && (el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "", 
            el[vShowHidden] && (style.display = "none"));
        }
        const importantRE = /\s*!important$/;
        function setStyle(style, name, val) {
            if (isArray$2(val)) val.forEach((v2 => setStyle(style, name, v2))); else if (null == val && (val = ""), 
            name.startsWith("--")) style.setProperty(name, val); else {
                const prefixed = autoPrefix(style, name);
                importantRE.test(val) ? style.setProperty(hyphenate$1(prefixed), val.replace(importantRE, ""), "important") : style[prefixed] = val;
            }
        }
        const prefixes = [ "Webkit", "Moz", "ms" ], prefixCache = {};
        function autoPrefix(style, rawName) {
            const cached2 = prefixCache[rawName];
            if (cached2) return cached2;
            let name = camelize$1(rawName);
            if ("filter" !== name && name in style) return prefixCache[rawName] = name;
            name = capitalize$1(name);
            for (let i2 = 0; i2 < prefixes.length; i2++) {
                const prefixed = prefixes[i2] + name;
                if (prefixed in style) return prefixCache[rawName] = prefixed;
            }
            return rawName;
        }
        const xlinkNS = "http://www.w3.org/1999/xlink";
        function patchAttr(el, key2, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key2)) {
            isSVG && key2.startsWith("xlink:") ? null == value ? el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length)) : el.setAttributeNS(xlinkNS, key2, value) : null == value || isBoolean && !includeBooleanAttr(value) ? el.removeAttribute(key2) : el.setAttribute(key2, isBoolean ? "" : isSymbol$1(value) ? String(value) : value);
        }
        function patchDOMProp(el, key2, value, parentComponent) {
            if ("innerHTML" === key2 || "textContent" === key2) {
                if (null == value) return;
                return void (el[key2] = value);
            }
            const tag = el.tagName;
            if ("value" === key2 && "PROGRESS" !== tag && !tag.includes("-")) {
                const oldValue = "OPTION" === tag ? el.getAttribute("value") || "" : el.value, newValue = null == value ? "" : String(value);
                return oldValue === newValue && "_value" in el || (el.value = newValue), null == value && el.removeAttribute(key2), 
                void (el._value = value);
            }
            let needRemove = !1;
            if ("" === value || null == value) {
                const type = typeof el[key2];
                "boolean" === type ? value = includeBooleanAttr(value) : null == value && "string" === type ? (value = "", 
                needRemove = !0) : "number" === type && (value = 0, needRemove = !0);
            }
            try {
                el[key2] = value;
            } catch (e2) {}
            needRemove && el.removeAttribute(key2);
        }
        function addEventListener(el, event, handler, options) {
            el.addEventListener(event, handler, options);
        }
        function removeEventListener(el, event, handler, options) {
            el.removeEventListener(event, handler, options);
        }
        const veiKey = Symbol("_vei");
        function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
            const invokers = el[veiKey] || (el[veiKey] = {}), existingInvoker = invokers[rawName];
            if (nextValue && existingInvoker) existingInvoker.value = nextValue; else {
                const [name, options] = parseName(rawName);
                if (nextValue) {
                    addEventListener(el, name, invokers[rawName] = createInvoker(nextValue, instance), options);
                } else existingInvoker && (removeEventListener(el, name, existingInvoker, options), 
                invokers[rawName] = void 0);
            }
        }
        const optionsModifierRE = /(?:Once|Passive|Capture)$/;
        function parseName(name) {
            let options;
            if (optionsModifierRE.test(name)) {
                let m2;
                for (options = {}; m2 = name.match(optionsModifierRE); ) name = name.slice(0, name.length - m2[0].length), 
                options[m2[0].toLowerCase()] = !0;
            }
            return [ ":" === name[2] ? name.slice(3) : hyphenate$1(name.slice(2)), options ];
        }
        let cachedNow = 0;
        const p = Promise.resolve(), getNow = () => cachedNow || (p.then((() => cachedNow = 0)), 
        cachedNow = Date.now());
        function createInvoker(initialValue, instance) {
            const invoker = e2 => {
                if (e2._vts) {
                    if (e2._vts <= invoker.attached) return;
                } else e2._vts = Date.now();
                callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [ e2 ]);
            };
            return invoker.value = initialValue, invoker.attached = getNow(), invoker;
        }
        function patchStopImmediatePropagation(e2, value) {
            if (isArray$2(value)) {
                const originalStop = e2.stopImmediatePropagation;
                return e2.stopImmediatePropagation = () => {
                    originalStop.call(e2), e2._stopped = !0;
                }, value.map((fn => e22 => !e22._stopped && fn && fn(e22)));
            }
            return value;
        }
        const isNativeOn = key2 => 111 === key2.charCodeAt(0) && 110 === key2.charCodeAt(1) && key2.charCodeAt(2) > 96 && key2.charCodeAt(2) < 123, patchProp = (el, key2, prevValue, nextValue, namespace, parentComponent) => {
            const isSVG = "svg" === namespace;
            "class" === key2 ? patchClass(el, nextValue, isSVG) : "style" === key2 ? patchStyle(el, prevValue, nextValue) : isOn$1(key2) ? isModelListener(key2) || patchEvent(el, key2, prevValue, nextValue, parentComponent) : ("." === key2[0] ? (key2 = key2.slice(1), 
            1) : "^" === key2[0] ? (key2 = key2.slice(1), 0) : shouldSetAsProp(el, key2, nextValue, isSVG)) ? (patchDOMProp(el, key2, nextValue), 
            el.tagName.includes("-") || "value" !== key2 && "checked" !== key2 && "selected" !== key2 || patchAttr(el, key2, nextValue, isSVG, parentComponent, "value" !== key2)) : ("true-value" === key2 ? el._trueValue = nextValue : "false-value" === key2 && (el._falseValue = nextValue), 
            patchAttr(el, key2, nextValue, isSVG));
        };
        function shouldSetAsProp(el, key2, value, isSVG) {
            if (isSVG) return "innerHTML" === key2 || "textContent" === key2 || !!(key2 in el && isNativeOn(key2) && isFunction$2(value));
            if ("spellcheck" === key2 || "draggable" === key2 || "translate" === key2) return !1;
            if ("form" === key2) return !1;
            if ("list" === key2 && "INPUT" === el.tagName) return !1;
            if ("type" === key2 && "TEXTAREA" === el.tagName) return !1;
            if ("width" === key2 || "height" === key2) {
                const tag = el.tagName;
                if ("IMG" === tag || "VIDEO" === tag || "CANVAS" === tag || "SOURCE" === tag) return !1;
            }
            return (!isNativeOn(key2) || !isString$1(value)) && key2 in el;
        }
        const positionMap = new WeakMap, newPositionMap = new WeakMap, moveCbKey = Symbol("_moveCb"), enterCbKey = Symbol("_enterCb"), TransitionGroupImpl = {
            name: "TransitionGroup",
            props: extend({}, TransitionPropsValidators, {
                tag: String,
                moveClass: String
            }),
            setup(props2, {slots: slots}) {
                const instance = getCurrentInstance(), state = useTransitionState();
                let prevChildren, children;
                return onUpdated((() => {
                    if (!prevChildren.length) return;
                    const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
                    if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) return;
                    prevChildren.forEach(callPendingCbs), prevChildren.forEach(recordPosition);
                    const movedChildren = prevChildren.filter(applyTranslation);
                    forceReflow(), movedChildren.forEach((c2 => {
                        const el = c2.el, style = el.style;
                        addTransitionClass(el, moveClass), style.transform = style.webkitTransform = style.transitionDuration = "";
                        const cb = el[moveCbKey] = e2 => {
                            e2 && e2.target !== el || e2 && !/transform$/.test(e2.propertyName) || (el.removeEventListener("transitionend", cb), 
                            el[moveCbKey] = null, removeTransitionClass(el, moveClass));
                        };
                        el.addEventListener("transitionend", cb);
                    }));
                })), () => {
                    const rawProps = toRaw(props2), cssTransitionProps = resolveTransitionProps(rawProps);
                    let tag = rawProps.tag || Fragment;
                    if (prevChildren = [], children) for (let i2 = 0; i2 < children.length; i2++) {
                        const child = children[i2];
                        child.el && child.el instanceof Element && (prevChildren.push(child), setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance)), 
                        positionMap.set(child, child.el.getBoundingClientRect()));
                    }
                    children = slots.default ? getTransitionRawChildren(slots.default()) : [];
                    for (let i2 = 0; i2 < children.length; i2++) {
                        const child = children[i2];
                        null != child.key && setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                    }
                    return createVNode(tag, null, children);
                };
            }
        };
        TransitionGroupImpl.props;
        const TransitionGroup = TransitionGroupImpl;
        function callPendingCbs(c2) {
            const el = c2.el;
            el[moveCbKey] && el[moveCbKey](), el[enterCbKey] && el[enterCbKey]();
        }
        function recordPosition(c2) {
            newPositionMap.set(c2, c2.el.getBoundingClientRect());
        }
        function applyTranslation(c2) {
            const oldPos = positionMap.get(c2), newPos = newPositionMap.get(c2), dx = oldPos.left - newPos.left, dy = oldPos.top - newPos.top;
            if (dx || dy) {
                const s2 = c2.el.style;
                return s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`, s2.transitionDuration = "0s", 
                c2;
            }
        }
        function hasCSSTransform(el, root2, moveClass) {
            const clone = el.cloneNode(), _vtc = el[vtcKey];
            _vtc && _vtc.forEach((cls => {
                cls.split(/\s+/).forEach((c2 => c2 && clone.classList.remove(c2)));
            })), moveClass.split(/\s+/).forEach((c2 => c2 && clone.classList.add(c2))), clone.style.display = "none";
            const container = 1 === root2.nodeType ? root2 : root2.parentNode;
            container.appendChild(clone);
            const {hasTransform: hasTransform} = getTransitionInfo(clone);
            return container.removeChild(clone), hasTransform;
        }
        const systemModifiers = [ "ctrl", "shift", "alt", "meta" ], modifierGuards = {
            stop: e2 => e2.stopPropagation(),
            prevent: e2 => e2.preventDefault(),
            self: e2 => e2.target !== e2.currentTarget,
            ctrl: e2 => !e2.ctrlKey,
            shift: e2 => !e2.shiftKey,
            alt: e2 => !e2.altKey,
            meta: e2 => !e2.metaKey,
            left: e2 => "button" in e2 && 0 !== e2.button,
            middle: e2 => "button" in e2 && 1 !== e2.button,
            right: e2 => "button" in e2 && 2 !== e2.button,
            exact: (e2, modifiers) => systemModifiers.some((m2 => e2[`${m2}Key`] && !modifiers.includes(m2)))
        }, withModifiers = (fn, modifiers) => {
            const cache = fn._withMods || (fn._withMods = {}), cacheKey = modifiers.join(".");
            return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
                for (let i2 = 0; i2 < modifiers.length; i2++) {
                    const guard = modifierGuards[modifiers[i2]];
                    if (guard && guard(event, modifiers)) return;
                }
                return fn(event, ...args);
            });
        }, rendererOptions = extend({
            patchProp: patchProp
        }, nodeOps);
        let renderer;
        function ensureRenderer() {
            return renderer || (renderer = createRenderer(rendererOptions));
        }
        const render = (...args) => {
            ensureRenderer().render(...args);
        }, createApp = (...args) => {
            const app = ensureRenderer().createApp(...args), {mount: mount} = app;
            return app.mount = containerOrSelector => {
                const container = normalizeContainer(containerOrSelector);
                if (!container) return;
                const component = app._component;
                isFunction$2(component) || component.render || component.template || (component.template = container.innerHTML), 
                container.innerHTML = "";
                const proxy = mount(container, !1, resolveRootNamespace(container));
                return container instanceof Element && (container.removeAttribute("v-cloak"), container.setAttribute("data-v-app", "")), 
                proxy;
            }, app;
        };
        function resolveRootNamespace(container) {
            return container instanceof SVGElement ? "svg" : "function" == typeof MathMLElement && container instanceof MathMLElement ? "mathml" : void 0;
        }
        function normalizeContainer(container) {
            if (isString$1(container)) {
                return document.querySelector(container);
            }
            return container;
        }
        var freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$g = Object.prototype, hasOwnProperty$e = objectProto$g.hasOwnProperty, nativeObjectToString$1 = objectProto$g.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function getRawTag(value) {
            var isOwn = hasOwnProperty$e.call(value, symToStringTag$1), tag = value[symToStringTag$1];
            try {
                value[symToStringTag$1] = void 0;
                var unmasked = !0;
            } catch (e2) {}
            var result = nativeObjectToString$1.call(value);
            return unmasked && (isOwn ? value[symToStringTag$1] = tag : delete value[symToStringTag$1]), 
            result;
        }
        var nativeObjectToString = Object.prototype.toString;
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function baseGetTag(value) {
            return null == value ? void 0 === value ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        function isObjectLike(value) {
            return null != value && "object" == typeof value;
        }
        var symbolTag$3 = "[object Symbol]";
        function isSymbol(value) {
            return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
        }
        function arrayMap(array, iteratee) {
            for (var index2 = -1, length2 = null == array ? 0 : array.length, result = Array(length2); ++index2 < length2; ) result[index2] = iteratee(array[index2], index2, array);
            return result;
        }
        var isArray$1 = Array.isArray, INFINITY$2 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
        function baseToString(value) {
            if ("string" == typeof value) return value;
            if (isArray$1(value)) return arrayMap(value, baseToString) + "";
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY$2 ? "-0" : result;
        }
        var reWhitespace = /\s/;
        function trimmedEndIndex(string2) {
            for (var index2 = string2.length; index2-- && reWhitespace.test(string2.charAt(index2)); ) ;
            return index2;
        }
        var reTrimStart = /^\s+/;
        function baseTrim(string2) {
            return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
        }
        function isObject$2(value) {
            var type = typeof value;
            return null != value && ("object" == type || "function" == type);
        }
        var NAN = NaN, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
        function toNumber(value) {
            if ("number" == typeof value) return value;
            if (isSymbol(value)) return NAN;
            if (isObject$2(value)) {
                var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                value = isObject$2(other) ? other + "" : other;
            }
            if ("string" != typeof value) return 0 === value ? value : +value;
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
        function toFinite(value) {
            return value ? (value = toNumber(value)) === INFINITY$1 || value === -INFINITY$1 ? (value < 0 ? -1 : 1) * MAX_INTEGER : value == value ? value : 0 : 0 === value ? value : 0;
        }
        function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result == result ? remainder ? result - remainder : result : 0;
        }
        function identity(value) {
            return value;
        }
        var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
        function isFunction$1(value) {
            if (!isObject$2(value)) return !1;
            var tag = baseGetTag(value);
            return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
        }
        var uid2, coreJsData = root["__core-js_shared__"], maskSrcKey = (uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid2 : "";
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        var funcToString$2 = Function.prototype.toString;
        function toSource(func) {
            if (null != func) {
                try {
                    return funcToString$2.call(func);
                } catch (e2) {}
                try {
                    return func + "";
                } catch (e2) {}
            }
            return "";
        }
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$e = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$d = objectProto$e.hasOwnProperty, reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        function baseIsNative(value) {
            return !(!isObject$2(value) || isMasked(value)) && (isFunction$1(value) ? reIsNative : reIsHostCtor).test(toSource(value));
        }
        function getValue$3(object, key2) {
            return null == object ? void 0 : object[key2];
        }
        function getNative(object, key2) {
            var value = getValue$3(object, key2);
            return baseIsNative(value) ? value : void 0;
        }
        var WeakMap$1 = getNative(root, "WeakMap"), objectCreate = Object.create, baseCreate = function() {
            function object() {}
            return function(proto) {
                if (!isObject$2(proto)) return {};
                if (objectCreate) return objectCreate(proto);
                object.prototype = proto;
                var result = new object;
                return object.prototype = void 0, result;
            };
        }();
        function apply(func, thisArg, args) {
            switch (args.length) {
              case 0:
                return func.call(thisArg);

              case 1:
                return func.call(thisArg, args[0]);

              case 2:
                return func.call(thisArg, args[0], args[1]);

              case 3:
                return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
        }
        function copyArray(source, array) {
            var index2 = -1, length2 = source.length;
            for (array || (array = Array(length2)); ++index2 < length2; ) array[index2] = source[index2];
            return array;
        }
        var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                if (lastCalled = stamp, remaining > 0) {
                    if (++count >= HOT_COUNT) return arguments[0];
                } else count = 0;
                return func.apply(void 0, arguments);
            };
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        var defineProperty = function() {
            try {
                var func = getNative(Object, "defineProperty");
                return func({}, "", {}), func;
            } catch (e2) {}
        }(), setToString = shortOut(defineProperty ? function(func, string2) {
            return defineProperty(func, "toString", {
                configurable: !0,
                enumerable: !1,
                value: constant(string2),
                writable: !0
            });
        } : identity);
        function arrayEach(array, iteratee) {
            for (var index2 = -1, length2 = null == array ? 0 : array.length; ++index2 < length2 && !1 !== iteratee(array[index2], index2, array); ) ;
            return array;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
            for (var length2 = array.length, index2 = fromIndex + -1; ++index2 < length2; ) if (predicate(array[index2], index2, array)) return index2;
            return -1;
        }
        function baseIsNaN(value) {
            return value != value;
        }
        function strictIndexOf(array, value, fromIndex) {
            for (var index2 = fromIndex - 1, length2 = array.length; ++index2 < length2; ) if (array[index2] === value) return index2;
            return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
            return value == value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function arrayIncludes(array, value) {
            return !!(null == array ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
        }
        var MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length2) {
            var type = typeof value;
            return !!(length2 = null == length2 ? MAX_SAFE_INTEGER$1 : length2) && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length2;
        }
        function baseAssignValue(object, key2, value) {
            "__proto__" == key2 && defineProperty ? defineProperty(object, key2, {
                configurable: !0,
                enumerable: !0,
                value: value,
                writable: !0
            }) : object[key2] = value;
        }
        function eq(value, other) {
            return value === other || value != value && other != other;
        }
        var hasOwnProperty$c = Object.prototype.hasOwnProperty;
        function assignValue(object, key2, value) {
            var objValue = object[key2];
            hasOwnProperty$c.call(object, key2) && eq(objValue, value) && (void 0 !== value || key2 in object) || baseAssignValue(object, key2, value);
        }
        function copyObject(source, props2, object, customizer) {
            var isNew = !object;
            object || (object = {});
            for (var index2 = -1, length2 = props2.length; ++index2 < length2; ) {
                var key2 = props2[index2], newValue = void 0;
                void 0 === newValue && (newValue = source[key2]), isNew ? baseAssignValue(object, key2, newValue) : assignValue(object, key2, newValue);
            }
            return object;
        }
        var nativeMax$2 = Math.max;
        function overRest(func, start, transform) {
            return start = nativeMax$2(void 0 === start ? func.length - 1 : start, 0), function() {
                for (var args = arguments, index2 = -1, length2 = nativeMax$2(args.length - start, 0), array = Array(length2); ++index2 < length2; ) array[index2] = args[start + index2];
                index2 = -1;
                for (var otherArgs = Array(start + 1); ++index2 < start; ) otherArgs[index2] = args[index2];
                return otherArgs[start] = transform(array), apply(func, this, otherArgs);
            };
        }
        function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
        }
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
            return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isArrayLike(value) {
            return null != value && isLength(value.length) && !isFunction$1(value);
        }
        var objectProto$c = Object.prototype;
        function isPrototype(value) {
            var Ctor = value && value.constructor;
            return value === ("function" == typeof Ctor && Ctor.prototype || objectProto$c);
        }
        function baseTimes(n2, iteratee) {
            for (var index2 = -1, result = Array(n2); ++index2 < n2; ) result[index2] = iteratee(index2);
            return result;
        }
        var argsTag$3 = "[object Arguments]";
        function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag$3;
        }
        var objectProto$b = Object.prototype, hasOwnProperty$b = objectProto$b.hasOwnProperty, propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable, isArguments = baseIsArguments(function() {
            return arguments;
        }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty$b.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
        };
        function stubFalse() {
            return !1;
        }
        var freeExports$2 = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && "object" == typeof module && module && !module.nodeType && module, Buffer$1 = freeModule$2 && freeModule$2.exports === freeExports$2 ? root.Buffer : void 0, isBuffer = (Buffer$1 ? Buffer$1.isBuffer : void 0) || stubFalse, argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
        function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseUnary(func) {
            return function(value) {
                return func(value);
            };
        }
        typedArrayTags["[object Float32Array]"] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0, 
        typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = !1;
        var freeExports$1 = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && "object" == typeof module && module && !module.nodeType && module, freeProcess = freeModule$1 && freeModule$1.exports === freeExports$1 && freeGlobal.process, nodeUtil = function() {
            try {
                var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
                return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
            } catch (e2) {}
        }(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, hasOwnProperty$a = Object.prototype.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
            var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
            for (var key2 in value) !inherited && !hasOwnProperty$a.call(value, key2) || skipIndexes && ("length" == key2 || isBuff && ("offset" == key2 || "parent" == key2) || isType && ("buffer" == key2 || "byteLength" == key2 || "byteOffset" == key2) || isIndex(key2, length2)) || result.push(key2);
            return result;
        }
        function overArg(func, transform) {
            return function(arg) {
                return func(transform(arg));
            };
        }
        var nativeKeys = overArg(Object.keys, Object), hasOwnProperty$9 = Object.prototype.hasOwnProperty;
        function baseKeys(object) {
            if (!isPrototype(object)) return nativeKeys(object);
            var result = [];
            for (var key2 in Object(object)) hasOwnProperty$9.call(object, key2) && "constructor" != key2 && result.push(key2);
            return result;
        }
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function nativeKeysIn(object) {
            var result = [];
            if (null != object) for (var key2 in Object(object)) result.push(key2);
            return result;
        }
        var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
        function baseKeysIn(object) {
            if (!isObject$2(object)) return nativeKeysIn(object);
            var isProto = isPrototype(object), result = [];
            for (var key2 in object) ("constructor" != key2 || !isProto && hasOwnProperty$8.call(object, key2)) && result.push(key2);
            return result;
        }
        function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
        }
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
        function isKey(value, object) {
            if (isArray$1(value)) return !1;
            var type = typeof value;
            return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || (reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object));
        }
        var nativeCreate = getNative(Object, "create");
        function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
        }
        function hashDelete(key2) {
            var result = this.has(key2) && delete this.__data__[key2];
            return this.size -= result ? 1 : 0, result;
        }
        var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", hasOwnProperty$7 = Object.prototype.hasOwnProperty;
        function hashGet(key2) {
            var data = this.__data__;
            if (nativeCreate) {
                var result = data[key2];
                return result === HASH_UNDEFINED$2 ? void 0 : result;
            }
            return hasOwnProperty$7.call(data, key2) ? data[key2] : void 0;
        }
        var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
        function hashHas(key2) {
            var data = this.__data__;
            return nativeCreate ? void 0 !== data[key2] : hasOwnProperty$6.call(data, key2);
        }
        var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
        function hashSet(key2, value) {
            var data = this.__data__;
            return this.size += this.has(key2) ? 0 : 1, data[key2] = nativeCreate && void 0 === value ? HASH_UNDEFINED$1 : value, 
            this;
        }
        function Hash(entries) {
            var index2 = -1, length2 = null == entries ? 0 : entries.length;
            for (this.clear(); ++index2 < length2; ) {
                var entry = entries[index2];
                this.set(entry[0], entry[1]);
            }
        }
        function listCacheClear() {
            this.__data__ = [], this.size = 0;
        }
        function assocIndexOf(array, key2) {
            for (var length2 = array.length; length2--; ) if (eq(array[length2][0], key2)) return length2;
            return -1;
        }
        Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, 
        Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;
        var splice = Array.prototype.splice;
        function listCacheDelete(key2) {
            var data = this.__data__, index2 = assocIndexOf(data, key2);
            return !(index2 < 0) && (index2 == data.length - 1 ? data.pop() : splice.call(data, index2, 1), 
            --this.size, !0);
        }
        function listCacheGet(key2) {
            var data = this.__data__, index2 = assocIndexOf(data, key2);
            return index2 < 0 ? void 0 : data[index2][1];
        }
        function listCacheHas(key2) {
            return assocIndexOf(this.__data__, key2) > -1;
        }
        function listCacheSet(key2, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key2);
            return index2 < 0 ? (++this.size, data.push([ key2, value ])) : data[index2][1] = value, 
            this;
        }
        function ListCache(entries) {
            var index2 = -1, length2 = null == entries ? 0 : entries.length;
            for (this.clear(); ++index2 < length2; ) {
                var entry = entries[index2];
                this.set(entry[0], entry[1]);
            }
        }
        ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, 
        ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, 
        ListCache.prototype.set = listCacheSet;
        var Map$1 = getNative(root, "Map");
        function mapCacheClear() {
            this.size = 0, this.__data__ = {
                hash: new Hash,
                map: new (Map$1 || ListCache),
                string: new Hash
            };
        }
        function isKeyable(value) {
            var type = typeof value;
            return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
        }
        function getMapData(map, key2) {
            var data = map.__data__;
            return isKeyable(key2) ? data["string" == typeof key2 ? "string" : "hash"] : data.map;
        }
        function mapCacheDelete(key2) {
            var result = getMapData(this, key2).delete(key2);
            return this.size -= result ? 1 : 0, result;
        }
        function mapCacheGet(key2) {
            return getMapData(this, key2).get(key2);
        }
        function mapCacheHas(key2) {
            return getMapData(this, key2).has(key2);
        }
        function mapCacheSet(key2, value) {
            var data = getMapData(this, key2), size2 = data.size;
            return data.set(key2, value), this.size += data.size == size2 ? 0 : 1, this;
        }
        function MapCache(entries) {
            var index2 = -1, length2 = null == entries ? 0 : entries.length;
            for (this.clear(); ++index2 < length2; ) {
                var entry = entries[index2];
                this.set(entry[0], entry[1]);
            }
        }
        MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, 
        MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
        var FUNC_ERROR_TEXT$1 = "Expected a function";
        function memoize(func, resolver) {
            if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT$1);
            var memoized = function() {
                var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                if (cache.has(key2)) return cache.get(key2);
                var result = func.apply(this, args);
                return memoized.cache = cache.set(key2, result) || cache, result;
            };
            return memoized.cache = new (memoize.Cache || MapCache), memoized;
        }
        memoize.Cache = MapCache;
        var MAX_MEMOIZE_SIZE = 500;
        function memoizeCapped(func) {
            var result = memoize(func, (function(key2) {
                return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key2;
            })), cache = result.cache;
            return result;
        }
        var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped((function(string2) {
            var result = [];
            return 46 === string2.charCodeAt(0) && result.push(""), string2.replace(rePropName, (function(match2, number, quote, subString) {
                result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
            })), result;
        }));
        function toString(value) {
            return null == value ? "" : baseToString(value);
        }
        function castPath(value, object) {
            return isArray$1(value) ? value : isKey(value, object) ? [ value ] : stringToPath(toString(value));
        }
        var INFINITY = 1 / 0;
        function toKey(value) {
            if ("string" == typeof value || isSymbol(value)) return value;
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseGet(object, path) {
            for (var index2 = 0, length2 = (path = castPath(path, object)).length; null != object && index2 < length2; ) object = object[toKey(path[index2++])];
            return index2 && index2 == length2 ? object : void 0;
        }
        function get$1(object, path, defaultValue) {
            var result = null == object ? void 0 : baseGet(object, path);
            return void 0 === result ? defaultValue : result;
        }
        function arrayPush(array, values) {
            for (var index2 = -1, length2 = values.length, offset = array.length; ++index2 < length2; ) array[offset + index2] = values[index2];
            return array;
        }
        var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
        function isFlattenable(value) {
            return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function baseFlatten(array, depth, predicate, isStrict, result) {
            var index2 = -1, length2 = array.length;
            for (predicate || (predicate = isFlattenable), result || (result = []); ++index2 < length2; ) {
                var value = array[index2];
                predicate(value) ? arrayPush(result, value) : result[result.length] = value;
            }
            return result;
        }
        function flatten(array) {
            return (null == array ? 0 : array.length) ? baseFlatten(array) : [];
        }
        function flatRest(func) {
            return setToString(overRest(func, void 0, flatten), func + "");
        }
        var getPrototype = overArg(Object.getPrototypeOf, Object), objectTag$3 = "[object Object]", funcProto = Function.prototype, objectProto$5 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$5 = objectProto$5.hasOwnProperty, objectCtorString = funcToString.call(Object);
        function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) return !1;
            var proto = getPrototype(value);
            if (null === proto) return !0;
            var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
            return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        function baseSlice(array, start, end) {
            var index2 = -1, length2 = array.length;
            start < 0 && (start = -start > length2 ? 0 : length2 + start), (end = end > length2 ? length2 : end) < 0 && (end += length2), 
            length2 = start > end ? 0 : end - start >>> 0, start >>>= 0;
            for (var result = Array(length2); ++index2 < length2; ) result[index2] = array[index2 + start];
            return result;
        }
        function stackClear() {
            this.__data__ = new ListCache, this.size = 0;
        }
        function stackDelete(key2) {
            var data = this.__data__, result = data.delete(key2);
            return this.size = data.size, result;
        }
        function stackGet(key2) {
            return this.__data__.get(key2);
        }
        function stackHas(key2) {
            return this.__data__.has(key2);
        }
        var LARGE_ARRAY_SIZE = 200;
        function stackSet(key2, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
                var pairs = data.__data__;
                if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([ key2, value ]), 
                this.size = ++data.size, this;
                data = this.__data__ = new MapCache(pairs);
            }
            return data.set(key2, value), this.size = data.size, this;
        }
        function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
        }
        function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
        }
        Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, 
        Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
        var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, Buffer2 = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
        function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
            return buffer.copy(result), result;
        }
        function arrayFilter(array, predicate) {
            for (var index2 = -1, length2 = null == array ? 0 : array.length, resIndex = 0, result = []; ++index2 < length2; ) {
                var value = array[index2];
                predicate(value, index2, array) && (result[resIndex++] = value);
            }
            return result;
        }
        function stubArray() {
            return [];
        }
        var propertyIsEnumerable = Object.prototype.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(object) {
            return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols$1(object), (function(symbol) {
                return propertyIsEnumerable.call(object, symbol);
            })));
        } : stubArray;
        function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
        }
        var getSymbolsIn = Object.getOwnPropertySymbols ? function(object) {
            for (var result = []; object; ) arrayPush(result, getSymbols(object)), object = getPrototype(object);
            return result;
        } : stubArray;
        function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var DataView = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$5 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$5 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag = baseGetTag;
        (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1) != mapTag$5 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1) != setTag$5 || WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1) && (getTag = function(value) {
            var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$3;

              case mapCtorString:
                return mapTag$5;

              case promiseCtorString:
                return promiseTag;

              case setCtorString:
                return setTag$5;

              case weakMapCtorString:
                return weakMapTag$1;
            }
            return result;
        });
        var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
        function initCloneArray(array) {
            var length2 = array.length, result = new array.constructor(length2);
            return length2 && "string" == typeof array[0] && hasOwnProperty$4.call(array, "index") && (result.index = array.index, 
            result.input = array.input), result;
        }
        var Uint8Array2 = root.Uint8Array;
        function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            return new Uint8Array2(result).set(new Uint8Array2(arrayBuffer)), result;
        }
        function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        var reFlags = /\w*$/;
        function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            return result.lastIndex = regexp.lastIndex, result;
        }
        var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
        function cloneSymbol(symbol) {
            return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag$2:
                return cloneArrayBuffer(object);

              case boolTag$2:
              case dateTag$2:
                return new Ctor(+object);

              case dataViewTag$2:
                return cloneDataView(object, isDeep);

              case float32Tag$1:
              case float64Tag$1:
              case int8Tag$1:
              case int16Tag$1:
              case int32Tag$1:
              case uint8Tag$1:
              case uint8ClampedTag$1:
              case uint16Tag$1:
              case uint32Tag$1:
                return cloneTypedArray(object, isDeep);

              case mapTag$4:
                return new Ctor;

              case numberTag$2:
              case stringTag$2:
                return new Ctor(object);

              case regexpTag$2:
                return cloneRegExp(object);

              case setTag$4:
                return new Ctor;

              case symbolTag$2:
                return cloneSymbol(object);
            }
        }
        function initCloneObject(object) {
            return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
        }
        var mapTag$3 = "[object Map]";
        function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag$3;
        }
        var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$3 = "[object Set]";
        function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag$3;
        }
        var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
        function baseClone(value, bitmask, customizer, key2, object, stack2) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
            if (customizer && (result = object ? customizer(value, key2, object, stack2) : customizer(value)), 
            void 0 !== result) return result;
            if (!isObject$2(value)) return value;
            var isArr = isArray$1(value);
            if (isArr) {
                if (result = initCloneArray(value), !isDeep) return copyArray(value, result);
            } else {
                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                if (isBuffer(value)) return cloneBuffer(value, isDeep);
                if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
                    if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                } else {
                    if (!cloneableTags[tag]) return object ? value : {};
                    result = initCloneByTag(value, tag, isDeep);
                }
            }
            stack2 || (stack2 = new Stack);
            var stacked = stack2.get(value);
            if (stacked) return stacked;
            stack2.set(value, result), isSet(value) ? value.forEach((function(subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
            })) : isMap(value) && value.forEach((function(subValue, key3) {
                result.set(key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
            }));
            var props2 = isArr ? void 0 : (isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys)(value);
            return arrayEach(props2 || value, (function(subValue, key3) {
                props2 && (subValue = value[key3 = subValue]), assignValue(result, key3, baseClone(subValue, bitmask, customizer, key3, value, stack2));
            })), result;
        }
        cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, 
        cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
        var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
        function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
        }
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        function setCacheAdd(value) {
            return this.__data__.set(value, HASH_UNDEFINED), this;
        }
        function setCacheHas(value) {
            return this.__data__.has(value);
        }
        function SetCache(values) {
            var index2 = -1, length2 = null == values ? 0 : values.length;
            for (this.__data__ = new MapCache; ++index2 < length2; ) this.add(values[index2]);
        }
        function arraySome(array, predicate) {
            for (var index2 = -1, length2 = null == array ? 0 : array.length; ++index2 < length2; ) if (predicate(array[index2], index2, array)) return !0;
            return !1;
        }
        function cacheHas(cache, key2) {
            return cache.has(key2);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas;
        var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
            var arrStacked = stack2.get(array), othStacked = stack2.get(other);
            if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
            var index2 = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache : void 0;
            for (stack2.set(array, other), stack2.set(other, array); ++index2 < arrLength; ) {
                var arrValue = array[index2], othValue = other[index2];
                if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
                if (void 0 !== compared) {
                    if (compared) continue;
                    result = !1;
                    break;
                }
                if (seen) {
                    if (!arraySome(other, (function(othValue2, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) return seen.push(othIndex);
                    }))) {
                        result = !1;
                        break;
                    }
                } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack2)) {
                    result = !1;
                    break;
                }
            }
            return stack2.delete(array), stack2.delete(other), result;
        }
        function mapToArray(map) {
            var index2 = -1, result = Array(map.size);
            return map.forEach((function(value, key2) {
                result[++index2] = [ key2, value ];
            })), result;
        }
        function setToArray(set2) {
            var index2 = -1, result = Array(set2.size);
            return set2.forEach((function(value) {
                result[++index2] = value;
            })), result;
        }
        var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                object = object.buffer, other = other.buffer;

              case arrayBufferTag:
                return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other)));

              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);

              case errorTag:
                return object.name == other.name && object.message == other.message;

              case regexpTag:
              case stringTag:
                return object == other + "";

              case mapTag$1:
                var convert = mapToArray;

              case setTag$1:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
                if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                var stacked = stack2.get(object);
                if (stacked) return stacked == other;
                bitmask |= COMPARE_UNORDERED_FLAG$2, stack2.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
                return stack2.delete(object), result;

              case symbolTag:
                if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
            return !1;
        }
        var COMPARE_PARTIAL_FLAG$3 = 1, hasOwnProperty$3 = Object.prototype.hasOwnProperty;
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length;
            if (objLength != getAllKeys(other).length && !isPartial) return !1;
            for (var index2 = objLength; index2--; ) {
                var key2 = objProps[index2];
                if (!(isPartial ? key2 in other : hasOwnProperty$3.call(other, key2))) return !1;
            }
            var objStacked = stack2.get(object), othStacked = stack2.get(other);
            if (objStacked && othStacked) return objStacked == other && othStacked == object;
            var result = !0;
            stack2.set(object, other), stack2.set(other, object);
            for (var skipCtor = isPartial; ++index2 < objLength; ) {
                var objValue = object[key2 = objProps[index2]], othValue = other[key2];
                if (customizer) var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
                if (!(void 0 === compared ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                    result = !1;
                    break;
                }
                skipCtor || (skipCtor = "constructor" == key2);
            }
            if (result && !skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                objCtor == othCtor || !("constructor" in object) || !("constructor" in other) || "function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor || (result = !1);
            }
            return stack2.delete(object), stack2.delete(other), result;
        }
        var COMPARE_PARTIAL_FLAG$2 = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
            var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other), objIsObj = (objTag = objTag == argsTag ? objectTag : objTag) == objectTag, othIsObj = (othTag = othTag == argsTag ? objectTag : othTag) == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
                if (!isBuffer(other)) return !1;
                objIsArr = !0, objIsObj = !1;
            }
            if (isSameTag && !objIsObj) return stack2 || (stack2 = new Stack), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
            if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
                var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
                if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    return stack2 || (stack2 = new Stack), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
                }
            }
            return !!isSameTag && (stack2 || (stack2 = new Stack), equalObjects(object, other, bitmask, customizer, equalFunc, stack2));
        }
        function baseIsEqual(value, other, bitmask, customizer, stack2) {
            return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value != value && other != other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2));
        }
        var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
        function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length2 = index2;
            if (null == object) return !length2;
            for (object = Object(object); index2--; ) {
                var data = matchData[index2];
                if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1;
            }
            for (;++index2 < length2; ) {
                var key2 = (data = matchData[index2])[0], objValue = object[key2], srcValue = data[1];
                if (data[2]) {
                    if (void 0 === objValue && !(key2 in object)) return !1;
                } else {
                    var result, stack2 = new Stack;
                    if (!(void 0 === result ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) return !1;
                }
            }
            return !0;
        }
        function isStrictComparable(value) {
            return value == value && !isObject$2(value);
        }
        function getMatchData(object) {
            for (var result = keys(object), length2 = result.length; length2--; ) {
                var key2 = result[length2], value = object[key2];
                result[length2] = [ key2, value, isStrictComparable(value) ];
            }
            return result;
        }
        function matchesStrictComparable(key2, srcValue) {
            return function(object) {
                return null != object && (object[key2] === srcValue && (void 0 !== srcValue || key2 in Object(object)));
            };
        }
        function baseMatches(source) {
            var matchData = getMatchData(source);
            return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
                return object === source || baseIsMatch(object, source, matchData);
            };
        }
        function baseHasIn(object, key2) {
            return null != object && key2 in Object(object);
        }
        function hasPath(object, path, hasFunc) {
            for (var index2 = -1, length2 = (path = castPath(path, object)).length, result = !1; ++index2 < length2; ) {
                var key2 = toKey(path[index2]);
                if (!(result = null != object && hasFunc(object, key2))) break;
                object = object[key2];
            }
            return result || ++index2 != length2 ? result : !!(length2 = null == object ? 0 : object.length) && isLength(length2) && isIndex(key2, length2) && (isArray$1(object) || isArguments(object));
        }
        function hasIn(object, path) {
            return null != object && hasPath(object, path, baseHasIn);
        }
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        function baseMatchesProperty(path, srcValue) {
            return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
                var objValue = get$1(object, path);
                return void 0 === objValue && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
        }
        function baseProperty(key2) {
            return function(object) {
                return null == object ? void 0 : object[key2];
            };
        }
        function basePropertyDeep(path) {
            return function(object) {
                return baseGet(object, path);
            };
        }
        function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function baseIteratee(value) {
            return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
        }
        var now$2 = function() {
            return root.Date.now();
        }, FUNC_ERROR_TEXT = "Expected a function", nativeMax$1 = Math.max, nativeMin$1 = Math.min;
        function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
            }
            function leadingEdge(time) {
                return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeWaiting = wait - (time - lastCallTime);
                return maxing ? nativeMin$1(timeWaiting, maxWait - (time - lastInvokeTime)) : timeWaiting;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime;
                return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
            }
            function timerExpired() {
                var time = now$2();
                if (shouldInvoke(time)) return trailingEdge(time);
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
                result);
            }
            function cancel() {
                void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
            }
            function flush() {
                return void 0 === timerId ? result : trailingEdge(now$2());
            }
            function debounced() {
                var time = now$2(), isInvoking = shouldInvoke(time);
                if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                    if (void 0 === timerId) return leadingEdge(lastCallTime);
                    if (maxing) return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait), 
                    invokeFunc(lastCallTime);
                }
                return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
            }
            return wait = toNumber(wait) || 0, isObject$2(options) && (leading = !!options.leading, 
            maxWait = (maxing = "maxWait" in options) ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait, 
            trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
            debounced.flush = flush, debounced;
        }
        function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
        }
        function last(array) {
            var length2 = null == array ? 0 : array.length;
            return length2 ? array[length2 - 1] : void 0;
        }
        function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
                var iterable = Object(collection);
                if (!isArrayLike(collection)) {
                    var iteratee = baseIteratee(predicate);
                    collection = keys(collection), predicate = function(key2) {
                        return iteratee(iterable[key2], key2, iterable);
                    };
                }
                var index2 = findIndexFunc(collection, predicate, fromIndex);
                return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
            };
        }
        var nativeMax = Math.max;
        function findIndex(array, predicate, fromIndex) {
            var length2 = null == array ? 0 : array.length;
            if (!length2) return -1;
            var index2 = null == fromIndex ? 0 : toInteger(fromIndex);
            return index2 < 0 && (index2 = nativeMax(length2 + index2, 0)), baseFindIndex(array, baseIteratee(predicate), index2);
        }
        var find = createFind(findIndex), nativeMin = Math.min;
        function baseIntersection(arrays, iteratee, comparator2) {
            for (var includes2 = arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--; ) {
                var array = arrays[othIndex];
                othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength), 
                caches[othIndex] = length2 >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : void 0;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer: for (;++index2 < length2 && result.length < maxLength; ) {
                var value = array[index2], computed2 = value;
                if (value = 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed2) : includes2(result, computed2))) {
                    for (othIndex = othLength; --othIndex; ) {
                        var cache = caches[othIndex];
                        if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2))) continue outer;
                    }
                    seen && seen.push(computed2), result.push(value);
                }
            }
            return result;
        }
        function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
        }
        var intersection = baseRest((function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        }));
        function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        var mapTag = "[object Map]", setTag = "[object Set]", hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function isEmpty(value) {
            if (null == value) return !0;
            if (isArrayLike(value) && (isArray$1(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) return !value.size;
            if (isPrototype(value)) return !baseKeys(value).length;
            for (var key2 in value) if (hasOwnProperty$1.call(value, key2)) return !1;
            return !0;
        }
        function isEqual(value, other) {
            return baseIsEqual(value, other);
        }
        function baseUnset(object, path) {
            return null == (object = parent(object, path = castPath(path, object))) || delete object[toKey(last(path))];
        }
        function customOmitClone(value) {
            return isPlainObject(value) ? void 0 : value;
        }
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit$1 = flatRest((function(object, paths) {
            var result = {};
            if (null == object) return result;
            var isDeep = !1;
            paths = arrayMap(paths, (function(path) {
                return path = castPath(path, object), isDeep || (isDeep = path.length > 1), path;
            })), copyObject(object, getAllKeysIn(object), result), isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
            for (var length2 = paths.length; length2--; ) baseUnset(result, paths[length2]);
            return result;
        }));
        function _typeof$1(o2) {
            return (_typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
                return typeof o3;
            } : function(o3) {
                return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
            })(o2);
        }
        function toPrimitive(t2, r2) {
            if ("object" != _typeof$1(t2) || !t2) return t2;
            var e2 = t2[Symbol.toPrimitive];
            if (void 0 !== e2) {
                var i2 = e2.call(t2, r2 || "default");
                if ("object" != _typeof$1(i2)) return i2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === r2 ? String : Number)(t2);
        }
        function toPropertyKey(t2) {
            var i2 = toPrimitive(t2, "string");
            return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
        }
        function _defineProperty$l(e2, r2, t2) {
            return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
                value: t2,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e2[r2] = t2, e2;
        }
        function ownKeys$1(e2, r2) {
            var t2 = Object.keys(e2);
            if (Object.getOwnPropertySymbols) {
                var o2 = Object.getOwnPropertySymbols(e2);
                r2 && (o2 = o2.filter((function(r3) {
                    return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
                }))), t2.push.apply(t2, o2);
            }
            return t2;
        }
        function _objectSpread2$1(e2) {
            for (var r2 = 1; r2 < arguments.length; r2++) {
                var t2 = null != arguments[r2] ? arguments[r2] : {};
                r2 % 2 ? ownKeys$1(Object(t2), !0).forEach((function(r3) {
                    _defineProperty$l(e2, r3, t2[r3]);
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach((function(r3) {
                    Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
                }));
            }
            return e2;
        }
        function _extends$1() {
            return _extends$1 = Object.assign ? Object.assign.bind() : function(n2) {
                for (var e2 = 1; e2 < arguments.length; e2++) {
                    var t2 = arguments[e2];
                    for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
                }
                return n2;
            }, _extends$1.apply(null, arguments);
        }
        const isFunction = val => "function" == typeof val, isArray = Array.isArray, isString = val => "string" == typeof val, isObject$1 = val => null !== val && "object" == typeof val, onRE = /^on[^a-z]/, isOn = key2 => onRE.test(key2), cacheStringFunction = fn => {
            const cache = Object.create(null);
            return str => cache[str] || (cache[str] = fn(str));
        }, camelizeRE = /-(\w)/g, camelize = cacheStringFunction((str => str.replace(camelizeRE, ((_2, c2) => c2 ? c2.toUpperCase() : "")))), hyphenateRE = /\B([A-Z])/g, hyphenate = cacheStringFunction((str => str.replace(hyphenateRE, "-$1").toLowerCase())), capitalize = cacheStringFunction((str => str.charAt(0).toUpperCase() + str.slice(1))), hasOwnProperty = Object.prototype.hasOwnProperty, hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
        function resolvePropValue(options, props2, key2, value) {
            const opt = options[key2];
            if (null != opt) {
                const hasDefault = hasOwn(opt, "default");
                if (hasDefault && void 0 === value) {
                    const defaultValue = opt.default;
                    value = opt.type !== Function && isFunction(defaultValue) ? defaultValue() : defaultValue;
                }
                opt.type === Boolean && (hasOwn(props2, key2) || hasDefault ? "" === value && (value = !0) : value = !1);
            }
            return value;
        }
        function renderHelper(v2) {
            let defaultV = arguments.length > 2 ? arguments[2] : void 0;
            return "function" == typeof v2 ? v2(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}) : null != v2 ? v2 : defaultV;
        }
        function wrapPromiseFn(openFn) {
            let closeFn;
            const closePromise = new Promise((resolve2 => {
                closeFn = openFn((() => {
                    resolve2(!0);
                }));
            })), result = () => {
                null == closeFn || closeFn();
            };
            return result.then = (filled, rejected) => closePromise.then(filled, rejected), 
            result.promise = closePromise, result;
        }
        function classNames() {
            const classes = [];
            for (let i2 = 0; i2 < arguments.length; i2++) {
                const value = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
                if (value) if (isString(value)) classes.push(value); else if (isArray(value)) for (let i3 = 0; i3 < value.length; i3++) {
                    const inner = classNames(value[i3]);
                    inner && classes.push(inner);
                } else if (isObject$1(value)) for (const name in value) value[name] && classes.push(name);
            }
            return classes.join(" ");
        }
        var MapShim = function() {
            if ("undefined" != typeof Map) return Map;
            function getIndex(arr, key2) {
                var result = -1;
                return arr.some((function(entry, index2) {
                    return entry[0] === key2 && (result = index2, !0);
                })), result;
            }
            return function() {
                function class_1() {
                    this.__entries__ = [];
                }
                return Object.defineProperty(class_1.prototype, "size", {
                    get: function() {
                        return this.__entries__.length;
                    },
                    enumerable: !0,
                    configurable: !0
                }), class_1.prototype.get = function(key2) {
                    var index2 = getIndex(this.__entries__, key2), entry = this.__entries__[index2];
                    return entry && entry[1];
                }, class_1.prototype.set = function(key2, value) {
                    var index2 = getIndex(this.__entries__, key2);
                    ~index2 ? this.__entries__[index2][1] = value : this.__entries__.push([ key2, value ]);
                }, class_1.prototype.delete = function(key2) {
                    var entries = this.__entries__, index2 = getIndex(entries, key2);
                    ~index2 && entries.splice(index2, 1);
                }, class_1.prototype.has = function(key2) {
                    return !!~getIndex(this.__entries__, key2);
                }, class_1.prototype.clear = function() {
                    this.__entries__.splice(0);
                }, class_1.prototype.forEach = function(callback, ctx) {
                    void 0 === ctx && (ctx = null);
                    for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                        var entry = _a[_i];
                        callback.call(ctx, entry[1], entry[0]);
                    }
                }, class_1;
            }();
        }(), isBrowser = "undefined" != typeof window && "undefined" != typeof document && window.document === document, global$1 = "undefined" != typeof global && global.Math === Math ? global : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")(), requestAnimationFrame$1 = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(global$1) : function(callback) {
            return setTimeout((function() {
                return callback(Date.now());
            }), 1e3 / 60);
        }, trailingTimeout = 2;
        function throttle(callback, delay) {
            var leadingCall = !1, trailingCall = !1, lastCallTime = 0;
            function resolvePending() {
                leadingCall && (leadingCall = !1, callback()), trailingCall && proxy();
            }
            function timeoutCallback() {
                requestAnimationFrame$1(resolvePending);
            }
            function proxy() {
                var timeStamp = Date.now();
                if (leadingCall) {
                    if (timeStamp - lastCallTime < trailingTimeout) return;
                    trailingCall = !0;
                } else leadingCall = !0, trailingCall = !1, setTimeout(timeoutCallback, delay);
                lastCallTime = timeStamp;
            }
            return proxy;
        }
        var REFRESH_DELAY = 20, transitionKeys = [ "top", "right", "bottom", "left", "width", "height", "size", "weight" ], mutationObserverSupported = "undefined" != typeof MutationObserver, ResizeObserverController = function() {
            function ResizeObserverController2() {
                this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, 
                this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), 
                this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
            }
            return ResizeObserverController2.prototype.addObserver = function(observer) {
                ~this.observers_.indexOf(observer) || this.observers_.push(observer), this.connected_ || this.connect_();
            }, ResizeObserverController2.prototype.removeObserver = function(observer) {
                var observers2 = this.observers_, index2 = observers2.indexOf(observer);
                ~index2 && observers2.splice(index2, 1), !observers2.length && this.connected_ && this.disconnect_();
            }, ResizeObserverController2.prototype.refresh = function() {
                this.updateObservers_() && this.refresh();
            }, ResizeObserverController2.prototype.updateObservers_ = function() {
                var activeObservers = this.observers_.filter((function(observer) {
                    return observer.gatherActive(), observer.hasActive();
                }));
                return activeObservers.forEach((function(observer) {
                    return observer.broadcastActive();
                })), activeObservers.length > 0;
            }, ResizeObserverController2.prototype.connect_ = function() {
                isBrowser && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), 
                window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), 
                this.mutationsObserver_.observe(document, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), 
                this.connected_ = !0);
            }, ResizeObserverController2.prototype.disconnect_ = function() {
                isBrowser && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), 
                window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), 
                this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), 
                this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
            }, ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
                var _b = _a.propertyName, propertyName = void 0 === _b ? "" : _b;
                transitionKeys.some((function(key2) {
                    return !!~propertyName.indexOf(key2);
                })) && this.refresh();
            }, ResizeObserverController2.getInstance = function() {
                return this.instance_ || (this.instance_ = new ResizeObserverController2), this.instance_;
            }, ResizeObserverController2.instance_ = null, ResizeObserverController2;
        }(), defineConfigurable = function(target, props2) {
            for (var _i = 0, _a = Object.keys(props2); _i < _a.length; _i++) {
                var key2 = _a[_i];
                Object.defineProperty(target, key2, {
                    value: props2[key2],
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                });
            }
            return target;
        }, getWindowOf = function(target) {
            return target && target.ownerDocument && target.ownerDocument.defaultView || global$1;
        }, emptyRect = createRectInit(0, 0, 0, 0);
        function toFloat(value) {
            return parseFloat(value) || 0;
        }
        function getBordersSize(styles) {
            for (var positions = [], _i = 1; _i < arguments.length; _i++) positions[_i - 1] = arguments[_i];
            return positions.reduce((function(size2, position2) {
                return size2 + toFloat(styles["border-" + position2 + "-width"]);
            }), 0);
        }
        function getPaddings(styles) {
            for (var paddings = {}, _i = 0, positions_1 = [ "top", "right", "bottom", "left" ]; _i < positions_1.length; _i++) {
                var position2 = positions_1[_i], value = styles["padding-" + position2];
                paddings[position2] = toFloat(value);
            }
            return paddings;
        }
        function getSVGContentRect(target) {
            var bbox = target.getBBox();
            return createRectInit(0, 0, bbox.width, bbox.height);
        }
        function getHTMLElementContentRect(target) {
            var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
            if (!clientWidth && !clientHeight) return emptyRect;
            var styles = getWindowOf(target).getComputedStyle(target), paddings = getPaddings(styles), horizPad = paddings.left + paddings.right, vertPad = paddings.top + paddings.bottom, width = toFloat(styles.width), height = toFloat(styles.height);
            if ("border-box" === styles.boxSizing && (Math.round(width + horizPad) !== clientWidth && (width -= getBordersSize(styles, "left", "right") + horizPad), 
            Math.round(height + vertPad) !== clientHeight && (height -= getBordersSize(styles, "top", "bottom") + vertPad)), 
            !isDocumentElement(target)) {
                var vertScrollbar = Math.round(width + horizPad) - clientWidth, horizScrollbar = Math.round(height + vertPad) - clientHeight;
                1 !== Math.abs(vertScrollbar) && (width -= vertScrollbar), 1 !== Math.abs(horizScrollbar) && (height -= horizScrollbar);
            }
            return createRectInit(paddings.left, paddings.top, width, height);
        }
        var isSVGGraphicsElement = "undefined" != typeof SVGGraphicsElement ? function(target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
        } : function(target) {
            return target instanceof getWindowOf(target).SVGElement && "function" == typeof target.getBBox;
        };
        function isDocumentElement(target) {
            return target === getWindowOf(target).document.documentElement;
        }
        function getContentRect(target) {
            return isBrowser ? isSVGGraphicsElement(target) ? getSVGContentRect(target) : getHTMLElementContentRect(target) : emptyRect;
        }
        function createReadOnlyRect(_a) {
            var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height, Constr = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object, rect = Object.create(Constr.prototype);
            return defineConfigurable(rect, {
                x: x2,
                y: y2,
                width: width,
                height: height,
                top: y2,
                right: x2 + width,
                bottom: height + y2,
                left: x2
            }), rect;
        }
        function createRectInit(x2, y2, width, height) {
            return {
                x: x2,
                y: y2,
                width: width,
                height: height
            };
        }
        var ResizeObservation = function() {
            function ResizeObservation2(target) {
                this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), 
                this.target = target;
            }
            return ResizeObservation2.prototype.isActive = function() {
                var rect = getContentRect(this.target);
                return this.contentRect_ = rect, rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
            }, ResizeObservation2.prototype.broadcastRect = function() {
                var rect = this.contentRect_;
                return this.broadcastWidth = rect.width, this.broadcastHeight = rect.height, rect;
            }, ResizeObservation2;
        }(), ResizeObserverEntry = function() {
            function ResizeObserverEntry2(target, rectInit) {
                var contentRect = createReadOnlyRect(rectInit);
                defineConfigurable(this, {
                    target: target,
                    contentRect: contentRect
                });
            }
            return ResizeObserverEntry2;
        }(), ResizeObserverSPI = function() {
            function ResizeObserverSPI2(callback, controller, callbackCtx) {
                if (this.activeObservations_ = [], this.observations_ = new MapShim, "function" != typeof callback) throw new TypeError("The callback provided as parameter 1 is not a function.");
                this.callback_ = callback, this.controller_ = controller, this.callbackCtx_ = callbackCtx;
            }
            return ResizeObserverSPI2.prototype.observe = function(target) {
                if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(target instanceof getWindowOf(target).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                    var observations = this.observations_;
                    observations.has(target) || (observations.set(target, new ResizeObservation(target)), 
                    this.controller_.addObserver(this), this.controller_.refresh());
                }
            }, ResizeObserverSPI2.prototype.unobserve = function(target) {
                if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(target instanceof getWindowOf(target).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                    var observations = this.observations_;
                    observations.has(target) && (observations.delete(target), observations.size || this.controller_.removeObserver(this));
                }
            }, ResizeObserverSPI2.prototype.disconnect = function() {
                this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
            }, ResizeObserverSPI2.prototype.gatherActive = function() {
                var _this = this;
                this.clearActive(), this.observations_.forEach((function(observation) {
                    observation.isActive() && _this.activeObservations_.push(observation);
                }));
            }, ResizeObserverSPI2.prototype.broadcastActive = function() {
                if (this.hasActive()) {
                    var ctx = this.callbackCtx_, entries = this.activeObservations_.map((function(observation) {
                        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
                    }));
                    this.callback_.call(ctx, entries, ctx), this.clearActive();
                }
            }, ResizeObserverSPI2.prototype.clearActive = function() {
                this.activeObservations_.splice(0);
            }, ResizeObserverSPI2.prototype.hasActive = function() {
                return this.activeObservations_.length > 0;
            }, ResizeObserverSPI2;
        }(), observers = "undefined" != typeof WeakMap ? new WeakMap : new MapShim, ResizeObserver$2 = function() {
            function ResizeObserver2(callback) {
                if (!(this instanceof ResizeObserver2)) throw new TypeError("Cannot call a class as a function.");
                if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                var controller = ResizeObserverController.getInstance(), observer = new ResizeObserverSPI(callback, controller, this);
                observers.set(this, observer);
            }
            return ResizeObserver2;
        }();
        [ "observe", "unobserve", "disconnect" ].forEach((function(method) {
            ResizeObserver$2.prototype[method] = function() {
                var _a;
                return (_a = observers.get(this))[method].apply(_a, arguments);
            };
        }));
        var index = void 0 !== global$1.ResizeObserver ? global$1.ResizeObserver : ResizeObserver$2;
        const isValid = value => null != value && "" !== value, initDefaultProps = (types2, defaultProps) => {
            const propTypes = _extends$1({}, types2);
            return Object.keys(defaultProps).forEach((k2 => {
                const prop = propTypes[k2];
                if (!prop) throw new Error(`not have ${k2} prop`);
                prop.type || prop.default ? prop.default = defaultProps[k2] : prop.def ? prop.def(defaultProps[k2]) : propTypes[k2] = {
                    type: prop,
                    default: defaultProps[k2]
                };
            })), propTypes;
        }, splitAttrs = attrs => {
            const allAttrs = Object.keys(attrs), eventAttrs = {}, onEvents = {}, extraAttrs = {};
            for (let i2 = 0, l2 = allAttrs.length; i2 < l2; i2++) {
                const key2 = allAttrs[i2];
                isOn(key2) ? (eventAttrs[key2[2].toLowerCase() + key2.slice(3)] = attrs[key2], onEvents[key2] = attrs[key2]) : extraAttrs[key2] = attrs[key2];
            }
            return {
                onEvents: onEvents,
                events: eventAttrs,
                extraAttrs: extraAttrs
            };
        }, parseStyleText = function() {
            let cssText = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", camel = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const res = {}, listDelimiter = /;(?![^(]*\))/g, propertyDelimiter = /:(.+)/;
            return "object" == typeof cssText ? cssText : (cssText.split(listDelimiter).forEach((function(item) {
                if (item) {
                    const tmp = item.split(propertyDelimiter);
                    if (tmp.length > 1) {
                        const k2 = camel ? camelize(tmp[0].trim()) : tmp[0].trim();
                        res[k2] = tmp[1].trim();
                    }
                }
            })), res);
        }, hasProp = (instance, prop) => void 0 !== instance[prop], skipFlattenKey = Symbol("skipFlatten"), flattenChildren = function() {
            let children = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], filterEmpty2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            const temp = Array.isArray(children) ? children : [ children ], res = [];
            return temp.forEach((child => {
                Array.isArray(child) ? res.push(...flattenChildren(child, filterEmpty2)) : child && child.type === Fragment ? child.key === skipFlattenKey ? res.push(child) : res.push(...flattenChildren(child.children, filterEmpty2)) : child && isVNode(child) ? filterEmpty2 && !isEmptyElement(child) ? res.push(child) : filterEmpty2 || res.push(child) : isValid(child) && res.push(child);
            })), res;
        }, getSlot = function(self2) {
            let name = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default", options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            if (isVNode(self2)) return self2.type === Fragment ? "default" === name ? flattenChildren(self2.children) : [] : self2.children && self2.children[name] ? flattenChildren(self2.children[name](options)) : [];
            {
                const res = self2.$slots[name] && self2.$slots[name](options);
                return flattenChildren(res);
            }
        }, findDOMNode = instance => {
            var _a;
            let node2 = (null === (_a = null == instance ? void 0 : instance.vnode) || void 0 === _a ? void 0 : _a.el) || instance && (instance.$el || instance);
            for (;node2 && !node2.tagName; ) node2 = node2.nextSibling;
            return node2;
        }, getOptionProps = instance => {
            const res = {};
            if (instance.$ && instance.$.vnode) {
                const props2 = instance.$.vnode.props || {};
                Object.keys(instance.$props).forEach((k2 => {
                    const v2 = instance.$props[k2], hyphenateKey = hyphenate(k2);
                    (void 0 !== v2 || hyphenateKey in props2) && (res[k2] = v2);
                }));
            } else if (isVNode(instance) && "object" == typeof instance.type) {
                const originProps = instance.props || {}, props2 = {};
                Object.keys(originProps).forEach((key2 => {
                    props2[camelize(key2)] = originProps[key2];
                }));
                const options = instance.type.props || {};
                Object.keys(options).forEach((k2 => {
                    const v2 = resolvePropValue(options, props2, k2, props2[k2]);
                    (void 0 !== v2 || k2 in props2) && (res[k2] = v2);
                }));
            }
            return res;
        }, getComponent = function(instance) {
            let com, prop = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default", options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : instance, execute = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
            if (instance.$) {
                const temp = instance[prop];
                if (void 0 !== temp) return "function" == typeof temp && execute ? temp(options) : temp;
                com = instance.$slots[prop], com = execute && com ? com(options) : com;
            } else if (isVNode(instance)) {
                const temp = instance.props && instance.props[prop];
                if (void 0 !== temp && null !== instance.props) return "function" == typeof temp && execute ? temp(options) : temp;
                instance.type === Fragment ? com = instance.children : instance.children && instance.children[prop] && (com = instance.children[prop], 
                com = execute && com ? com(options) : com);
            }
            return Array.isArray(com) && (com = flattenChildren(com), com = 1 === com.length ? com[0] : com, 
            com = 0 === com.length ? void 0 : com), com;
        };
        function getEvents() {
            let ele = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, on = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], props2 = {};
            return props2 = ele.$ ? _extends$1(_extends$1({}, props2), ele.$attrs) : _extends$1(_extends$1({}, props2), ele.props), 
            splitAttrs(props2)[on ? "onEvents" : "events"];
        }
        function getStyle$1(ele, camel) {
            let style = ((isVNode(ele) ? ele.props : ele.$attrs) || {}).style || {};
            return "string" == typeof style && (style = parseStyleText(style, camel)), style;
        }
        function isFragment(c2) {
            return 1 === c2.length && c2[0].type === Fragment;
        }
        function isEmptyElement(c2) {
            return c2 && (c2.type === Comment || c2.type === Fragment && 0 === c2.children.length || c2.type === Text && "" === c2.children.trim());
        }
        function filterEmpty() {
            const res = [];
            return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).forEach((child => {
                Array.isArray(child) ? res.push(...child) : (null == child ? void 0 : child.type) === Fragment ? res.push(...filterEmpty(child.children)) : res.push(child);
            })), res.filter((c2 => !isEmptyElement(c2)));
        }
        function isValidElement(element) {
            return Array.isArray(element) && 1 === element.length && (element = element[0]), 
            element && element.__v_isVNode && "symbol" != typeof element.type;
        }
        function getPropsSlot(slots, props2) {
            let prop = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "default";
            var _a, _b;
            return null !== (_a = props2[prop]) && void 0 !== _a ? _a : null === (_b = slots[prop]) || void 0 === _b ? void 0 : _b.call(slots);
        }
        const ResizeObserver$1 = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ResizeObserver",
            props: {
                disabled: Boolean,
                onResize: Function
            },
            emits: [ "resize" ],
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const state = reactive({
                    width: 0,
                    height: 0,
                    offsetHeight: 0,
                    offsetWidth: 0
                });
                let currentElement = null, resizeObserver = null;
                const destroyObserver = () => {
                    resizeObserver && (resizeObserver.disconnect(), resizeObserver = null);
                }, onResize = entries => {
                    const {onResize: onResize2} = props2, target = entries[0].target, {width: width, height: height} = target.getBoundingClientRect(), {offsetWidth: offsetWidth, offsetHeight: offsetHeight} = target, fixedWidth = Math.floor(width), fixedHeight = Math.floor(height);
                    if (state.width !== fixedWidth || state.height !== fixedHeight || state.offsetWidth !== offsetWidth || state.offsetHeight !== offsetHeight) {
                        const size2 = {
                            width: fixedWidth,
                            height: fixedHeight,
                            offsetWidth: offsetWidth,
                            offsetHeight: offsetHeight
                        };
                        _extends$1(state, size2), onResize2 && Promise.resolve().then((() => {
                            onResize2(_extends$1(_extends$1({}, size2), {
                                offsetWidth: offsetWidth,
                                offsetHeight: offsetHeight
                            }), target);
                        }));
                    }
                }, instance = getCurrentInstance(), registerObserver = () => {
                    const {disabled: disabled} = props2;
                    if (disabled) return void destroyObserver();
                    const element = findDOMNode(instance);
                    element !== currentElement && (destroyObserver(), currentElement = element), !resizeObserver && element && (resizeObserver = new index(onResize), 
                    resizeObserver.observe(element));
                };
                return onMounted((() => {
                    registerObserver();
                })), onUpdated((() => {
                    registerObserver();
                })), onUnmounted((() => {
                    destroyObserver();
                })), watch((() => props2.disabled), (() => {
                    registerObserver();
                }), {
                    flush: "post"
                }), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots)[0];
                };
            }
        });
        let raf = callback => setTimeout(callback, 16), caf = num => clearTimeout(num);
        "undefined" != typeof window && "requestAnimationFrame" in window && (raf = callback => window.requestAnimationFrame(callback), 
        caf = handle => window.cancelAnimationFrame(handle));
        let rafUUID = 0;
        const rafIds = new Map;
        function cleanup(id) {
            rafIds.delete(id);
        }
        function wrapperRaf(callback) {
            rafUUID += 1;
            const id = rafUUID;
            function callRef(leftTimes) {
                if (0 === leftTimes) cleanup(id), callback(); else {
                    const realId = raf((() => {
                        callRef(leftTimes - 1);
                    }));
                    rafIds.set(id, realId);
                }
            }
            return callRef(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1), 
            id;
        }
        wrapperRaf.cancel = id => {
            const realId = rafIds.get(id);
            return cleanup(realId), caf(realId);
        };
        const tuple = function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return args;
        }, withInstall = comp => {
            const c2 = comp;
            return c2.install = function(app) {
                app.component(c2.displayName || c2.name, comp);
            }, comp;
        };
        function eventType() {
            return {
                type: [ Function, Array ]
            };
        }
        function objectType(defaultVal) {
            return {
                type: Object,
                default: defaultVal
            };
        }
        function booleanType(defaultVal) {
            return {
                type: Boolean,
                default: defaultVal
            };
        }
        function functionType(defaultVal) {
            return {
                type: Function,
                default: defaultVal
            };
        }
        function anyType(defaultVal, required) {
            const type = {
                validator: () => !0,
                default: defaultVal
            };
            return type;
        }
        function arrayType(defaultVal) {
            return {
                type: Array,
                default: defaultVal
            };
        }
        function stringType(defaultVal) {
            return {
                type: String,
                default: defaultVal
            };
        }
        function someType(types2, defaultVal) {
            return types2 ? {
                type: types2,
                default: defaultVal
            } : anyType(defaultVal);
        }
        let supportsPassive = !1;
        try {
            const opts = Object.defineProperty({}, "passive", {
                get() {
                    supportsPassive = !0;
                }
            });
            window.addEventListener("testPassive", null, opts), window.removeEventListener("testPassive", null, opts);
        } catch (e2) {}
        function addEventListenerWrap(target, eventType2, cb, option) {
            if (target && target.addEventListener) {
                let opt = option;
                void 0 !== opt || !supportsPassive || "touchstart" !== eventType2 && "touchmove" !== eventType2 && "wheel" !== eventType2 || (opt = {
                    passive: !1
                }), target.addEventListener(eventType2, cb, opt);
            }
            return {
                remove: () => {
                    target && target.removeEventListener && target.removeEventListener(eventType2, cb);
                }
            };
        }
        const defaultIconPrefixCls = "anticon", GlobalFormContextKey = Symbol("GlobalFormContextKey"), useProvideGlobalForm = state => {
            provide(GlobalFormContextKey, state);
        }, useInjectGlobalForm = () => inject(GlobalFormContextKey, {
            validateMessages: computed((() => {}))
        }), configProviderProps = () => ({
            iconPrefixCls: String,
            getTargetContainer: {
                type: Function
            },
            getPopupContainer: {
                type: Function
            },
            prefixCls: String,
            getPrefixCls: {
                type: Function
            },
            renderEmpty: {
                type: Function
            },
            transformCellText: {
                type: Function
            },
            csp: objectType(),
            input: objectType(),
            autoInsertSpaceInButton: {
                type: Boolean,
                default: void 0
            },
            locale: objectType(),
            pageHeader: objectType(),
            componentSize: {
                type: String
            },
            componentDisabled: {
                type: Boolean,
                default: void 0
            },
            direction: {
                type: String,
                default: "ltr"
            },
            space: objectType(),
            virtual: {
                type: Boolean,
                default: void 0
            },
            dropdownMatchSelectWidth: {
                type: [ Number, Boolean ],
                default: !0
            },
            form: objectType(),
            pagination: objectType(),
            theme: objectType(),
            select: objectType(),
            wave: objectType()
        }), configProviderKey = Symbol("configProvider"), defaultConfigProvider = {
            getPrefixCls: (suffixCls, customizePrefixCls) => customizePrefixCls || (suffixCls ? `ant-${suffixCls}` : "ant"),
            iconPrefixCls: computed((() => defaultIconPrefixCls)),
            getPopupContainer: computed((() => () => document.body)),
            direction: computed((() => "ltr"))
        }, useConfigContextInject = () => inject(configProviderKey, defaultConfigProvider), useConfigContextProvider = props2 => provide(configProviderKey, props2), DisabledContextKey = Symbol("DisabledContextKey"), useInjectDisabled = () => inject(DisabledContextKey, ref(void 0)), useProviderDisabled = disabled => {
            const parentDisabled = useInjectDisabled();
            return provide(DisabledContextKey, computed((() => {
                var _a;
                return null !== (_a = disabled.value) && void 0 !== _a ? _a : parentDisabled.value;
            }))), disabled;
        }, enUS = {
            items_per_page: "/ page",
            jump_to: "Go to",
            jump_to_confirm: "confirm",
            page: "",
            prev_page: "Previous Page",
            next_page: "Next Page",
            prev_5: "Previous 5 Pages",
            next_5: "Next 5 Pages",
            prev_3: "Previous 3 Pages",
            next_3: "Next 3 Pages"
        }, locale$2 = {
            placeholder: "Select time",
            rangePlaceholder: [ "Start time", "End time" ]
        }, locale$1 = {
            lang: _extends$1({
                placeholder: "Select date",
                yearPlaceholder: "Select year",
                quarterPlaceholder: "Select quarter",
                monthPlaceholder: "Select month",
                weekPlaceholder: "Select week",
                rangePlaceholder: [ "Start date", "End date" ],
                rangeYearPlaceholder: [ "Start year", "End year" ],
                rangeQuarterPlaceholder: [ "Start quarter", "End quarter" ],
                rangeMonthPlaceholder: [ "Start month", "End month" ],
                rangeWeekPlaceholder: [ "Start week", "End week" ]
            }, {
                locale: "en_US",
                today: "Today",
                now: "Now",
                backToToday: "Back to today",
                ok: "Ok",
                clear: "Clear",
                month: "Month",
                year: "Year",
                timeSelect: "select time",
                dateSelect: "select date",
                weekSelect: "Choose a week",
                monthSelect: "Choose a month",
                yearSelect: "Choose a year",
                decadeSelect: "Choose a decade",
                yearFormat: "YYYY",
                dateFormat: "M/D/YYYY",
                dayFormat: "D",
                dateTimeFormat: "M/D/YYYY HH:mm:ss",
                monthBeforeYear: !0,
                previousMonth: "Previous month (PageUp)",
                nextMonth: "Next month (PageDown)",
                previousYear: "Last year (Control + left)",
                nextYear: "Next year (Control + right)",
                previousDecade: "Last decade",
                nextDecade: "Next decade",
                previousCentury: "Last century",
                nextCentury: "Next century"
            }),
            timePickerLocale: _extends$1({}, locale$2)
        }, typeTemplate$1 = "${label} is not a valid ${type}", localeValues = {
            locale: "en",
            Pagination: enUS,
            DatePicker: locale$1,
            TimePicker: locale$2,
            Calendar: locale$1,
            global: {
                placeholder: "Please select"
            },
            Table: {
                filterTitle: "Filter menu",
                filterConfirm: "OK",
                filterReset: "Reset",
                filterEmptyText: "No filters",
                filterCheckall: "Select all items",
                filterSearchPlaceholder: "Search in filters",
                emptyText: "No data",
                selectAll: "Select current page",
                selectInvert: "Invert current page",
                selectNone: "Clear all data",
                selectionAll: "Select all data",
                sortTitle: "Sort",
                expand: "Expand row",
                collapse: "Collapse row",
                triggerDesc: "Click to sort descending",
                triggerAsc: "Click to sort ascending",
                cancelSort: "Click to cancel sorting"
            },
            Tour: {
                Next: "Next",
                Previous: "Previous",
                Finish: "Finish"
            },
            Modal: {
                okText: "OK",
                cancelText: "Cancel",
                justOkText: "OK"
            },
            Popconfirm: {
                okText: "OK",
                cancelText: "Cancel"
            },
            Transfer: {
                titles: [ "", "" ],
                searchPlaceholder: "Search here",
                itemUnit: "item",
                itemsUnit: "items",
                remove: "Remove",
                selectCurrent: "Select current page",
                removeCurrent: "Remove current page",
                selectAll: "Select all data",
                removeAll: "Remove all data",
                selectInvert: "Invert current page"
            },
            Upload: {
                uploading: "Uploading...",
                removeFile: "Remove file",
                uploadError: "Upload error",
                previewFile: "Preview file",
                downloadFile: "Download file"
            },
            Empty: {
                description: "No data"
            },
            Icon: {
                icon: "icon"
            },
            Text: {
                edit: "Edit",
                copy: "Copy",
                copied: "Copied",
                expand: "Expand"
            },
            PageHeader: {
                back: "Back"
            },
            Form: {
                optional: "(optional)",
                defaultValidateMessages: {
                    default: "Field validation error for ${label}",
                    required: "Please enter ${label}",
                    enum: "${label} must be one of [${enum}]",
                    whitespace: "${label} cannot be a blank character",
                    date: {
                        format: "${label} date format is invalid",
                        parse: "${label} cannot be converted to a date",
                        invalid: "${label} is an invalid date"
                    },
                    types: {
                        string: typeTemplate$1,
                        method: typeTemplate$1,
                        array: typeTemplate$1,
                        object: typeTemplate$1,
                        number: typeTemplate$1,
                        date: typeTemplate$1,
                        boolean: typeTemplate$1,
                        integer: typeTemplate$1,
                        float: typeTemplate$1,
                        regexp: typeTemplate$1,
                        email: typeTemplate$1,
                        url: typeTemplate$1,
                        hex: typeTemplate$1
                    },
                    string: {
                        len: "${label} must be ${len} characters",
                        min: "${label} must be at least ${min} characters",
                        max: "${label} must be up to ${max} characters",
                        range: "${label} must be between ${min}-${max} characters"
                    },
                    number: {
                        len: "${label} must be equal to ${len}",
                        min: "${label} must be minimum ${min}",
                        max: "${label} must be maximum ${max}",
                        range: "${label} must be between ${min}-${max}"
                    },
                    array: {
                        len: "Must be ${len} ${label}",
                        min: "At least ${min} ${label}",
                        max: "At most ${max} ${label}",
                        range: "The amount of ${label} must be between ${min}-${max}"
                    },
                    pattern: {
                        mismatch: "${label} does not match the pattern ${pattern}"
                    }
                }
            },
            Image: {
                preview: "Preview"
            },
            QRCode: {
                expired: "QR code expired",
                refresh: "Refresh",
                scanned: "Scanned"
            }
        }, LocaleReceiver = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "LocaleReceiver",
            props: {
                componentName: String,
                defaultLocale: {
                    type: [ Object, Function ]
                },
                children: {
                    type: Function
                }
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const localeData = inject("localeData", {}), locale2 = computed((() => {
                    const {componentName: componentName = "global", defaultLocale: defaultLocale} = props2, locale3 = defaultLocale || localeValues[componentName || "global"], {antLocale: antLocale} = localeData, localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
                    return _extends$1(_extends$1({}, "function" == typeof locale3 ? locale3() : locale3), localeFromContext || {});
                })), localeCode = computed((() => {
                    const {antLocale: antLocale} = localeData, localeCode2 = antLocale && antLocale.locale;
                    return antLocale && antLocale.exist && !localeCode2 ? localeValues.locale : localeCode2;
                }));
                return () => {
                    const children = props2.children || slots.default, {antLocale: antLocale} = localeData;
                    return null == children ? void 0 : children(locale2.value, localeCode.value, antLocale);
                };
            }
        });
        function useLocaleReceiver(componentName, defaultLocale, propsLocale) {
            const localeData = inject("localeData", {});
            return [ computed((() => {
                const {antLocale: antLocale} = localeData, locale2 = unref(defaultLocale) || localeValues[componentName], localeFromContext = antLocale ? antLocale[componentName] : {};
                return _extends$1(_extends$1(_extends$1({}, "function" == typeof locale2 ? locale2() : locale2), localeFromContext || {}), unref(propsLocale) || {});
            })) ];
        }
        function murmur2(str) {
            for (var k2, h2 = 0, i2 = 0, len = str.length; len >= 4; ++i2, len -= 4) k2 = 1540483477 * (65535 & (k2 = 255 & str.charCodeAt(i2) | (255 & str.charCodeAt(++i2)) << 8 | (255 & str.charCodeAt(++i2)) << 16 | (255 & str.charCodeAt(++i2)) << 24)) + (59797 * (k2 >>> 16) << 16), 
            h2 = 1540483477 * (65535 & (k2 ^= k2 >>> 24)) + (59797 * (k2 >>> 16) << 16) ^ 1540483477 * (65535 & h2) + (59797 * (h2 >>> 16) << 16);
            switch (len) {
              case 3:
                h2 ^= (255 & str.charCodeAt(i2 + 2)) << 16;

              case 2:
                h2 ^= (255 & str.charCodeAt(i2 + 1)) << 8;

              case 1:
                h2 = 1540483477 * (65535 & (h2 ^= 255 & str.charCodeAt(i2))) + (59797 * (h2 >>> 16) << 16);
            }
            return (((h2 = 1540483477 * (65535 & (h2 ^= h2 >>> 13)) + (59797 * (h2 >>> 16) << 16)) ^ h2 >>> 15) >>> 0).toString(36);
        }
        const SPLIT = "%";
        class Entity {
            constructor(instanceId) {
                this.cache = new Map, this.instanceId = instanceId;
            }
            get(keys2) {
                return this.cache.get(Array.isArray(keys2) ? keys2.join(SPLIT) : keys2) || null;
            }
            update(keys2, valueFn) {
                const path = Array.isArray(keys2) ? keys2.join(SPLIT) : keys2, nextValue = valueFn(this.cache.get(path));
                null === nextValue ? this.cache.delete(path) : this.cache.set(path, nextValue);
            }
        }
        const ATTR_TOKEN = "data-token-hash", ATTR_MARK = "data-css-hash", CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
        function createCache() {
            const cssinjsInstanceId = Math.random().toString(12).slice(2);
            if ("undefined" != typeof document && document.head && document.body) {
                const styles = document.body.querySelectorAll(`style[${ATTR_MARK}]`) || [], {firstChild: firstChild} = document.head;
                Array.from(styles).forEach((style => {
                    style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId, style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId && document.head.insertBefore(style, firstChild);
                }));
                const styleHash = {};
                Array.from(document.querySelectorAll(`style[${ATTR_MARK}]`)).forEach((style => {
                    var _a;
                    const hash = style.getAttribute(ATTR_MARK);
                    styleHash[hash] ? style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId && (null === (_a = style.parentNode) || void 0 === _a || _a.removeChild(style)) : styleHash[hash] = !0;
                }));
            }
            return new Entity(cssinjsInstanceId);
        }
        const StyleContextKey = Symbol("StyleContextKey"), getCache = () => {
            var _a, _b, _c;
            const instance = getCurrentInstance();
            let cache;
            if (instance && instance.appContext) {
                const globalCache = null === (_c = null === (_b = null === (_a = instance.appContext) || void 0 === _a ? void 0 : _a.config) || void 0 === _b ? void 0 : _b.globalProperties) || void 0 === _c ? void 0 : _c.__ANTDV_CSSINJS_CACHE__;
                globalCache ? cache = globalCache : (cache = createCache(), instance.appContext.config.globalProperties && (instance.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = cache));
            } else cache = createCache();
            return cache;
        }, defaultStyleContext = {
            cache: createCache(),
            defaultCache: !0,
            hashPriority: "low"
        }, useStyleInject = () => {
            const cache = getCache();
            return inject(StyleContextKey, shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
                cache: cache
            })));
        }, useStyleProvider = props2 => {
            const parentContext = useStyleInject(), context = shallowRef(_extends$1(_extends$1({}, defaultStyleContext), {
                cache: createCache()
            }));
            return watch([ () => unref(props2), parentContext ], (() => {
                const mergedContext = _extends$1({}, parentContext.value), propsValue = unref(props2);
                Object.keys(propsValue).forEach((key2 => {
                    const value = propsValue[key2];
                    void 0 !== propsValue[key2] && (mergedContext[key2] = value);
                }));
                const {cache: cache} = propsValue;
                mergedContext.cache = mergedContext.cache || createCache(), mergedContext.defaultCache = !cache && parentContext.value.defaultCache, 
                context.value = mergedContext;
            }), {
                immediate: !0
            }), provide(StyleContextKey, context), context;
        };
        function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
            const styleContext = useStyleInject(), fullPathStr = shallowRef(""), res = shallowRef();
            watchEffect((() => {
                fullPathStr.value = [ prefix, ...keyPath.value ].join("%");
            }));
            const clearCache = pathStr => {
                styleContext.value.cache.update(pathStr, (prevCache => {
                    const [times = 0, cache] = prevCache || [];
                    return 0 === times - 1 ? (null == onCacheRemove || onCacheRemove(cache, !1), null) : [ times - 1, cache ];
                }));
            };
            return watch(fullPathStr, ((newStr, oldStr) => {
                oldStr && clearCache(oldStr), styleContext.value.cache.update(newStr, (prevCache => {
                    const [times = 0, cache] = prevCache || [];
                    return [ times + 1, cache || cacheFn() ];
                })), res.value = styleContext.value.cache.get(fullPathStr.value)[1];
            }), {
                immediate: !0
            }), onBeforeUnmount((() => {
                clearCache(fullPathStr.value);
            })), res;
        }
        function canUseDom$1() {
            return !("undefined" == typeof window || !window.document || !window.document.createElement);
        }
        function contains$1(root2, n2) {
            return !!root2 && (!!root2.contains && root2.contains(n2));
        }
        withInstall(defineComponent({
            name: "AStyleProvider",
            inheritAttrs: !1,
            props: (() => ({
                autoClear: booleanType(),
                mock: stringType(),
                cache: objectType(),
                defaultCache: booleanType(),
                hashPriority: stringType(),
                container: someType(),
                ssrInline: booleanType(),
                transformers: arrayType(),
                linters: arrayType()
            }))(),
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                return useStyleProvider(props2), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        }));
        const APPEND_ORDER$1 = "data-vc-order", MARK_KEY$1 = "vc-util-key", containerCache$1 = new Map;
        function getMark$1() {
            let {mark: mark} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return mark ? mark.startsWith("data-") ? mark : `data-${mark}` : MARK_KEY$1;
        }
        function getContainer$2(option) {
            if (option.attachTo) return option.attachTo;
            return document.querySelector("head") || document.body;
        }
        function getOrder$1(prepend) {
            return "queue" === prepend ? "prependQueue" : prepend ? "prepend" : "append";
        }
        function findStyles$1(container) {
            return Array.from((containerCache$1.get(container) || container).children).filter((node2 => "STYLE" === node2.tagName));
        }
        function injectCSS$1(css2) {
            let option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (!canUseDom$1()) return null;
            const {csp: csp, prepend: prepend} = option, styleNode = document.createElement("style");
            styleNode.setAttribute(APPEND_ORDER$1, getOrder$1(prepend)), (null == csp ? void 0 : csp.nonce) && (styleNode.nonce = null == csp ? void 0 : csp.nonce), 
            styleNode.innerHTML = css2;
            const container = getContainer$2(option), {firstChild: firstChild} = container;
            if (prepend) {
                if ("queue" === prepend) {
                    const existStyle = findStyles$1(container).filter((node2 => [ "prepend", "prependQueue" ].includes(node2.getAttribute(APPEND_ORDER$1))));
                    if (existStyle.length) return container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling), 
                    styleNode;
                }
                container.insertBefore(styleNode, firstChild);
            } else container.appendChild(styleNode);
            return styleNode;
        }
        function findExistNode$1(key2) {
            let option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return findStyles$1(getContainer$2(option)).find((node2 => node2.getAttribute(getMark$1(option)) === key2));
        }
        function removeCSS(key2) {
            let option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const existNode = findExistNode$1(key2, option);
            if (existNode) {
                getContainer$2(option).removeChild(existNode);
            }
        }
        function syncRealContainer$1(container, option) {
            const cachedRealContainer = containerCache$1.get(container);
            if (!cachedRealContainer || !contains$1(document, cachedRealContainer)) {
                const placeholderStyle = injectCSS$1("", option), {parentNode: parentNode} = placeholderStyle;
                containerCache$1.set(container, parentNode), container.removeChild(placeholderStyle);
            }
        }
        function updateCSS$1(css2, key2) {
            let option = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            var _a, _b, _c;
            syncRealContainer$1(getContainer$2(option), option);
            const existNode = findExistNode$1(key2, option);
            if (existNode) return (null === (_a = option.csp) || void 0 === _a ? void 0 : _a.nonce) && existNode.nonce !== (null === (_b = option.csp) || void 0 === _b ? void 0 : _b.nonce) && (existNode.nonce = null === (_c = option.csp) || void 0 === _c ? void 0 : _c.nonce), 
            existNode.innerHTML !== css2 && (existNode.innerHTML = css2), existNode;
            const newNode = injectCSS$1(css2, option);
            return newNode.setAttribute(getMark$1(option), key2), newNode;
        }
        function sameDerivativeOption(left, right) {
            if (left.length !== right.length) return !1;
            for (let i2 = 0; i2 < left.length; i2++) if (left[i2] !== right[i2]) return !1;
            return !0;
        }
        class ThemeCache {
            constructor() {
                this.cache = new Map, this.keys = [], this.cacheCallTimes = 0;
            }
            size() {
                return this.keys.length;
            }
            internalGet(derivativeOption) {
                let updateCallTimes = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], cache = {
                    map: this.cache
                };
                return derivativeOption.forEach((derivative2 => {
                    var _a;
                    cache = cache ? null === (_a = null == cache ? void 0 : cache.map) || void 0 === _a ? void 0 : _a.get(derivative2) : void 0;
                })), (null == cache ? void 0 : cache.value) && updateCallTimes && (cache.value[1] = this.cacheCallTimes++), 
                null == cache ? void 0 : cache.value;
            }
            get(derivativeOption) {
                var _a;
                return null === (_a = this.internalGet(derivativeOption, !0)) || void 0 === _a ? void 0 : _a[0];
            }
            has(derivativeOption) {
                return !!this.internalGet(derivativeOption);
            }
            set(derivativeOption, value) {
                if (!this.has(derivativeOption)) {
                    if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
                        const [targetKey] = this.keys.reduce(((result, key2) => {
                            const [, callTimes] = result;
                            return this.internalGet(key2)[1] < callTimes ? [ key2, this.internalGet(key2)[1] ] : result;
                        }), [ this.keys[0], this.cacheCallTimes ]);
                        this.delete(targetKey);
                    }
                    this.keys.push(derivativeOption);
                }
                let cache = this.cache;
                derivativeOption.forEach(((derivative2, index2) => {
                    if (index2 === derivativeOption.length - 1) cache.set(derivative2, {
                        value: [ value, this.cacheCallTimes++ ]
                    }); else {
                        const cacheValue = cache.get(derivative2);
                        cacheValue ? cacheValue.map || (cacheValue.map = new Map) : cache.set(derivative2, {
                            map: new Map
                        }), cache = cache.get(derivative2).map;
                    }
                }));
            }
            deleteByPath(currentCache, derivatives) {
                var _a;
                const cache = currentCache.get(derivatives[0]);
                if (1 === derivatives.length) return cache.map ? currentCache.set(derivatives[0], {
                    map: cache.map
                }) : currentCache.delete(derivatives[0]), null === (_a = cache.value) || void 0 === _a ? void 0 : _a[0];
                const result = this.deleteByPath(cache.map, derivatives.slice(1));
                return cache.map && 0 !== cache.map.size || cache.value || currentCache.delete(derivatives[0]), 
                result;
            }
            delete(derivativeOption) {
                if (this.has(derivativeOption)) return this.keys = this.keys.filter((item => !sameDerivativeOption(item, derivativeOption))), 
                this.deleteByPath(this.cache, derivativeOption);
            }
        }
        ThemeCache.MAX_CACHE_SIZE = 20, ThemeCache.MAX_CACHE_OFFSET = 5;
        let warned = {};
        function warning$3(valid, message) {}
        function call(method, valid, message) {
            valid || warned[message] || (warned[message] = !0);
        }
        function warningOnce(valid, message) {
            call(warning$3, valid, message);
        }
        function noop$3() {}
        let warning$2 = noop$3, uuid$2 = 0;
        class Theme {
            constructor(derivatives) {
                this.derivatives = Array.isArray(derivatives) ? derivatives : [ derivatives ], this.id = uuid$2, 
                0 === derivatives.length && warning$2(derivatives.length > 0), uuid$2 += 1;
            }
            getDerivativeToken(token2) {
                return this.derivatives.reduce(((result, derivative2) => derivative2(token2, result)), void 0);
            }
        }
        const cacheThemes = new ThemeCache;
        function createTheme(derivatives) {
            const derivativeArr = Array.isArray(derivatives) ? derivatives : [ derivatives ];
            return cacheThemes.has(derivativeArr) || cacheThemes.set(derivativeArr, new Theme(derivativeArr)), 
            cacheThemes.get(derivativeArr);
        }
        const flattenTokenCache = new WeakMap;
        function flattenToken(token2) {
            let str = flattenTokenCache.get(token2) || "";
            return str || (Object.keys(token2).forEach((key2 => {
                const value = token2[key2];
                str += key2, str += value instanceof Theme ? value.id : value && "object" == typeof value ? flattenToken(value) : value;
            })), flattenTokenCache.set(token2, str)), str;
        }
        function token2key(token2, salt) {
            return murmur2(`${salt}_${flattenToken(token2)}`);
        }
        const randomSelectorKey = `random-${Date.now()}-${Math.random()}`.replace(/\./g, ""), checkContent = "_bAmBoO_";
        function supportSelector(styleStr, handleElement, supportCheck) {
            var _a, _b;
            if (canUseDom$1()) {
                updateCSS$1(styleStr, randomSelectorKey);
                const ele = document.createElement("div");
                ele.style.position = "fixed", ele.style.left = "0", ele.style.top = "0", null == handleElement || handleElement(ele), 
                document.body.appendChild(ele);
                const support = supportCheck ? supportCheck(ele) : null === (_a = getComputedStyle(ele).content) || void 0 === _a ? void 0 : _a.includes(checkContent);
                return null === (_b = ele.parentNode) || void 0 === _b || _b.removeChild(ele), removeCSS(randomSelectorKey), 
                support;
            }
            return !1;
        }
        let canLayer;
        function supportLayer() {
            return void 0 === canLayer && (canLayer = supportSelector(`@layer ${randomSelectorKey} { .${randomSelectorKey} { content: "${checkContent}"!important; } }`, (ele => {
                ele.className = randomSelectorKey;
            }))), canLayer;
        }
        const EMPTY_OVERRIDE = {}, hashPrefix = !0 || !1 ? "css" : "css-dev-only-do-not-override", tokenKeys = new Map;
        function recordCleanToken(tokenKey) {
            tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
        }
        function removeStyleTags(key2, instanceId) {
            if ("undefined" != typeof document) {
                document.querySelectorAll(`style[${ATTR_TOKEN}="${key2}"]`).forEach((style => {
                    var _a;
                    style[CSS_IN_JS_INSTANCE] === instanceId && (null === (_a = style.parentNode) || void 0 === _a || _a.removeChild(style));
                }));
            }
        }
        const TOKEN_THRESHOLD = 0;
        function cleanTokenStyle(tokenKey, instanceId) {
            tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
            const tokenKeyList = Array.from(tokenKeys.keys()), cleanableKeyList = tokenKeyList.filter((key2 => (tokenKeys.get(key2) || 0) <= 0));
            tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD && cleanableKeyList.forEach((key2 => {
                removeStyleTags(key2, instanceId), tokenKeys.delete(key2);
            }));
        }
        const getComputedToken = (originToken, overrideToken, theme, format2) => {
            let mergedDerivativeToken = _extends$1(_extends$1({}, theme.getDerivativeToken(originToken)), overrideToken);
            return format2 && (mergedDerivativeToken = format2(mergedDerivativeToken)), mergedDerivativeToken;
        };
        function useCacheToken(theme, tokens) {
            let option = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ref({});
            const style = useStyleInject(), mergedToken = computed((() => _extends$1({}, ...tokens.value))), tokenStr = computed((() => flattenToken(mergedToken.value))), overrideTokenStr = computed((() => flattenToken(option.value.override || EMPTY_OVERRIDE)));
            return useClientCache("token", computed((() => [ option.value.salt || "", theme.value.id, tokenStr.value, overrideTokenStr.value ])), (() => {
                const {salt: salt = "", override: override = EMPTY_OVERRIDE, formatToken: formatToken2, getComputedToken: compute} = option.value, mergedDerivativeToken = compute ? compute(mergedToken.value, override, theme.value) : getComputedToken(mergedToken.value, override, theme.value, formatToken2), tokenKey = token2key(mergedDerivativeToken, salt);
                mergedDerivativeToken._tokenKey = tokenKey, recordCleanToken(tokenKey);
                const hashId = `${hashPrefix}-${murmur2(tokenKey)}`;
                return mergedDerivativeToken._hashId = hashId, [ mergedDerivativeToken, hashId ];
            }), (cache => {
                var _a;
                cleanTokenStyle(cache[0]._tokenKey, null === (_a = style.value) || void 0 === _a ? void 0 : _a.cache.instanceId);
            }));
        }
        var unitlessKeys = {
            animationIterationCount: 1,
            aspectRatio: 1,
            borderImageOutset: 1,
            borderImageSlice: 1,
            borderImageWidth: 1,
            boxFlex: 1,
            boxFlexGroup: 1,
            boxOrdinalGroup: 1,
            columnCount: 1,
            columns: 1,
            flex: 1,
            flexGrow: 1,
            flexPositive: 1,
            flexShrink: 1,
            flexNegative: 1,
            flexOrder: 1,
            gridRow: 1,
            gridRowEnd: 1,
            gridRowSpan: 1,
            gridRowStart: 1,
            gridColumn: 1,
            gridColumnEnd: 1,
            gridColumnSpan: 1,
            gridColumnStart: 1,
            msGridRow: 1,
            msGridRowSpan: 1,
            msGridColumn: 1,
            msGridColumnSpan: 1,
            fontWeight: 1,
            lineHeight: 1,
            opacity: 1,
            order: 1,
            orphans: 1,
            tabSize: 1,
            widows: 1,
            zIndex: 1,
            zoom: 1,
            WebkitLineClamp: 1,
            fillOpacity: 1,
            floodOpacity: 1,
            stopOpacity: 1,
            strokeDasharray: 1,
            strokeDashoffset: 1,
            strokeMiterlimit: 1,
            strokeOpacity: 1,
            strokeWidth: 1
        }, COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from = String.fromCharCode;
        function trim(value) {
            return value.trim();
        }
        function replace(value, pattern, replacement) {
            return value.replace(pattern, replacement);
        }
        function indexof(value, search, position2) {
            return value.indexOf(search, position2);
        }
        function charat(value, index2) {
            return 0 | value.charCodeAt(index2);
        }
        function substr(value, begin, end) {
            return value.slice(begin, end);
        }
        function strlen(value) {
            return value.length;
        }
        function sizeof(value) {
            return value.length;
        }
        function append(value, array) {
            return array.push(value), value;
        }
        var line = 1, column = 1, length = 0, position = 0, character = 0, characters = "";
        function node(value, root2, parent2, type, props2, children, length2, siblings) {
            return {
                value: value,
                root: root2,
                parent: parent2,
                type: type,
                props: props2,
                children: children,
                line: line,
                column: column,
                length: length2,
                return: "",
                siblings: siblings
            };
        }
        function char() {
            return character;
        }
        function prev() {
            return character = position > 0 ? charat(characters, --position) : 0, column--, 
            10 === character && (column = 1, line--), character;
        }
        function next() {
            return character = position < length ? charat(characters, position++) : 0, column++, 
            10 === character && (column = 1, line++), character;
        }
        function peek() {
            return charat(characters, position);
        }
        function caret() {
            return position;
        }
        function slice(begin, end) {
            return substr(characters, begin, end);
        }
        function token(type) {
            switch (type) {
              case 0:
              case 9:
              case 10:
              case 13:
              case 32:
                return 5;

              case 33:
              case 43:
              case 44:
              case 47:
              case 62:
              case 64:
              case 126:
              case 59:
              case 123:
              case 125:
                return 4;

              case 58:
                return 3;

              case 34:
              case 39:
              case 40:
              case 91:
                return 2;

              case 41:
              case 93:
                return 1;
            }
            return 0;
        }
        function alloc(value) {
            return line = column = 1, length = strlen(characters = value), position = 0, [];
        }
        function dealloc(value) {
            return characters = "", value;
        }
        function delimit(type) {
            return trim(slice(position - 1, delimiter(91 === type ? type + 2 : 40 === type ? type + 1 : type)));
        }
        function whitespace$1(type) {
            for (;(character = peek()) && character < 33; ) next();
            return token(type) > 2 || token(character) > 3 ? "" : " ";
        }
        function escaping(index2, count) {
            for (;--count && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); ) ;
            return slice(index2, caret() + (count < 6 && 32 == peek() && 32 == next()));
        }
        function delimiter(type) {
            for (;next(); ) switch (character) {
              case type:
                return position;

              case 34:
              case 39:
                34 !== type && 39 !== type && delimiter(character);
                break;

              case 40:
                41 === type && delimiter(type);
                break;

              case 92:
                next();
            }
            return position;
        }
        function commenter(type, index2) {
            for (;next() && type + character !== 57 && (type + character !== 84 || 47 !== peek()); ) ;
            return "/*" + slice(index2, position - 1) + "*" + from(47 === type ? type : next());
        }
        function identifier(index2) {
            for (;!token(peek()); ) next();
            return slice(index2, position);
        }
        function compile(value) {
            return dealloc(parse("", null, null, null, [ "" ], value = alloc(value), 0, [ 0 ], value));
        }
        function parse(value, root2, parent2, rule, rules2, rulesets, pseudo, points, declarations) {
            for (var index2 = 0, offset = 0, length2 = pseudo, atrule = 0, property2 = 0, previous = 0, variable = 1, scanning = 1, ampersand = 1, character2 = 0, type = "", props2 = rules2, children = rulesets, reference = rule, characters2 = type; scanning; ) switch (previous = character2, 
            character2 = next()) {
              case 40:
                if (108 != previous && 58 == charat(characters2, length2 - 1)) {
                    -1 != indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) && (ampersand = -1);
                    break;
                }

              case 34:
              case 39:
              case 91:
                characters2 += delimit(character2);
                break;

              case 9:
              case 10:
              case 13:
              case 32:
                characters2 += whitespace$1(previous);
                break;

              case 92:
                characters2 += escaping(caret() - 1, 7);
                continue;

              case 47:
                switch (peek()) {
                  case 42:
                  case 47:
                    append(comment(commenter(next(), caret()), root2, parent2, declarations), declarations);
                    break;

                  default:
                    characters2 += "/";
                }
                break;

              case 123 * variable:
                points[index2++] = strlen(characters2) * ampersand;

              case 125 * variable:
              case 59:
              case 0:
                switch (character2) {
                  case 0:
                  case 125:
                    scanning = 0;

                  case 59 + offset:
                    -1 == ampersand && (characters2 = replace(characters2, /\f/g, "")), property2 > 0 && strlen(characters2) - length2 && append(property2 > 32 ? declaration(characters2 + ";", rule, parent2, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent2, length2 - 2, declarations), declarations);
                    break;

                  case 59:
                    characters2 += ";";

                  default:
                    if (append(reference = ruleset(characters2, root2, parent2, index2, offset, rules2, points, type, props2 = [], children = [], length2, rulesets), rulesets), 
                    123 === character2) if (0 === offset) parse(characters2, root2, reference, reference, props2, rulesets, length2, points, children); else switch (99 === atrule && 110 === charat(characters2, 3) ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type, rules2, props2 = [], length2, children), children), rules2, children, length2, points, rule ? props2 : children);
                        break;

                      default:
                        parse(characters2, reference, reference, reference, [ "" ], children, 0, points, children);
                    }
                }
                index2 = offset = property2 = 0, variable = ampersand = 1, type = characters2 = "", 
                length2 = pseudo;
                break;

              case 58:
                length2 = 1 + strlen(characters2), property2 = previous;

              default:
                if (variable < 1) if (123 == character2) --variable; else if (125 == character2 && 0 == variable++ && 125 == prev()) continue;
                switch (characters2 += from(character2), character2 * variable) {
                  case 38:
                    ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
                    break;

                  case 44:
                    points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                    break;

                  case 64:
                    45 === peek() && (characters2 += delimit(next())), atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), 
                    character2++;
                    break;

                  case 45:
                    45 === previous && 2 == strlen(characters2) && (variable = 0);
                }
            }
            return rulesets;
        }
        function ruleset(value, root2, parent2, index2, offset, rules2, points, type, props2, children, length2, siblings) {
            for (var post = offset - 1, rule = 0 === offset ? rules2 : [ "" ], size2 = sizeof(rule), i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2) for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size2; ++x2) (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2]))) && (props2[k2++] = z2);
            return node(value, root2, parent2, 0 === offset ? RULESET : type, props2, children, length2, siblings);
        }
        function comment(value, root2, parent2, siblings) {
            return node(value, root2, parent2, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
        }
        function declaration(value, root2, parent2, length2, siblings) {
            return node(value, root2, parent2, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
        }
        function serialize(children, callback) {
            for (var output = "", i2 = 0; i2 < children.length; i2++) output += callback(children[i2], i2, children, callback) || "";
            return output;
        }
        function stringify(element, index2, children, callback) {
            switch (element.type) {
              case LAYER:
                if (element.children.length) break;

              case IMPORT:
              case DECLARATION:
                return element.return = element.return || element.value;

              case COMMENT:
                return "";

              case KEYFRAMES:
                return element.return = element.value + "{" + serialize(element.children, callback) + "}";

              case RULESET:
                if (!strlen(element.value = element.props.join(","))) return "";
            }
            return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
        }
        const ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path", CSS_FILE_STYLE = "_FILE_STYLE__";
        let cachePathMap, fromCSSFile = !0;
        function prepare() {
            var _a;
            if (!cachePathMap && (cachePathMap = {}, canUseDom$1())) {
                const div = document.createElement("div");
                div.className = ATTR_CACHE_MAP, div.style.position = "fixed", div.style.visibility = "hidden", 
                div.style.top = "-9999px", document.body.appendChild(div);
                let content = getComputedStyle(div).content || "";
                content = content.replace(/^"/, "").replace(/"$/, ""), content.split(";").forEach((item => {
                    const [path, hash] = item.split(":");
                    cachePathMap[path] = hash;
                }));
                const inlineMapStyle = document.querySelector(`style[${ATTR_CACHE_MAP}]`);
                inlineMapStyle && (fromCSSFile = !1, null === (_a = inlineMapStyle.parentNode) || void 0 === _a || _a.removeChild(inlineMapStyle)), 
                document.body.removeChild(div);
            }
        }
        function existPath(path) {
            return prepare(), !!cachePathMap[path];
        }
        function getStyleAndHash(path) {
            const hash = cachePathMap[path];
            let styleStr = null;
            if (hash && canUseDom$1()) if (fromCSSFile) styleStr = CSS_FILE_STYLE; else {
                const style = document.querySelector(`style[${ATTR_MARK}="${cachePathMap[path]}"]`);
                style ? styleStr = style.innerHTML : delete cachePathMap[path];
            }
            return [ styleStr, hash ];
        }
        const isClientSide = canUseDom$1(), SKIP_CHECK = "_skip_check_", MULTI_VALUE = "_multi_value_";
        function normalizeStyle(styleStr) {
            return serialize(compile(styleStr), stringify).replace(/\{%%%\:[^;];}/g, ";");
        }
        function isCompoundCSSProperty(value) {
            return "object" == typeof value && value && (SKIP_CHECK in value || MULTI_VALUE in value);
        }
        function injectSelectorHash(key2, hashId, hashPriority) {
            if (!hashId) return key2;
            const hashClassName = `.${hashId}`, hashSelector = "low" === hashPriority ? `:where(${hashClassName})` : hashClassName;
            return key2.split(",").map((k2 => {
                var _a;
                const fullPath = k2.trim().split(/\s+/);
                let firstPath = fullPath[0] || "";
                const htmlElement = (null === (_a = firstPath.match(/^\w+/)) || void 0 === _a ? void 0 : _a[0]) || "";
                return firstPath = `${htmlElement}${hashSelector}${firstPath.slice(htmlElement.length)}`, 
                [ firstPath, ...fullPath.slice(1) ].join(" ");
            })).join(",");
        }
        const globalEffectStyleKeys = new Set, parseStyle = function(interpolation) {
            let config = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, {root: root2, injectHash: injectHash, parentSelectors: parentSelectors} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                root: !0,
                parentSelectors: []
            };
            const {hashId: hashId, layer: layer, path: path, hashPriority: hashPriority, transformers: transformers = [], linters: linters = []} = config;
            let styleStr = "", effectStyle = {};
            function parseKeyframes(keyframes) {
                const animationName = keyframes.getName(hashId);
                if (!effectStyle[animationName]) {
                    const [parsedStr] = parseStyle(keyframes.style, config, {
                        root: !1,
                        parentSelectors: parentSelectors
                    });
                    effectStyle[animationName] = `@keyframes ${keyframes.getName(hashId)}${parsedStr}`;
                }
            }
            function flattenList(list) {
                let fullList = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                return list.forEach((item => {
                    Array.isArray(item) ? flattenList(item, fullList) : item && fullList.push(item);
                })), fullList;
            }
            if (flattenList(Array.isArray(interpolation) ? interpolation : [ interpolation ]).forEach((originStyle => {
                const style = "string" != typeof originStyle || root2 ? originStyle : {};
                if ("string" == typeof style) styleStr += `${style}\n`; else if (style._keyframe) parseKeyframes(style); else {
                    const mergedStyle = transformers.reduce(((prev2, trans) => {
                        var _a;
                        return (null === (_a = null == trans ? void 0 : trans.visit) || void 0 === _a ? void 0 : _a.call(trans, prev2)) || prev2;
                    }), style);
                    Object.keys(mergedStyle).forEach((key2 => {
                        var _a;
                        const value = mergedStyle[key2];
                        if ("object" != typeof value || !value || "animationName" === key2 && value._keyframe || isCompoundCSSProperty(value)) {
                            let appendStyle = function(cssKey, cssValue) {
                                const styleName = cssKey.replace(/[A-Z]/g, (match2 => `-${match2.toLowerCase()}`));
                                let formatValue = cssValue;
                                unitlessKeys[cssKey] || "number" != typeof formatValue || 0 === formatValue || (formatValue = `${formatValue}px`), 
                                "animationName" === cssKey && (null == cssValue ? void 0 : cssValue._keyframe) && (parseKeyframes(cssValue), 
                                formatValue = cssValue.getName(hashId)), styleStr += `${styleName}:${formatValue};`;
                            };
                            const actualValue = null !== (_a = null == value ? void 0 : value.value) && void 0 !== _a ? _a : value;
                            "object" == typeof value && (null == value ? void 0 : value[MULTI_VALUE]) && Array.isArray(actualValue) ? actualValue.forEach((item => {
                                appendStyle(key2, item);
                            })) : appendStyle(key2, actualValue);
                        } else {
                            let subInjectHash = !1, mergedKey = key2.trim(), nextRoot = !1;
                            (root2 || injectHash) && hashId ? mergedKey.startsWith("@") ? subInjectHash = !0 : mergedKey = injectSelectorHash(key2, hashId, hashPriority) : !root2 || hashId || "&" !== mergedKey && "" !== mergedKey || (mergedKey = "", 
                            nextRoot = !0);
                            const [parsedStr, childEffectStyle] = parseStyle(value, config, {
                                root: nextRoot,
                                injectHash: subInjectHash,
                                parentSelectors: [ ...parentSelectors, mergedKey ]
                            });
                            effectStyle = _extends$1(_extends$1({}, effectStyle), childEffectStyle), styleStr += `${mergedKey}${parsedStr}`;
                        }
                    }));
                }
            })), root2) {
                if (layer && supportLayer()) {
                    const layerCells = layer.split(","), layerName = layerCells[layerCells.length - 1].trim();
                    styleStr = `@layer ${layerName} {${styleStr}}`, layerCells.length > 1 && (styleStr = `@layer ${layer}{%%%:%}${styleStr}`);
                }
            } else styleStr = `{${styleStr}}`;
            return [ styleStr, effectStyle ];
        };
        function uniqueHash(path, styleStr) {
            return murmur2(`${path.join("%")}${styleStr}`);
        }
        function useStyleRegister(info, styleFn) {
            const styleContext = useStyleInject(), tokenKey = computed((() => info.value.token._tokenKey)), fullPath = computed((() => [ tokenKey.value, ...info.value.path ]));
            let isMergedClientSide = isClientSide;
            return useClientCache("style", fullPath, (() => {
                const {path: path, hashId: hashId, layer: layer, nonce: nonce, clientOnly: clientOnly, order: order = 0} = info.value, cachePath = fullPath.value.join("|");
                if (existPath(cachePath)) {
                    const [inlineCacheStyleStr, styleHash] = getStyleAndHash(cachePath);
                    if (inlineCacheStyleStr) return [ inlineCacheStyleStr, tokenKey.value, styleHash, {}, clientOnly, order ];
                }
                const styleObj = styleFn(), {hashPriority: hashPriority, container: container, transformers: transformers, linters: linters, cache: cache} = styleContext.value, [parsedStyle, effectStyle] = parseStyle(styleObj, {
                    hashId: hashId,
                    hashPriority: hashPriority,
                    layer: layer,
                    path: path.join("-"),
                    transformers: transformers,
                    linters: linters
                }), styleStr = normalizeStyle(parsedStyle), styleId = uniqueHash(fullPath.value, styleStr);
                if (isMergedClientSide) {
                    const mergedCSSConfig = {
                        mark: ATTR_MARK,
                        prepend: "queue",
                        attachTo: container,
                        priority: order
                    }, nonceStr = "function" == typeof nonce ? nonce() : nonce;
                    nonceStr && (mergedCSSConfig.csp = {
                        nonce: nonceStr
                    });
                    const style = updateCSS$1(styleStr, styleId, mergedCSSConfig);
                    style[CSS_IN_JS_INSTANCE] = cache.instanceId, style.setAttribute(ATTR_TOKEN, tokenKey.value), 
                    Object.keys(effectStyle).forEach((effectKey => {
                        globalEffectStyleKeys.has(effectKey) || (globalEffectStyleKeys.add(effectKey), updateCSS$1(normalizeStyle(effectStyle[effectKey]), `_effect-${effectKey}`, {
                            mark: ATTR_MARK,
                            prepend: "queue",
                            attachTo: container
                        }));
                    }));
                }
                return [ styleStr, tokenKey.value, styleId, effectStyle, clientOnly, order ];
            }), ((_ref, fromHMR) => {
                let [, , styleId] = _ref;
                (fromHMR || styleContext.value.autoClear) && isClientSide && removeCSS(styleId, {
                    mark: ATTR_MARK
                });
            })), node2 => node2;
        }
        class Keyframe {
            constructor(name, style) {
                this._keyframe = !0, this.name = name, this.style = style;
            }
            getName() {
                let hashId = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                return hashId ? `${hashId}-${this.name}` : this.name;
            }
        }
        const version = "4.2.3", PresetColors = [ "blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold" ];
        function bound01(n2, max) {
            isOnePointZero(n2) && (n2 = "100%");
            var isPercent = isPercentage(n2);
            return n2 = 360 === max ? n2 : Math.min(max, Math.max(0, parseFloat(n2))), isPercent && (n2 = parseInt(String(n2 * max), 10) / 100), 
            Math.abs(n2 - max) < 1e-6 ? 1 : n2 = 360 === max ? (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max)) : n2 % max / parseFloat(String(max));
        }
        function clamp01(val) {
            return Math.min(1, Math.max(0, val));
        }
        function isOnePointZero(n2) {
            return "string" == typeof n2 && -1 !== n2.indexOf(".") && 1 === parseFloat(n2);
        }
        function isPercentage(n2) {
            return "string" == typeof n2 && -1 !== n2.indexOf("%");
        }
        function boundAlpha(a2) {
            return a2 = parseFloat(a2), (isNaN(a2) || a2 < 0 || a2 > 1) && (a2 = 1), a2;
        }
        function convertToPercentage(n2) {
            return n2 <= 1 ? "".concat(100 * Number(n2), "%") : n2;
        }
        function pad2(c2) {
            return 1 === c2.length ? "0" + c2 : String(c2);
        }
        function rgbToRgb(r2, g2, b2) {
            return {
                r: 255 * bound01(r2, 255),
                g: 255 * bound01(g2, 255),
                b: 255 * bound01(b2, 255)
            };
        }
        function rgbToHsl(r2, g2, b2) {
            r2 = bound01(r2, 255), g2 = bound01(g2, 255), b2 = bound01(b2, 255);
            var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2), h2 = 0, s2 = 0, l2 = (max + min) / 2;
            if (max === min) s2 = 0, h2 = 0; else {
                var d2 = max - min;
                switch (s2 = l2 > .5 ? d2 / (2 - max - min) : d2 / (max + min), max) {
                  case r2:
                    h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
                    break;

                  case g2:
                    h2 = (b2 - r2) / d2 + 2;
                    break;

                  case b2:
                    h2 = (r2 - g2) / d2 + 4;
                }
                h2 /= 6;
            }
            return {
                h: h2,
                s: s2,
                l: l2
            };
        }
        function hue2rgb(p2, q2, t2) {
            return t2 < 0 && (t2 += 1), t2 > 1 && (t2 -= 1), t2 < 1 / 6 ? p2 + 6 * t2 * (q2 - p2) : t2 < .5 ? q2 : t2 < 2 / 3 ? p2 + (q2 - p2) * (2 / 3 - t2) * 6 : p2;
        }
        function hslToRgb(h2, s2, l2) {
            var r2, g2, b2;
            if (h2 = bound01(h2, 360), s2 = bound01(s2, 100), l2 = bound01(l2, 100), 0 === s2) g2 = l2, 
            b2 = l2, r2 = l2; else {
                var q2 = l2 < .5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2, p2 = 2 * l2 - q2;
                r2 = hue2rgb(p2, q2, h2 + 1 / 3), g2 = hue2rgb(p2, q2, h2), b2 = hue2rgb(p2, q2, h2 - 1 / 3);
            }
            return {
                r: 255 * r2,
                g: 255 * g2,
                b: 255 * b2
            };
        }
        function rgbToHsv(r2, g2, b2) {
            r2 = bound01(r2, 255), g2 = bound01(g2, 255), b2 = bound01(b2, 255);
            var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2), h2 = 0, v2 = max, d2 = max - min, s2 = 0 === max ? 0 : d2 / max;
            if (max === min) h2 = 0; else {
                switch (max) {
                  case r2:
                    h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
                    break;

                  case g2:
                    h2 = (b2 - r2) / d2 + 2;
                    break;

                  case b2:
                    h2 = (r2 - g2) / d2 + 4;
                }
                h2 /= 6;
            }
            return {
                h: h2,
                s: s2,
                v: v2
            };
        }
        function hsvToRgb(h2, s2, v2) {
            h2 = 6 * bound01(h2, 360), s2 = bound01(s2, 100), v2 = bound01(v2, 100);
            var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i2 % 6;
            return {
                r: 255 * [ v2, q2, p2, p2, t2, v2 ][mod],
                g: 255 * [ t2, v2, v2, q2, p2, p2 ][mod],
                b: 255 * [ p2, p2, t2, v2, v2, q2 ][mod]
            };
        }
        function rgbToHex(r2, g2, b2, allow3Char) {
            var hex = [ pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)) ];
            return allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) : hex.join("");
        }
        function rgbaToHex(r2, g2, b2, a2, allow4Char) {
            var hex = [ pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a2)) ];
            return allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1)) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0) : hex.join("");
        }
        function convertDecimalToHex(d2) {
            return Math.round(255 * parseFloat(d2)).toString(16);
        }
        function convertHexToDecimal(h2) {
            return parseIntFromHex(h2) / 255;
        }
        function parseIntFromHex(val) {
            return parseInt(val, 16);
        }
        function numberInputToObject(color) {
            return {
                r: color >> 16,
                g: (65280 & color) >> 8,
                b: 255 & color
            };
        }
        var names = {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#dcdcdc",
            ghostwhite: "#f8f8ff",
            goldenrod: "#daa520",
            gold: "#ffd700",
            gray: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavenderblush: "#fff0f5",
            lavender: "#e6e6fa",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrodyellow: "#fafad2",
            lightgray: "#d3d3d3",
            lightgreen: "#90ee90",
            lightgrey: "#d3d3d3",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32cd32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370db",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdf5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#db7093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            rebeccapurple: "#663399",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            skyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
        };
        function inputToRGB(color) {
            var rgb = {
                r: 0,
                g: 0,
                b: 0
            }, a2 = 1, s2 = null, v2 = null, l2 = null, ok = !1, format2 = !1;
            return "string" == typeof color && (color = stringInputToObject(color)), "object" == typeof color && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = rgbToRgb(color.r, color.g, color.b), 
            ok = !0, format2 = "%" === String(color.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s2 = convertToPercentage(color.s), 
            v2 = convertToPercentage(color.v), rgb = hsvToRgb(color.h, s2, v2), ok = !0, format2 = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s2 = convertToPercentage(color.s), 
            l2 = convertToPercentage(color.l), rgb = hslToRgb(color.h, s2, l2), ok = !0, format2 = "hsl"), 
            Object.prototype.hasOwnProperty.call(color, "a") && (a2 = color.a)), a2 = boundAlpha(a2), 
            {
                ok: ok,
                format: color.format || format2,
                r: Math.min(255, Math.max(rgb.r, 0)),
                g: Math.min(255, Math.max(rgb.g, 0)),
                b: Math.min(255, Math.max(rgb.b, 0)),
                a: a2
            };
        }
        var CSS_INTEGER = "[-\\+]?\\d+%?", CSS_UNIT = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat(CSS_INTEGER, ")"), PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), matchers = {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
        function stringInputToObject(color) {
            if (0 === (color = color.trim().toLowerCase()).length) return !1;
            var named = !1;
            if (names[color]) color = names[color], named = !0; else if ("transparent" === color) return {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                format: "name"
            };
            var match2 = matchers.rgb.exec(color);
            return match2 ? {
                r: match2[1],
                g: match2[2],
                b: match2[3]
            } : (match2 = matchers.rgba.exec(color)) ? {
                r: match2[1],
                g: match2[2],
                b: match2[3],
                a: match2[4]
            } : (match2 = matchers.hsl.exec(color)) ? {
                h: match2[1],
                s: match2[2],
                l: match2[3]
            } : (match2 = matchers.hsla.exec(color)) ? {
                h: match2[1],
                s: match2[2],
                l: match2[3],
                a: match2[4]
            } : (match2 = matchers.hsv.exec(color)) ? {
                h: match2[1],
                s: match2[2],
                v: match2[3]
            } : (match2 = matchers.hsva.exec(color)) ? {
                h: match2[1],
                s: match2[2],
                v: match2[3],
                a: match2[4]
            } : (match2 = matchers.hex8.exec(color)) ? {
                r: parseIntFromHex(match2[1]),
                g: parseIntFromHex(match2[2]),
                b: parseIntFromHex(match2[3]),
                a: convertHexToDecimal(match2[4]),
                format: named ? "name" : "hex8"
            } : (match2 = matchers.hex6.exec(color)) ? {
                r: parseIntFromHex(match2[1]),
                g: parseIntFromHex(match2[2]),
                b: parseIntFromHex(match2[3]),
                format: named ? "name" : "hex"
            } : (match2 = matchers.hex4.exec(color)) ? {
                r: parseIntFromHex(match2[1] + match2[1]),
                g: parseIntFromHex(match2[2] + match2[2]),
                b: parseIntFromHex(match2[3] + match2[3]),
                a: convertHexToDecimal(match2[4] + match2[4]),
                format: named ? "name" : "hex8"
            } : !!(match2 = matchers.hex3.exec(color)) && {
                r: parseIntFromHex(match2[1] + match2[1]),
                g: parseIntFromHex(match2[2] + match2[2]),
                b: parseIntFromHex(match2[3] + match2[3]),
                format: named ? "name" : "hex"
            };
        }
        function isValidCSSUnit(color) {
            return Boolean(matchers.CSS_UNIT.exec(String(color)));
        }
        var TinyColor = function() {
            function TinyColor2(color, opts) {
                var _a;
                if (void 0 === color && (color = ""), void 0 === opts && (opts = {}), color instanceof TinyColor2) return color;
                "number" == typeof color && (color = numberInputToObject(color)), this.originalInput = color;
                var rgb = inputToRGB(color);
                this.originalInput = color, this.r = rgb.r, this.g = rgb.g, this.b = rgb.b, this.a = rgb.a, 
                this.roundA = Math.round(100 * this.a) / 100, this.format = null !== (_a = opts.format) && void 0 !== _a ? _a : rgb.format, 
                this.gradientType = opts.gradientType, this.r < 1 && (this.r = Math.round(this.r)), 
                this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), 
                this.isValid = rgb.ok;
            }
            return TinyColor2.prototype.isDark = function() {
                return this.getBrightness() < 128;
            }, TinyColor2.prototype.isLight = function() {
                return !this.isDark();
            }, TinyColor2.prototype.getBrightness = function() {
                var rgb = this.toRgb();
                return (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1e3;
            }, TinyColor2.prototype.getLuminance = function() {
                var rgb = this.toRgb(), RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255;
                return .2126 * (RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4)) + .7152 * (GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4)) + .0722 * (BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4));
            }, TinyColor2.prototype.getAlpha = function() {
                return this.a;
            }, TinyColor2.prototype.setAlpha = function(alpha) {
                return this.a = boundAlpha(alpha), this.roundA = Math.round(100 * this.a) / 100, 
                this;
            }, TinyColor2.prototype.isMonochrome = function() {
                return 0 === this.toHsl().s;
            }, TinyColor2.prototype.toHsv = function() {
                var hsv = rgbToHsv(this.r, this.g, this.b);
                return {
                    h: 360 * hsv.h,
                    s: hsv.s,
                    v: hsv.v,
                    a: this.a
                };
            }, TinyColor2.prototype.toHsvString = function() {
                var hsv = rgbToHsv(this.r, this.g, this.b), h2 = Math.round(360 * hsv.h), s2 = Math.round(100 * hsv.s), v2 = Math.round(100 * hsv.v);
                return 1 === this.a ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
            }, TinyColor2.prototype.toHsl = function() {
                var hsl = rgbToHsl(this.r, this.g, this.b);
                return {
                    h: 360 * hsl.h,
                    s: hsl.s,
                    l: hsl.l,
                    a: this.a
                };
            }, TinyColor2.prototype.toHslString = function() {
                var hsl = rgbToHsl(this.r, this.g, this.b), h2 = Math.round(360 * hsl.h), s2 = Math.round(100 * hsl.s), l2 = Math.round(100 * hsl.l);
                return 1 === this.a ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
            }, TinyColor2.prototype.toHex = function(allow3Char) {
                return void 0 === allow3Char && (allow3Char = !1), rgbToHex(this.r, this.g, this.b, allow3Char);
            }, TinyColor2.prototype.toHexString = function(allow3Char) {
                return void 0 === allow3Char && (allow3Char = !1), "#" + this.toHex(allow3Char);
            }, TinyColor2.prototype.toHex8 = function(allow4Char) {
                return void 0 === allow4Char && (allow4Char = !1), rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
            }, TinyColor2.prototype.toHex8String = function(allow4Char) {
                return void 0 === allow4Char && (allow4Char = !1), "#" + this.toHex8(allow4Char);
            }, TinyColor2.prototype.toHexShortString = function(allowShortChar) {
                return void 0 === allowShortChar && (allowShortChar = !1), 1 === this.a ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
            }, TinyColor2.prototype.toRgb = function() {
                return {
                    r: Math.round(this.r),
                    g: Math.round(this.g),
                    b: Math.round(this.b),
                    a: this.a
                };
            }, TinyColor2.prototype.toRgbString = function() {
                var r2 = Math.round(this.r), g2 = Math.round(this.g), b2 = Math.round(this.b);
                return 1 === this.a ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
            }, TinyColor2.prototype.toPercentageRgb = function() {
                var fmt = function(x2) {
                    return "".concat(Math.round(100 * bound01(x2, 255)), "%");
                };
                return {
                    r: fmt(this.r),
                    g: fmt(this.g),
                    b: fmt(this.b),
                    a: this.a
                };
            }, TinyColor2.prototype.toPercentageRgbString = function() {
                var rnd = function(x2) {
                    return Math.round(100 * bound01(x2, 255));
                };
                return 1 === this.a ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
            }, TinyColor2.prototype.toName = function() {
                if (0 === this.a) return "transparent";
                if (this.a < 1) return !1;
                for (var hex = "#" + rgbToHex(this.r, this.g, this.b, !1), _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
                    var _b = _a[_i], key2 = _b[0];
                    if (hex === _b[1]) return key2;
                }
                return !1;
            }, TinyColor2.prototype.toString = function(format2) {
                var formatSet = Boolean(format2);
                format2 = null != format2 ? format2 : this.format;
                var formattedString = !1, hasAlpha = this.a < 1 && this.a >= 0;
                return formatSet || !hasAlpha || !format2.startsWith("hex") && "name" !== format2 ? ("rgb" === format2 && (formattedString = this.toRgbString()), 
                "prgb" === format2 && (formattedString = this.toPercentageRgbString()), "hex" !== format2 && "hex6" !== format2 || (formattedString = this.toHexString()), 
                "hex3" === format2 && (formattedString = this.toHexString(!0)), "hex4" === format2 && (formattedString = this.toHex8String(!0)), 
                "hex8" === format2 && (formattedString = this.toHex8String()), "name" === format2 && (formattedString = this.toName()), 
                "hsl" === format2 && (formattedString = this.toHslString()), "hsv" === format2 && (formattedString = this.toHsvString()), 
                formattedString || this.toHexString()) : "name" === format2 && 0 === this.a ? this.toName() : this.toRgbString();
            }, TinyColor2.prototype.toNumber = function() {
                return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
            }, TinyColor2.prototype.clone = function() {
                return new TinyColor2(this.toString());
            }, TinyColor2.prototype.lighten = function(amount) {
                void 0 === amount && (amount = 10);
                var hsl = this.toHsl();
                return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), new TinyColor2(hsl);
            }, TinyColor2.prototype.brighten = function(amount) {
                void 0 === amount && (amount = 10);
                var rgb = this.toRgb();
                return rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(-amount / 100 * 255))), 
                rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(-amount / 100 * 255))), rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(-amount / 100 * 255))), 
                new TinyColor2(rgb);
            }, TinyColor2.prototype.darken = function(amount) {
                void 0 === amount && (amount = 10);
                var hsl = this.toHsl();
                return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), new TinyColor2(hsl);
            }, TinyColor2.prototype.tint = function(amount) {
                return void 0 === amount && (amount = 10), this.mix("white", amount);
            }, TinyColor2.prototype.shade = function(amount) {
                return void 0 === amount && (amount = 10), this.mix("black", amount);
            }, TinyColor2.prototype.desaturate = function(amount) {
                void 0 === amount && (amount = 10);
                var hsl = this.toHsl();
                return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), new TinyColor2(hsl);
            }, TinyColor2.prototype.saturate = function(amount) {
                void 0 === amount && (amount = 10);
                var hsl = this.toHsl();
                return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), new TinyColor2(hsl);
            }, TinyColor2.prototype.greyscale = function() {
                return this.desaturate(100);
            }, TinyColor2.prototype.spin = function(amount) {
                var hsl = this.toHsl(), hue = (hsl.h + amount) % 360;
                return hsl.h = hue < 0 ? 360 + hue : hue, new TinyColor2(hsl);
            }, TinyColor2.prototype.mix = function(color, amount) {
                void 0 === amount && (amount = 50);
                var rgb1 = this.toRgb(), rgb2 = new TinyColor2(color).toRgb(), p2 = amount / 100;
                return new TinyColor2({
                    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
                    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
                    b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
                    a: (rgb2.a - rgb1.a) * p2 + rgb1.a
                });
            }, TinyColor2.prototype.analogous = function(results, slices) {
                void 0 === results && (results = 6), void 0 === slices && (slices = 30);
                var hsl = this.toHsl(), part = 360 / slices, ret = [ this ];
                for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) hsl.h = (hsl.h + part) % 360, 
                ret.push(new TinyColor2(hsl));
                return ret;
            }, TinyColor2.prototype.complement = function() {
                var hsl = this.toHsl();
                return hsl.h = (hsl.h + 180) % 360, new TinyColor2(hsl);
            }, TinyColor2.prototype.monochromatic = function(results) {
                void 0 === results && (results = 6);
                for (var hsv = this.toHsv(), h2 = hsv.h, s2 = hsv.s, v2 = hsv.v, res = [], modification = 1 / results; results--; ) res.push(new TinyColor2({
                    h: h2,
                    s: s2,
                    v: v2
                })), v2 = (v2 + modification) % 1;
                return res;
            }, TinyColor2.prototype.splitcomplement = function() {
                var hsl = this.toHsl(), h2 = hsl.h;
                return [ this, new TinyColor2({
                    h: (h2 + 72) % 360,
                    s: hsl.s,
                    l: hsl.l
                }), new TinyColor2({
                    h: (h2 + 216) % 360,
                    s: hsl.s,
                    l: hsl.l
                }) ];
            }, TinyColor2.prototype.onBackground = function(background) {
                var fg = this.toRgb(), bg = new TinyColor2(background).toRgb(), alpha = fg.a + bg.a * (1 - fg.a);
                return new TinyColor2({
                    r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
                    g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
                    b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
                    a: alpha
                });
            }, TinyColor2.prototype.triad = function() {
                return this.polyad(3);
            }, TinyColor2.prototype.tetrad = function() {
                return this.polyad(4);
            }, TinyColor2.prototype.polyad = function(n2) {
                for (var hsl = this.toHsl(), h2 = hsl.h, result = [ this ], increment = 360 / n2, i2 = 1; i2 < n2; i2++) result.push(new TinyColor2({
                    h: (h2 + i2 * increment) % 360,
                    s: hsl.s,
                    l: hsl.l
                }));
                return result;
            }, TinyColor2.prototype.equals = function(color) {
                return this.toRgbString() === new TinyColor2(color).toRgbString();
            }, TinyColor2;
        }(), hueStep = 2, saturationStep = .16, saturationStep2 = .05, brightnessStep1 = .05, brightnessStep2 = .15, lightColorCount = 5, darkColorCount = 4, darkColorMap = [ {
            index: 7,
            opacity: .15
        }, {
            index: 6,
            opacity: .25
        }, {
            index: 5,
            opacity: .3
        }, {
            index: 5,
            opacity: .45
        }, {
            index: 5,
            opacity: .65
        }, {
            index: 5,
            opacity: .85
        }, {
            index: 4,
            opacity: .9
        }, {
            index: 3,
            opacity: .95
        }, {
            index: 2,
            opacity: .97
        }, {
            index: 1,
            opacity: .98
        } ];
        function toHsv(_ref) {
            var hsv = rgbToHsv(_ref.r, _ref.g, _ref.b);
            return {
                h: 360 * hsv.h,
                s: hsv.s,
                v: hsv.v
            };
        }
        function toHex(_ref2) {
            var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
            return "#".concat(rgbToHex(r2, g2, b2, !1));
        }
        function mix$1(rgb1, rgb2, amount) {
            var p2 = amount / 100;
            return {
                r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
                g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
                b: (rgb2.b - rgb1.b) * p2 + rgb1.b
            };
        }
        function getHue(hsv, i2, light) {
            var hue;
            return (hue = Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240 ? light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2 : light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2) < 0 ? hue += 360 : hue >= 360 && (hue -= 360), 
            hue;
        }
        function getSaturation(hsv, i2, light) {
            return 0 === hsv.h && 0 === hsv.s ? hsv.s : ((saturation = light ? hsv.s - saturationStep * i2 : i2 === darkColorCount ? hsv.s + saturationStep : hsv.s + saturationStep2 * i2) > 1 && (saturation = 1), 
            light && i2 === lightColorCount && saturation > .1 && (saturation = .1), saturation < .06 && (saturation = .06), 
            Number(saturation.toFixed(2)));
            var saturation;
        }
        function getValue$2(hsv, i2, light) {
            var value;
            return (value = light ? hsv.v + brightnessStep1 * i2 : hsv.v - brightnessStep2 * i2) > 1 && (value = 1), 
            Number(value.toFixed(2));
        }
        function generate$1(color) {
            for (var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, patterns = [], pColor = inputToRGB(color), i2 = lightColorCount; i2 > 0; i2 -= 1) {
                var hsv = toHsv(pColor), colorString = toHex(inputToRGB({
                    h: getHue(hsv, i2, !0),
                    s: getSaturation(hsv, i2, !0),
                    v: getValue$2(hsv, i2, !0)
                }));
                patterns.push(colorString);
            }
            patterns.push(toHex(pColor));
            for (var _i = 1; _i <= darkColorCount; _i += 1) {
                var _hsv = toHsv(pColor), _colorString = toHex(inputToRGB({
                    h: getHue(_hsv, _i),
                    s: getSaturation(_hsv, _i),
                    v: getValue$2(_hsv, _i)
                }));
                patterns.push(_colorString);
            }
            return "dark" === opts.theme ? darkColorMap.map((function(_ref3) {
                var index2 = _ref3.index, opacity = _ref3.opacity;
                return toHex(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), 100 * opacity));
            })) : patterns;
        }
        var presetPrimaryColors = {
            red: "#F5222D",
            volcano: "#FA541C",
            orange: "#FA8C16",
            gold: "#FAAD14",
            yellow: "#FADB14",
            lime: "#A0D911",
            green: "#52C41A",
            cyan: "#13C2C2",
            blue: "#1890FF",
            geekblue: "#2F54EB",
            purple: "#722ED1",
            magenta: "#EB2F96",
            grey: "#666666"
        }, presetPalettes = {}, presetDarkPalettes = {};
        Object.keys(presetPrimaryColors).forEach((function(key2) {
            presetPalettes[key2] = generate$1(presetPrimaryColors[key2]), presetPalettes[key2].primary = presetPalettes[key2][5], 
            presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
                theme: "dark",
                backgroundColor: "#141414"
            }), presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
        }));
        var blue = presetPalettes.blue;
        const genControlHeight = token2 => {
            const {controlHeight: controlHeight} = token2;
            return {
                controlHeightSM: .75 * controlHeight,
                controlHeightXS: .5 * controlHeight,
                controlHeightLG: 1.25 * controlHeight
            };
        };
        function genSizeMapToken(token2) {
            const {sizeUnit: sizeUnit, sizeStep: sizeStep} = token2;
            return {
                sizeXXL: sizeUnit * (sizeStep + 8),
                sizeXL: sizeUnit * (sizeStep + 4),
                sizeLG: sizeUnit * (sizeStep + 2),
                sizeMD: sizeUnit * (sizeStep + 1),
                sizeMS: sizeUnit * sizeStep,
                size: sizeUnit * sizeStep,
                sizeSM: sizeUnit * (sizeStep - 1),
                sizeXS: sizeUnit * (sizeStep - 2),
                sizeXXS: sizeUnit * (sizeStep - 3)
            };
        }
        const defaultPresetColors = {
            blue: "#1677ff",
            purple: "#722ED1",
            cyan: "#13C2C2",
            green: "#52C41A",
            magenta: "#EB2F96",
            pink: "#eb2f96",
            red: "#F5222D",
            orange: "#FA8C16",
            yellow: "#FADB14",
            volcano: "#FA541C",
            geekblue: "#2F54EB",
            gold: "#FAAD14",
            lime: "#A0D911"
        }, seedToken = _extends$1(_extends$1({}, defaultPresetColors), {
            colorPrimary: "#1677ff",
            colorSuccess: "#52c41a",
            colorWarning: "#faad14",
            colorError: "#ff4d4f",
            colorInfo: "#1677ff",
            colorTextBase: "",
            colorBgBase: "",
            fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,\n'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n'Noto Color Emoji'",
            fontSize: 14,
            lineWidth: 1,
            lineType: "solid",
            motionUnit: .1,
            motionBase: 0,
            motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
            motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
            motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
            motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
            motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
            motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
            motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
            motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
            borderRadius: 6,
            sizeUnit: 4,
            sizeStep: 4,
            sizePopupArrow: 16,
            controlHeight: 32,
            zIndexBase: 0,
            zIndexPopupBase: 1e3,
            opacityImage: 1,
            wireframe: !1
        });
        function genColorMapToken(seed2, _ref) {
            let {generateColorPalettes: generateColorPalettes2, generateNeutralColorPalettes: generateNeutralColorPalettes2} = _ref;
            const {colorSuccess: colorSuccessBase, colorWarning: colorWarningBase, colorError: colorErrorBase, colorInfo: colorInfoBase, colorPrimary: colorPrimaryBase, colorBgBase: colorBgBase, colorTextBase: colorTextBase} = seed2, primaryColors = generateColorPalettes2(colorPrimaryBase), successColors = generateColorPalettes2(colorSuccessBase), warningColors = generateColorPalettes2(colorWarningBase), errorColors = generateColorPalettes2(colorErrorBase), infoColors = generateColorPalettes2(colorInfoBase);
            return _extends$1(_extends$1({}, generateNeutralColorPalettes2(colorBgBase, colorTextBase)), {
                colorPrimaryBg: primaryColors[1],
                colorPrimaryBgHover: primaryColors[2],
                colorPrimaryBorder: primaryColors[3],
                colorPrimaryBorderHover: primaryColors[4],
                colorPrimaryHover: primaryColors[5],
                colorPrimary: primaryColors[6],
                colorPrimaryActive: primaryColors[7],
                colorPrimaryTextHover: primaryColors[8],
                colorPrimaryText: primaryColors[9],
                colorPrimaryTextActive: primaryColors[10],
                colorSuccessBg: successColors[1],
                colorSuccessBgHover: successColors[2],
                colorSuccessBorder: successColors[3],
                colorSuccessBorderHover: successColors[4],
                colorSuccessHover: successColors[4],
                colorSuccess: successColors[6],
                colorSuccessActive: successColors[7],
                colorSuccessTextHover: successColors[8],
                colorSuccessText: successColors[9],
                colorSuccessTextActive: successColors[10],
                colorErrorBg: errorColors[1],
                colorErrorBgHover: errorColors[2],
                colorErrorBorder: errorColors[3],
                colorErrorBorderHover: errorColors[4],
                colorErrorHover: errorColors[5],
                colorError: errorColors[6],
                colorErrorActive: errorColors[7],
                colorErrorTextHover: errorColors[8],
                colorErrorText: errorColors[9],
                colorErrorTextActive: errorColors[10],
                colorWarningBg: warningColors[1],
                colorWarningBgHover: warningColors[2],
                colorWarningBorder: warningColors[3],
                colorWarningBorderHover: warningColors[4],
                colorWarningHover: warningColors[4],
                colorWarning: warningColors[6],
                colorWarningActive: warningColors[7],
                colorWarningTextHover: warningColors[8],
                colorWarningText: warningColors[9],
                colorWarningTextActive: warningColors[10],
                colorInfoBg: infoColors[1],
                colorInfoBgHover: infoColors[2],
                colorInfoBorder: infoColors[3],
                colorInfoBorderHover: infoColors[4],
                colorInfoHover: infoColors[4],
                colorInfo: infoColors[6],
                colorInfoActive: infoColors[7],
                colorInfoTextHover: infoColors[8],
                colorInfoText: infoColors[9],
                colorInfoTextActive: infoColors[10],
                colorBgMask: new TinyColor("#000").setAlpha(.45).toRgbString(),
                colorWhite: "#fff"
            });
        }
        const genRadius = radiusBase => {
            let radiusLG = radiusBase, radiusSM = radiusBase, radiusXS = radiusBase, radiusOuter = radiusBase;
            return radiusBase < 6 && radiusBase >= 5 ? radiusLG = radiusBase + 1 : radiusBase < 16 && radiusBase >= 6 ? radiusLG = radiusBase + 2 : radiusBase >= 16 && (radiusLG = 16), 
            radiusBase < 7 && radiusBase >= 5 ? radiusSM = 4 : radiusBase < 8 && radiusBase >= 7 ? radiusSM = 5 : radiusBase < 14 && radiusBase >= 8 ? radiusSM = 6 : radiusBase < 16 && radiusBase >= 14 ? radiusSM = 7 : radiusBase >= 16 && (radiusSM = 8), 
            radiusBase < 6 && radiusBase >= 2 ? radiusXS = 1 : radiusBase >= 6 && (radiusXS = 2), 
            radiusBase > 4 && radiusBase < 8 ? radiusOuter = 4 : radiusBase >= 8 && (radiusOuter = 6), 
            {
                borderRadius: radiusBase > 16 ? 16 : radiusBase,
                borderRadiusXS: radiusXS,
                borderRadiusSM: radiusSM,
                borderRadiusLG: radiusLG,
                borderRadiusOuter: radiusOuter
            };
        };
        function genCommonMapToken(token2) {
            const {motionUnit: motionUnit, motionBase: motionBase, borderRadius: borderRadius, lineWidth: lineWidth} = token2;
            return _extends$1({
                motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
                motionDurationMid: `${(motionBase + 2 * motionUnit).toFixed(1)}s`,
                motionDurationSlow: `${(motionBase + 3 * motionUnit).toFixed(1)}s`,
                lineWidthBold: lineWidth + 1
            }, genRadius(borderRadius));
        }
        const getAlphaColor$1 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString(), getSolidColor = (baseColor, brightness) => new TinyColor(baseColor).darken(brightness).toHexString(), generateColorPalettes = baseColor => {
            const colors = generate$1(baseColor);
            return {
                1: colors[0],
                2: colors[1],
                3: colors[2],
                4: colors[3],
                5: colors[4],
                6: colors[5],
                7: colors[6],
                8: colors[4],
                9: colors[5],
                10: colors[6]
            };
        }, generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
            const colorBgBase = bgBaseColor || "#fff", colorTextBase = textBaseColor || "#000";
            return {
                colorBgBase: colorBgBase,
                colorTextBase: colorTextBase,
                colorText: getAlphaColor$1(colorTextBase, .88),
                colorTextSecondary: getAlphaColor$1(colorTextBase, .65),
                colorTextTertiary: getAlphaColor$1(colorTextBase, .45),
                colorTextQuaternary: getAlphaColor$1(colorTextBase, .25),
                colorFill: getAlphaColor$1(colorTextBase, .15),
                colorFillSecondary: getAlphaColor$1(colorTextBase, .06),
                colorFillTertiary: getAlphaColor$1(colorTextBase, .04),
                colorFillQuaternary: getAlphaColor$1(colorTextBase, .02),
                colorBgLayout: getSolidColor(colorBgBase, 4),
                colorBgContainer: getSolidColor(colorBgBase, 0),
                colorBgElevated: getSolidColor(colorBgBase, 0),
                colorBgSpotlight: getAlphaColor$1(colorTextBase, .85),
                colorBorder: getSolidColor(colorBgBase, 15),
                colorBorderSecondary: getSolidColor(colorBgBase, 6)
            };
        };
        function getFontSizes(base) {
            const fontSizes = new Array(10).fill(null).map(((_2, index2) => {
                const i2 = index2 - 1, baseSize = base * Math.pow(2.71828, i2 / 5), intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
                return 2 * Math.floor(intSize / 2);
            }));
            return fontSizes[1] = base, fontSizes.map((size2 => ({
                size: size2,
                lineHeight: (size2 + 8) / size2
            })));
        }
        const genFontMapToken = fontSize => {
            const fontSizePairs = getFontSizes(fontSize), fontSizes = fontSizePairs.map((pair => pair.size)), lineHeights = fontSizePairs.map((pair => pair.lineHeight));
            return {
                fontSizeSM: fontSizes[0],
                fontSize: fontSizes[1],
                fontSizeLG: fontSizes[2],
                fontSizeXL: fontSizes[3],
                fontSizeHeading1: fontSizes[6],
                fontSizeHeading2: fontSizes[5],
                fontSizeHeading3: fontSizes[4],
                fontSizeHeading4: fontSizes[3],
                fontSizeHeading5: fontSizes[2],
                lineHeight: lineHeights[1],
                lineHeightLG: lineHeights[2],
                lineHeightSM: lineHeights[0],
                lineHeightHeading1: lineHeights[6],
                lineHeightHeading2: lineHeights[5],
                lineHeightHeading3: lineHeights[4],
                lineHeightHeading4: lineHeights[3],
                lineHeightHeading5: lineHeights[2]
            };
        };
        function derivative(token2) {
            const colorPalettes = Object.keys(defaultPresetColors).map((colorKey => {
                const colors = generate$1(token2[colorKey]);
                return new Array(10).fill(1).reduce(((prev2, _2, i2) => (prev2[`${colorKey}-${i2 + 1}`] = colors[i2], 
                prev2)), {});
            })).reduce(((prev2, cur) => prev2 = _extends$1(_extends$1({}, prev2), cur)), {});
            return _extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, token2), colorPalettes), genColorMapToken(token2, {
                generateColorPalettes: generateColorPalettes,
                generateNeutralColorPalettes: generateNeutralColorPalettes
            })), genFontMapToken(token2.fontSize)), genSizeMapToken(token2)), genControlHeight(token2)), genCommonMapToken(token2));
        }
        function isStableColor(color) {
            return color >= 0 && color <= 255;
        }
        function getAlphaColor(frontColor, backgroundColor) {
            const {r: fR, g: fG, b: fB, a: originAlpha} = new TinyColor(frontColor).toRgb();
            if (originAlpha < 1) return frontColor;
            const {r: bR, g: bG, b: bB} = new TinyColor(backgroundColor).toRgb();
            for (let fA = .01; fA <= 1; fA += .01) {
                const r2 = Math.round((fR - bR * (1 - fA)) / fA), g2 = Math.round((fG - bG * (1 - fA)) / fA), b2 = Math.round((fB - bB * (1 - fA)) / fA);
                if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) return new TinyColor({
                    r: r2,
                    g: g2,
                    b: b2,
                    a: Math.round(100 * fA) / 100
                }).toRgbString();
            }
            return new TinyColor({
                r: fR,
                g: fG,
                b: fB,
                a: 1
            }).toRgbString();
        }
        var __rest$m = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        function formatToken(derivativeToken) {
            const {override: override} = derivativeToken, restToken = __rest$m(derivativeToken, [ "override" ]), overrideTokens = _extends$1({}, override);
            Object.keys(seedToken).forEach((token2 => {
                delete overrideTokens[token2];
            }));
            const mergedToken = _extends$1(_extends$1({}, restToken), overrideTokens), screenXS = 480, screenSM = 576, screenMD = 768, screenLG = 992, screenXL = 1200, screenXXL = 1600, screenXXXL = 2e3;
            return _extends$1(_extends$1(_extends$1({}, mergedToken), {
                colorLink: mergedToken.colorInfoText,
                colorLinkHover: mergedToken.colorInfoHover,
                colorLinkActive: mergedToken.colorInfoActive,
                colorFillContent: mergedToken.colorFillSecondary,
                colorFillContentHover: mergedToken.colorFill,
                colorFillAlter: mergedToken.colorFillQuaternary,
                colorBgContainerDisabled: mergedToken.colorFillTertiary,
                colorBorderBg: mergedToken.colorBgContainer,
                colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
                colorTextPlaceholder: mergedToken.colorTextQuaternary,
                colorTextDisabled: mergedToken.colorTextQuaternary,
                colorTextHeading: mergedToken.colorText,
                colorTextLabel: mergedToken.colorTextSecondary,
                colorTextDescription: mergedToken.colorTextTertiary,
                colorTextLightSolid: mergedToken.colorWhite,
                colorHighlight: mergedToken.colorError,
                colorBgTextHover: mergedToken.colorFillSecondary,
                colorBgTextActive: mergedToken.colorFill,
                colorIcon: mergedToken.colorTextTertiary,
                colorIconHover: mergedToken.colorText,
                colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
                colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
                fontSizeIcon: mergedToken.fontSizeSM,
                lineWidth: mergedToken.lineWidth,
                controlOutlineWidth: 2 * mergedToken.lineWidth,
                controlInteractiveSize: mergedToken.controlHeight / 2,
                controlItemBgHover: mergedToken.colorFillTertiary,
                controlItemBgActive: mergedToken.colorPrimaryBg,
                controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
                controlItemBgActiveDisabled: mergedToken.colorFill,
                controlTmpOutline: mergedToken.colorFillQuaternary,
                controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
                lineType: mergedToken.lineType,
                borderRadius: mergedToken.borderRadius,
                borderRadiusXS: mergedToken.borderRadiusXS,
                borderRadiusSM: mergedToken.borderRadiusSM,
                borderRadiusLG: mergedToken.borderRadiusLG,
                fontWeightStrong: 600,
                opacityLoading: .65,
                linkDecoration: "none",
                linkHoverDecoration: "none",
                linkFocusDecoration: "none",
                controlPaddingHorizontal: 12,
                controlPaddingHorizontalSM: 8,
                paddingXXS: mergedToken.sizeXXS,
                paddingXS: mergedToken.sizeXS,
                paddingSM: mergedToken.sizeSM,
                padding: mergedToken.size,
                paddingMD: mergedToken.sizeMD,
                paddingLG: mergedToken.sizeLG,
                paddingXL: mergedToken.sizeXL,
                paddingContentHorizontalLG: mergedToken.sizeLG,
                paddingContentVerticalLG: mergedToken.sizeMS,
                paddingContentHorizontal: mergedToken.sizeMS,
                paddingContentVertical: mergedToken.sizeSM,
                paddingContentHorizontalSM: mergedToken.size,
                paddingContentVerticalSM: mergedToken.sizeXS,
                marginXXS: mergedToken.sizeXXS,
                marginXS: mergedToken.sizeXS,
                marginSM: mergedToken.sizeSM,
                margin: mergedToken.size,
                marginMD: mergedToken.sizeMD,
                marginLG: mergedToken.sizeLG,
                marginXL: mergedToken.sizeXL,
                marginXXL: mergedToken.sizeXXL,
                boxShadow: "\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ",
                boxShadowSecondary: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                boxShadowTertiary: "\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ",
                screenXS: screenXS,
                screenXSMin: screenXS,
                screenXSMax: screenSM - 1,
                screenSM: screenSM,
                screenSMMin: screenSM,
                screenSMMax: screenMD - 1,
                screenMD: screenMD,
                screenMDMin: screenMD,
                screenMDMax: screenLG - 1,
                screenLG: screenLG,
                screenLGMin: screenLG,
                screenLGMax: screenXL - 1,
                screenXL: screenXL,
                screenXLMin: screenXL,
                screenXLMax: screenXXL - 1,
                screenXXL: screenXXL,
                screenXXLMin: screenXXL,
                screenXXLMax: screenXXXL - 1,
                screenXXXL: screenXXXL,
                screenXXXLMin: screenXXXL,
                boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
                boxShadowCard: `\n      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},\n      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},\n      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}\n    `,
                boxShadowDrawerRight: "\n      -6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      -3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      -9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                boxShadowDrawerLeft: "\n      6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                boxShadowDrawerUp: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                boxShadowDrawerDown: "\n      0 -6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 -3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 -9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
                boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
                boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
                boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
            }), overrideTokens);
        }
        const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
            const unitWidth = width / 2, ax = 0, ay = unitWidth, bx = 1 * outerRadius / Math.sqrt(2), by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2)), cx = unitWidth - innerRadius * (1 / Math.sqrt(2)), cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2)), dx = 2 * unitWidth - cx, dy = cy, ex = 2 * unitWidth - bx, ey = by, fx = 2 * unitWidth - ax, fy = ay, shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2), polygonOffset = outerRadius * (Math.sqrt(2) - 1);
            return {
                pointerEvents: "none",
                width: width,
                height: width,
                overflow: "hidden",
                "&::after": {
                    content: '""',
                    position: "absolute",
                    width: shadowWidth,
                    height: shadowWidth,
                    bottom: 0,
                    insetInline: 0,
                    margin: "auto",
                    borderRadius: {
                        _skip_check_: !0,
                        value: `0 0 ${innerRadius}px 0`
                    },
                    transform: "translateY(50%) rotate(-135deg)",
                    boxShadow: boxShadow,
                    zIndex: 0,
                    background: "transparent"
                },
                "&::before": {
                    position: "absolute",
                    bottom: 0,
                    insetInlineStart: 0,
                    width: width,
                    height: width / 2,
                    background: bgColor,
                    clipPath: {
                        _multi_value_: !0,
                        value: [ `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')` ]
                    },
                    content: '""'
                }
            };
        };
        function genPresetColor(token2, genCss) {
            return PresetColors.reduce(((prev2, colorKey) => {
                const lightColor = token2[`${colorKey}-1`], lightBorderColor = token2[`${colorKey}-3`], darkColor = token2[`${colorKey}-6`], textColor = token2[`${colorKey}-7`];
                return _extends$1(_extends$1({}, prev2), genCss(colorKey, {
                    lightColor: lightColor,
                    lightBorderColor: lightBorderColor,
                    darkColor: darkColor,
                    textColor: textColor
                }));
            }), {});
        }
        const textEllipsis = {
            overflow: "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis"
        }, resetComponent = token2 => ({
            boxSizing: "border-box",
            margin: 0,
            padding: 0,
            color: token2.colorText,
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            listStyle: "none",
            fontFamily: token2.fontFamily
        }), resetIcon = () => ({
            display: "inline-flex",
            alignItems: "center",
            color: "inherit",
            fontStyle: "normal",
            lineHeight: 0,
            textAlign: "center",
            textTransform: "none",
            verticalAlign: "-0.125em",
            textRendering: "optimizeLegibility",
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale",
            "> *": {
                lineHeight: 1
            },
            svg: {
                display: "inline-block"
            }
        }), genLinkStyle = token2 => ({
            a: {
                color: token2.colorLink,
                textDecoration: token2.linkDecoration,
                backgroundColor: "transparent",
                outline: "none",
                cursor: "pointer",
                transition: `color ${token2.motionDurationSlow}`,
                "-webkit-text-decoration-skip": "objects",
                "&:hover": {
                    color: token2.colorLinkHover
                },
                "&:active": {
                    color: token2.colorLinkActive
                },
                "&:active,\n  &:hover": {
                    textDecoration: token2.linkHoverDecoration,
                    outline: 0
                },
                "&:focus": {
                    textDecoration: token2.linkFocusDecoration,
                    outline: 0
                },
                "&[disabled]": {
                    color: token2.colorTextDisabled,
                    cursor: "not-allowed"
                }
            }
        }), genCommonStyle = (token2, componentPrefixCls) => {
            const {fontFamily: fontFamily, fontSize: fontSize} = token2, rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
            return {
                [rootPrefixSelector]: {
                    fontFamily: fontFamily,
                    fontSize: fontSize,
                    boxSizing: "border-box",
                    "&::before, &::after": {
                        boxSizing: "border-box"
                    },
                    [rootPrefixSelector]: {
                        boxSizing: "border-box",
                        "&::before, &::after": {
                            boxSizing: "border-box"
                        }
                    }
                }
            };
        }, genFocusOutline = token2 => ({
            outline: `${token2.lineWidthBold}px solid ${token2.colorPrimaryBorder}`,
            outlineOffset: 1,
            transition: "outline-offset 0s, outline 0s"
        }), genFocusStyle = token2 => ({
            "&:focus-visible": _extends$1({}, genFocusOutline(token2))
        });
        function genComponentStyleHook(component, styleFn, getDefaultToken) {
            return _prefixCls => {
                const prefixCls = computed((() => null == _prefixCls ? void 0 : _prefixCls.value)), [theme, token2, hashId] = useToken(), {getPrefixCls: getPrefixCls, iconPrefixCls: iconPrefixCls} = useConfigContextInject(), rootPrefixCls = computed((() => getPrefixCls()));
                useStyleRegister(computed((() => ({
                    theme: theme.value,
                    token: token2.value,
                    hashId: hashId.value,
                    path: [ "Shared", rootPrefixCls.value ]
                }))), (() => [ {
                    "&": genLinkStyle(token2.value)
                } ]));
                return [ useStyleRegister(computed((() => ({
                    theme: theme.value,
                    token: token2.value,
                    hashId: hashId.value,
                    path: [ component, prefixCls.value, iconPrefixCls.value ]
                }))), (() => {
                    const {token: proxyToken, flush: flush} = statisticToken(token2.value), mergedComponentToken = _extends$1(_extends$1({}, "function" == typeof getDefaultToken ? getDefaultToken(proxyToken) : getDefaultToken), token2.value[component]), mergedToken = merge(proxyToken, {
                        componentCls: `.${prefixCls.value}`,
                        prefixCls: prefixCls.value,
                        iconCls: `.${iconPrefixCls.value}`,
                        antCls: `.${rootPrefixCls.value}`
                    }, mergedComponentToken), styleInterpolation = styleFn(mergedToken, {
                        hashId: hashId.value,
                        prefixCls: prefixCls.value,
                        rootPrefixCls: rootPrefixCls.value,
                        iconPrefixCls: iconPrefixCls.value,
                        overrideComponentToken: token2.value[component]
                    });
                    return flush(component, mergedComponentToken), [ genCommonStyle(token2.value, prefixCls.value), styleInterpolation ];
                })), hashId ];
            };
        }
        const enableStatistic = "undefined" != typeof CSSINJS_STATISTIC;
        let recording = !0;
        function merge() {
            for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) objs[_key] = arguments[_key];
            if (!enableStatistic) return _extends$1({}, ...objs);
            recording = !1;
            const ret = {};
            return objs.forEach((obj => {
                Object.keys(obj).forEach((key2 => {
                    Object.defineProperty(ret, key2, {
                        configurable: !0,
                        enumerable: !0,
                        get: () => obj[key2]
                    });
                }));
            })), recording = !0, ret;
        }
        function noop$2() {}
        function statisticToken(token2) {
            let tokenKeys2, proxy = token2, flush = noop$2;
            return enableStatistic && (tokenKeys2 = new Set, proxy = new Proxy(token2, {
                get: (obj, prop) => (recording && tokenKeys2.add(prop), obj[prop])
            }), flush = (componentName, componentToken) => {
                Array.from(tokenKeys2);
            }), {
                token: proxy,
                keys: tokenKeys2,
                flush: flush
            };
        }
        const defaultTheme = createTheme(derivative), defaultConfig = {
            token: seedToken,
            hashed: !0
        }, DesignTokenContextKey = Symbol("DesignTokenContext"), globalDesignTokenApi = shallowRef(), useDesignTokenProvider = value => {
            provide(DesignTokenContextKey, value), watch(value, (() => {
                globalDesignTokenApi.value = unref(value), triggerRef(globalDesignTokenApi);
            }), {
                immediate: !0,
                deep: !0
            });
        }, DesignTokenProvider = defineComponent({
            props: {
                value: objectType()
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                return useDesignTokenProvider(computed((() => props2.value))), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        });
        function useToken() {
            const designTokenContext = inject(DesignTokenContextKey, computed((() => globalDesignTokenApi.value || defaultConfig))), salt = computed((() => `${version}-${designTokenContext.value.hashed || ""}`)), mergedTheme = computed((() => designTokenContext.value.theme || defaultTheme)), cacheToken = useCacheToken(mergedTheme, computed((() => [ seedToken, designTokenContext.value.token ])), computed((() => ({
                salt: salt.value,
                override: _extends$1({
                    override: designTokenContext.value.token
                }, designTokenContext.value.components),
                formatToken: formatToken
            }))));
            return [ mergedTheme, computed((() => cacheToken.value[0])), computed((() => designTokenContext.value.hashed ? cacheToken.value[1] : "")) ];
        }
        const Empty$2 = defineComponent({
            compatConfig: {
                MODE: 3
            },
            setup() {
                const [, token2] = useToken(), themeStyle = computed((() => new TinyColor(token2.value.colorBgBase).toHsl().l < .5 ? {
                    opacity: .65
                } : {}));
                return () => createVNode("svg", {
                    style: themeStyle.value,
                    width: "184",
                    height: "152",
                    viewBox: "0 0 184 152",
                    xmlns: "http://www.w3.org/2000/svg"
                }, [ createVNode("g", {
                    fill: "none",
                    "fill-rule": "evenodd"
                }, [ createVNode("g", {
                    transform: "translate(24 31.67)"
                }, [ createVNode("ellipse", {
                    "fill-opacity": ".8",
                    fill: "#F5F5F7",
                    cx: "67.797",
                    cy: "106.89",
                    rx: "67.797",
                    ry: "12.668"
                }, null), createVNode("path", {
                    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
                    fill: "#AEB8C2"
                }, null), createVNode("path", {
                    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
                    fill: "url(#linearGradient-1)",
                    transform: "translate(13.56)"
                }, null), createVNode("path", {
                    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
                    fill: "#F5F5F7"
                }, null), createVNode("path", {
                    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
                    fill: "#DCE0E6"
                }, null) ]), createVNode("path", {
                    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
                    fill: "#DCE0E6"
                }, null), createVNode("g", {
                    transform: "translate(149.65 15.383)",
                    fill: "#FFF"
                }, [ createVNode("ellipse", {
                    cx: "20.654",
                    cy: "3.167",
                    rx: "2.849",
                    ry: "2.815"
                }, null), createVNode("path", {
                    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
                }, null) ]) ]) ]);
            }
        });
        Empty$2.PRESENTED_IMAGE_DEFAULT = !0;
        const Simple = defineComponent({
            compatConfig: {
                MODE: 3
            },
            setup() {
                const [, token2] = useToken(), color = computed((() => {
                    const {colorFill: colorFill, colorFillTertiary: colorFillTertiary, colorFillQuaternary: colorFillQuaternary, colorBgContainer: colorBgContainer} = token2.value;
                    return {
                        borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexString(),
                        shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
                        contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
                    };
                }));
                return () => createVNode("svg", {
                    width: "64",
                    height: "41",
                    viewBox: "0 0 64 41",
                    xmlns: "http://www.w3.org/2000/svg"
                }, [ createVNode("g", {
                    transform: "translate(0 1)",
                    fill: "none",
                    "fill-rule": "evenodd"
                }, [ createVNode("ellipse", {
                    fill: color.value.shadowColor,
                    cx: "32",
                    cy: "33",
                    rx: "32",
                    ry: "7"
                }, null), createVNode("g", {
                    "fill-rule": "nonzero",
                    stroke: color.value.borderColor
                }, [ createVNode("path", {
                    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
                }, null), createVNode("path", {
                    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
                    fill: color.value.contentColor
                }, null) ]) ]) ]);
            }
        });
        Simple.PRESENTED_IMAGE_SIMPLE = !0;
        const genSharedEmptyStyle = token2 => {
            const {componentCls: componentCls, margin: margin, marginXS: marginXS, marginXL: marginXL, fontSize: fontSize, lineHeight: lineHeight} = token2;
            return {
                [componentCls]: {
                    marginInline: marginXS,
                    fontSize: fontSize,
                    lineHeight: lineHeight,
                    textAlign: "center",
                    [`${componentCls}-image`]: {
                        height: token2.emptyImgHeight,
                        marginBottom: marginXS,
                        opacity: token2.opacityImage,
                        img: {
                            height: "100%"
                        },
                        svg: {
                            height: "100%",
                            margin: "auto"
                        }
                    },
                    [`${componentCls}-footer`]: {
                        marginTop: margin
                    },
                    "&-normal": {
                        marginBlock: marginXL,
                        color: token2.colorTextDisabled,
                        [`${componentCls}-image`]: {
                            height: token2.emptyImgHeightMD
                        }
                    },
                    "&-small": {
                        marginBlock: marginXS,
                        color: token2.colorTextDisabled,
                        [`${componentCls}-image`]: {
                            height: token2.emptyImgHeightSM
                        }
                    }
                }
            };
        }, useStyle$b = genComponentStyleHook("Empty", (token2 => {
            const {componentCls: componentCls, controlHeightLG: controlHeightLG} = token2, emptyToken = merge(token2, {
                emptyImgCls: `${componentCls}-img`,
                emptyImgHeight: 2.5 * controlHeightLG,
                emptyImgHeightMD: controlHeightLG,
                emptyImgHeightSM: .875 * controlHeightLG
            });
            return [ genSharedEmptyStyle(emptyToken) ];
        }));
        var __rest$l = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const defaultEmptyImg = createVNode(Empty$2, null, null), simpleEmptyImg = createVNode(Simple, null, null), Empty = defineComponent({
            name: "AEmpty",
            compatConfig: {
                MODE: 3
            },
            inheritAttrs: !1,
            props: (() => ({
                prefixCls: String,
                imageStyle: objectType(),
                image: anyType(),
                description: anyType()
            }))(),
            setup(props2, _ref) {
                let {slots: slots = {}, attrs: attrs} = _ref;
                const {direction: direction, prefixCls: prefixClsRef} = useConfigInject("empty", props2), [wrapSSR, hashId] = useStyle$b(prefixClsRef);
                return () => {
                    var _a, _b;
                    const prefixCls = prefixClsRef.value, _c = _extends$1(_extends$1({}, props2), attrs), {image: image = (null === (_a = slots.image) || void 0 === _a ? void 0 : _a.call(slots)) || defaultEmptyImg, description: description = (null === (_b = slots.description) || void 0 === _b ? void 0 : _b.call(slots)) || void 0, imageStyle: imageStyle, class: className = ""} = _c, restProps = __rest$l(_c, [ "image", "description", "imageStyle", "class" ]);
                    return wrapSSR(createVNode(LocaleReceiver, {
                        componentName: "Empty",
                        children: locale2 => {
                            const des = void 0 !== description ? description : locale2.description;
                            let imageNode = null;
                            return imageNode = "string" == typeof image ? createVNode("img", {
                                alt: "string" == typeof des ? des : "empty",
                                src: image
                            }, null) : image, createVNode("div", _objectSpread2$1({
                                class: classNames(prefixCls, className, hashId.value, {
                                    [`${prefixCls}-normal`]: image === simpleEmptyImg,
                                    [`${prefixCls}-rtl`]: "rtl" === direction.value
                                })
                            }, restProps), [ createVNode("div", {
                                class: `${prefixCls}-image`,
                                style: imageStyle
                            }, [ imageNode ]), des && createVNode("p", {
                                class: `${prefixCls}-description`
                            }, [ des ]), slots.default && createVNode("div", {
                                class: `${prefixCls}-footer`
                            }, [ filterEmpty(slots.default()) ]) ]);
                        }
                    }, null));
                };
            }
        });
        Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg, Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
        const Empty$1 = withInstall(Empty), DefaultRenderEmpty = props2 => {
            const {prefixCls: prefixCls} = useConfigInject("empty", props2);
            return (componentName => {
                switch (componentName) {
                  case "Table":
                  case "List":
                    return createVNode(Empty$1, {
                        image: Empty$1.PRESENTED_IMAGE_SIMPLE
                    }, null);

                  case "Select":
                  case "TreeSelect":
                  case "Cascader":
                  case "Transfer":
                  case "Mentions":
                    return createVNode(Empty$1, {
                        image: Empty$1.PRESENTED_IMAGE_SIMPLE,
                        class: `${prefixCls.value}-small`
                    }, null);

                  default:
                    return createVNode(Empty$1, null, null);
                }
            })(props2.componentName);
        };
        function renderEmpty(componentName) {
            return createVNode(DefaultRenderEmpty, {
                componentName: componentName
            }, null);
        }
        const SizeContextKey = Symbol("SizeContextKey"), useInjectSize = () => inject(SizeContextKey, ref(void 0)), useProviderSize = size2 => {
            const parentSize = useInjectSize();
            return provide(SizeContextKey, computed((() => size2.value || parentSize.value))), 
            size2;
        }, useConfigInject = (name, props2) => {
            const sizeContext = useInjectSize(), disabledContext = useInjectDisabled(), configProvider = inject(configProviderKey, _extends$1(_extends$1({}, defaultConfigProvider), {
                renderEmpty: name2 => h$1(DefaultRenderEmpty, {
                    componentName: name2
                })
            })), prefixCls = computed((() => configProvider.getPrefixCls(name, props2.prefixCls))), direction = computed((() => {
                var _a, _b;
                return null !== (_a = props2.direction) && void 0 !== _a ? _a : null === (_b = configProvider.direction) || void 0 === _b ? void 0 : _b.value;
            })), iconPrefixCls = computed((() => {
                var _a;
                return null !== (_a = props2.iconPrefixCls) && void 0 !== _a ? _a : configProvider.iconPrefixCls.value;
            })), rootPrefixCls = computed((() => configProvider.getPrefixCls())), autoInsertSpaceInButton = computed((() => {
                var _a;
                return null === (_a = configProvider.autoInsertSpaceInButton) || void 0 === _a ? void 0 : _a.value;
            })), renderEmpty2 = configProvider.renderEmpty, space = configProvider.space, pageHeader = configProvider.pageHeader, form = configProvider.form, getTargetContainer = computed((() => {
                var _a, _b;
                return null !== (_a = props2.getTargetContainer) && void 0 !== _a ? _a : null === (_b = configProvider.getTargetContainer) || void 0 === _b ? void 0 : _b.value;
            })), getPopupContainer = computed((() => {
                var _a, _b, _c;
                return null !== (_b = null !== (_a = props2.getContainer) && void 0 !== _a ? _a : props2.getPopupContainer) && void 0 !== _b ? _b : null === (_c = configProvider.getPopupContainer) || void 0 === _c ? void 0 : _c.value;
            })), dropdownMatchSelectWidth = computed((() => {
                var _a, _b;
                return null !== (_a = props2.dropdownMatchSelectWidth) && void 0 !== _a ? _a : null === (_b = configProvider.dropdownMatchSelectWidth) || void 0 === _b ? void 0 : _b.value;
            })), virtual = computed((() => {
                var _a;
                return (void 0 === props2.virtual ? !1 !== (null === (_a = configProvider.virtual) || void 0 === _a ? void 0 : _a.value) : !1 !== props2.virtual) && !1 !== dropdownMatchSelectWidth.value;
            })), size2 = computed((() => props2.size || sizeContext.value)), autocomplete = computed((() => {
                var _a, _b, _c;
                return null !== (_a = props2.autocomplete) && void 0 !== _a ? _a : null === (_c = null === (_b = configProvider.input) || void 0 === _b ? void 0 : _b.value) || void 0 === _c ? void 0 : _c.autocomplete;
            })), disabled = computed((() => {
                var _a;
                return null !== (_a = props2.disabled) && void 0 !== _a ? _a : disabledContext.value;
            })), csp = computed((() => {
                var _a;
                return null !== (_a = props2.csp) && void 0 !== _a ? _a : configProvider.csp;
            })), wave = computed((() => {
                var _a, _b;
                return null !== (_a = props2.wave) && void 0 !== _a ? _a : null === (_b = configProvider.wave) || void 0 === _b ? void 0 : _b.value;
            }));
            return {
                configProvider: configProvider,
                prefixCls: prefixCls,
                direction: direction,
                size: size2,
                getTargetContainer: getTargetContainer,
                getPopupContainer: getPopupContainer,
                space: space,
                pageHeader: pageHeader,
                form: form,
                autoInsertSpaceInButton: autoInsertSpaceInButton,
                renderEmpty: renderEmpty2,
                virtual: virtual,
                dropdownMatchSelectWidth: dropdownMatchSelectWidth,
                rootPrefixCls: rootPrefixCls,
                getPrefixCls: configProvider.getPrefixCls,
                autocomplete: autocomplete,
                csp: csp,
                iconPrefixCls: iconPrefixCls,
                disabled: disabled,
                select: configProvider.select,
                wave: wave
            };
        };
        function omit(obj, fields) {
            const shallowCopy = _extends$1({}, obj);
            for (let i2 = 0; i2 < fields.length; i2 += 1) {
                delete shallowCopy[fields[i2]];
            }
            return shallowCopy;
        }
        function t$1(t2) {
            return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
        }
        function e$1(t2, e2) {
            return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
        }
        function n$1(t2, n2) {
            if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
                var r2 = getComputedStyle(t2, null);
                return e$1(r2.overflowY, n2) || e$1(r2.overflowX, n2) || !!(e2 = function(t4) {
                    if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;
                    try {
                        return t4.ownerDocument.defaultView.frameElement;
                    } catch (t5) {
                        return null;
                    }
                }(t3 = t2)) && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
            }
            var t3, e2;
            return !1;
        }
        function r$1(t2, e2, n2, r2, i2, o2, l2, d2) {
            return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i2 : 0;
        }
        var i$1 = function(e2, i2) {
            var o2 = window, l2 = i2.scrollMode, d2 = i2.block, f2 = i2.inline, h2 = i2.boundary, u2 = i2.skipOverflowHiddenElements, s2 = "function" == typeof h2 ? h2 : function(t2) {
                return t2 !== h2;
            };
            if (!t$1(e2)) throw new TypeError("Invalid target");
            for (var a2, c2, g2 = document.scrollingElement || document.documentElement, p2 = [], m2 = e2; t$1(m2) && s2(m2); ) {
                if ((m2 = null == (c2 = (a2 = m2).parentElement) ? a2.getRootNode().host || null : c2) === g2) {
                    p2.push(m2);
                    break;
                }
                null != m2 && m2 === document.body && n$1(m2) && !n$1(document.documentElement) || null != m2 && n$1(m2, u2) && p2.push(m2);
            }
            for (var w2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, v2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, W = window.scrollX || pageXOffset, H = window.scrollY || pageYOffset, b2 = e2.getBoundingClientRect(), y2 = b2.height, E2 = b2.width, M2 = b2.top, V2 = b2.right, x2 = b2.bottom, I2 = b2.left, C = "start" === d2 || "nearest" === d2 ? M2 : "end" === d2 ? x2 : M2 + y2 / 2, R2 = "center" === f2 ? I2 + E2 / 2 : "end" === f2 ? V2 : I2, T2 = [], k2 = 0; k2 < p2.length; k2++) {
                var B2 = p2[k2], D2 = B2.getBoundingClientRect(), O2 = D2.height, X = D2.width, Y2 = D2.top, L2 = D2.right, S2 = D2.bottom, j2 = D2.left;
                if ("if-needed" === l2 && M2 >= 0 && I2 >= 0 && x2 <= v2 && V2 <= w2 && M2 >= Y2 && x2 <= S2 && I2 >= j2 && V2 <= L2) return T2;
                var N2 = getComputedStyle(B2), q2 = parseInt(N2.borderLeftWidth, 10), z2 = parseInt(N2.borderTopWidth, 10), A2 = parseInt(N2.borderRightWidth, 10), F2 = parseInt(N2.borderBottomWidth, 10), G = 0, J2 = 0, K = "offsetWidth" in B2 ? B2.offsetWidth - B2.clientWidth - q2 - A2 : 0, P2 = "offsetHeight" in B2 ? B2.offsetHeight - B2.clientHeight - z2 - F2 : 0, Q = "offsetWidth" in B2 ? 0 === B2.offsetWidth ? 0 : X / B2.offsetWidth : 0, U = "offsetHeight" in B2 ? 0 === B2.offsetHeight ? 0 : O2 / B2.offsetHeight : 0;
                if (g2 === B2) G = "start" === d2 ? C : "end" === d2 ? C - v2 : "nearest" === d2 ? r$1(H, H + v2, v2, z2, F2, H + C, H + C + y2, y2) : C - v2 / 2, 
                J2 = "start" === f2 ? R2 : "center" === f2 ? R2 - w2 / 2 : "end" === f2 ? R2 - w2 : r$1(W, W + w2, w2, q2, A2, W + R2, W + R2 + E2, E2), 
                G = Math.max(0, G + H), J2 = Math.max(0, J2 + W); else {
                    G = "start" === d2 ? C - Y2 - z2 : "end" === d2 ? C - S2 + F2 + P2 : "nearest" === d2 ? r$1(Y2, S2, O2, z2, F2 + P2, C, C + y2, y2) : C - (Y2 + O2 / 2) + P2 / 2, 
                    J2 = "start" === f2 ? R2 - j2 - q2 : "center" === f2 ? R2 - (j2 + X / 2) + K / 2 : "end" === f2 ? R2 - L2 + A2 + K : r$1(j2, L2, X, q2, A2 + K, R2, R2 + E2, E2);
                    var Z = B2.scrollLeft, $2 = B2.scrollTop;
                    C += $2 - (G = Math.max(0, Math.min($2 + G / U, B2.scrollHeight - O2 / U + P2))), 
                    R2 += Z - (J2 = Math.max(0, Math.min(Z + J2 / Q, B2.scrollWidth - X / Q + K)));
                }
                T2.push({
                    el: B2,
                    top: G,
                    left: J2
                });
            }
            return T2;
        };
        function isOptionsObject(options) {
            return options === Object(options) && 0 !== Object.keys(options).length;
        }
        function defaultBehavior(actions, behavior) {
            void 0 === behavior && (behavior = "auto");
            var canSmoothScroll = "scrollBehavior" in document.body.style;
            actions.forEach((function(_ref) {
                var el = _ref.el, top = _ref.top, left = _ref.left;
                el.scroll && canSmoothScroll ? el.scroll({
                    top: top,
                    left: left,
                    behavior: behavior
                }) : (el.scrollTop = top, el.scrollLeft = left);
            }));
        }
        function getOptions(options) {
            return !1 === options ? {
                block: "end",
                inline: "nearest"
            } : isOptionsObject(options) ? options : {
                block: "start",
                inline: "nearest"
            };
        }
        function scrollIntoView(target, options) {
            var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
            if (isOptionsObject(options) && "function" == typeof options.behavior) return options.behavior(isTargetAttached ? i$1(target, options) : []);
            if (isTargetAttached) {
                var computeOptions = getOptions(options);
                return defaultBehavior(i$1(target, computeOptions), computeOptions.behavior);
            }
        }
        function e(e2, t2) {
            for (var n2 = 0; n2 < t2.length; n2++) {
                var r2 = t2[n2];
                r2.enumerable = r2.enumerable || !1, r2.configurable = !0, "value" in r2 && (r2.writable = !0), 
                Object.defineProperty(e2, r2.key, r2);
            }
        }
        function t(t2, n2, r2) {
            return r2 && e(t2, r2), t2;
        }
        function n() {
            return (n = Object.assign || function(e2) {
                for (var t2 = 1; t2 < arguments.length; t2++) {
                    var n2 = arguments[t2];
                    for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
                }
                return e2;
            }).apply(this, arguments);
        }
        function r(e2, t2) {
            e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
        }
        function i(e2, t2) {
            if (null == e2) return {};
            var n2, r2, i2 = {}, o2 = Object.keys(e2);
            for (r2 = 0; r2 < o2.length; r2++) t2.indexOf(n2 = o2[r2]) >= 0 || (i2[n2] = e2[n2]);
            return i2;
        }
        function o(e2) {
            return 1 == (null != (t2 = e2) && "object" == typeof t2 && !1 === Array.isArray(t2)) && "[object Object]" === Object.prototype.toString.call(e2);
            var t2;
        }
        var u = Object.prototype, a = u.toString, f = u.hasOwnProperty, c = /^\s*function (\w+)/;
        function l(e2) {
            var t2, n2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
            if (n2) {
                var r2 = n2.toString().match(c);
                return r2 ? r2[1] : "";
            }
            return "";
        }
        var s = function(e2) {
            var t2, n2;
            return !1 !== o(e2) && "function" == typeof (t2 = e2.constructor) && !1 !== o(n2 = t2.prototype) && !1 !== n2.hasOwnProperty("isPrototypeOf");
        }, y = function(e2) {
            return e2;
        }, d = function(e2, t2) {
            return f.call(e2, t2);
        }, h = Number.isInteger || function(e2) {
            return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
        }, b = Array.isArray || function(e2) {
            return "[object Array]" === a.call(e2);
        }, O = function(e2) {
            return "[object Function]" === a.call(e2);
        }, g = function(e2) {
            return s(e2) && d(e2, "_vueTypes_name");
        }, m = function(e2) {
            return s(e2) && (d(e2, "type") || [ "_vueTypes_name", "validator", "default", "required" ].some((function(t2) {
                return d(e2, t2);
            })));
        };
        function j(e2, t2) {
            return Object.defineProperty(e2.bind(t2), "__original", {
                value: e2
            });
        }
        function _(e2, t2, n2) {
            var r2;
            void 0 === n2 && (n2 = !1);
            var i2 = !0, o2 = "";
            r2 = s(e2) ? e2 : {
                type: e2
            };
            var u2 = g(r2) ? r2._vueTypes_name + " - " : "";
            if (m(r2) && null !== r2.type) {
                if (void 0 === r2.type || !0 === r2.type) return i2;
                if (!r2.required && void 0 === t2) return i2;
                b(r2.type) ? (i2 = r2.type.some((function(e3) {
                    return !0 === _(e3, t2, !0);
                })), o2 = r2.type.map((function(e3) {
                    return l(e3);
                })).join(" or ")) : i2 = "Array" === (o2 = l(r2)) ? b(t2) : "Object" === o2 ? s(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
                    if (null == e3) return "";
                    var t3 = e3.constructor.toString().match(c);
                    return t3 ? t3[1] : "";
                }(t2) === o2 : t2 instanceof r2.type;
            }
            if (!i2) {
                var a2 = u2 + 'value "' + t2 + '" should be of type "' + o2 + '"';
                return !1 === n2 ? (y(a2), !1) : a2;
            }
            if (d(r2, "validator") && O(r2.validator)) {
                var f2 = y, v2 = [];
                if (y = function(e3) {
                    v2.push(e3);
                }, i2 = r2.validator(t2), y = f2, !i2) {
                    var p2 = (v2.length > 1 ? "* " : "") + v2.join("\n* ");
                    return v2.length = 0, !1 === n2 ? (y(p2), i2) : p2;
                }
            }
            return i2;
        }
        function T(e2, t2) {
            var n2 = Object.defineProperties(t2, {
                _vueTypes_name: {
                    value: e2,
                    writable: !0
                },
                isRequired: {
                    get: function() {
                        return this.required = !0, this;
                    }
                },
                def: {
                    value: function(e3) {
                        return void 0 !== e3 || this.default ? O(e3) || !0 === _(this, e3, !0) ? (this.default = b(e3) ? function() {
                            return [].concat(e3);
                        } : s(e3) ? function() {
                            return Object.assign({}, e3);
                        } : e3, this) : (y(this._vueTypes_name + ' - invalid default value: "' + e3 + '"'), 
                        this) : this;
                    }
                }
            }), r2 = n2.validator;
            return O(r2) && (n2.validator = j(r2, n2)), n2;
        }
        function w(e2, t2) {
            var n2 = T(e2, t2);
            return Object.defineProperty(n2, "validate", {
                value: function(e3) {
                    return O(this.validator) && y(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)), 
                    this.validator = j(e3, this), this;
                }
            });
        }
        function k(e2, t2, n2) {
            var r2, o2, u2 = (r2 = t2, o2 = {}, Object.getOwnPropertyNames(r2).forEach((function(e3) {
                o2[e3] = Object.getOwnPropertyDescriptor(r2, e3);
            })), Object.defineProperties({}, o2));
            if (u2._vueTypes_name = e2, !s(n2)) return u2;
            var a2, f2, c2 = n2.validator, l2 = i(n2, [ "validator" ]);
            if (O(c2)) {
                var v2 = u2.validator;
                v2 && (v2 = null !== (f2 = (a2 = v2).__original) && void 0 !== f2 ? f2 : a2), u2.validator = j(v2 ? function(e3) {
                    return v2.call(this, e3) && c2.call(this, e3);
                } : c2, u2);
            }
            return Object.assign(u2, l2);
        }
        function P(e2) {
            return e2.replace(/^(?!\s*$)/gm, "  ");
        }
        var x = function() {
            return w("any", {});
        }, A = function() {
            return w("function", {
                type: Function
            });
        }, E = function() {
            return w("boolean", {
                type: Boolean
            });
        }, N = function() {
            return w("string", {
                type: String
            });
        }, q = function() {
            return w("number", {
                type: Number
            });
        }, S = function() {
            return w("array", {
                type: Array
            });
        }, V = function() {
            return w("object", {
                type: Object
            });
        }, F = function() {
            return T("integer", {
                type: Number,
                validator: function(e2) {
                    return h(e2);
                }
            });
        }, D = function() {
            return T("symbol", {
                validator: function(e2) {
                    return "symbol" == typeof e2;
                }
            });
        };
        function L(e2, t2) {
            if (void 0 === t2 && (t2 = "custom validation failed"), "function" != typeof e2) throw new TypeError("[VueTypes error]: You must provide a function as argument");
            return T(e2.name || "<<anonymous function>>", {
                validator: function(n2) {
                    var r2 = e2(n2);
                    return r2 || y(this._vueTypes_name + " - " + t2), r2;
                }
            });
        }
        function Y(e2) {
            if (!b(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
            var t2 = 'oneOf - value should be one of "' + e2.join('", "') + '".', n2 = e2.reduce((function(e3, t3) {
                if (null != t3) {
                    var n3 = t3.constructor;
                    -1 === e3.indexOf(n3) && e3.push(n3);
                }
                return e3;
            }), []);
            return T("oneOf", {
                type: n2.length > 0 ? n2 : void 0,
                validator: function(n3) {
                    var r2 = -1 !== e2.indexOf(n3);
                    return r2 || y(t2), r2;
                }
            });
        }
        function B(e2) {
            if (!b(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
            for (var t2 = !1, n2 = [], r2 = 0; r2 < e2.length; r2 += 1) {
                var i2 = e2[r2];
                if (m(i2)) {
                    if (g(i2) && "oneOf" === i2._vueTypes_name) {
                        n2 = n2.concat(i2.type);
                        continue;
                    }
                    if (O(i2.validator) && (t2 = !0), !0 !== i2.type && i2.type) {
                        n2 = n2.concat(i2.type);
                        continue;
                    }
                }
                n2.push(i2);
            }
            return n2 = n2.filter((function(e3, t3) {
                return n2.indexOf(e3) === t3;
            })), T("oneOfType", t2 ? {
                type: n2,
                validator: function(t3) {
                    var n3 = [], r3 = e2.some((function(e3) {
                        var r4 = _(g(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, !0);
                        return "string" == typeof r4 && n3.push(r4), !0 === r4;
                    }));
                    return r3 || y("oneOfType - provided value does not match any of the " + n3.length + " passed-in validators:\n" + P(n3.join("\n"))), 
                    r3;
                }
            } : {
                type: n2
            });
        }
        function I(e2) {
            return T("arrayOf", {
                type: Array,
                validator: function(t2) {
                    var n2, r2 = t2.every((function(t3) {
                        return !0 === (n2 = _(e2, t3, !0));
                    }));
                    return r2 || y("arrayOf - value validation error:\n" + P(n2)), r2;
                }
            });
        }
        function J(e2) {
            return T("instanceOf", {
                type: e2
            });
        }
        function M(e2) {
            return T("objectOf", {
                type: Object,
                validator: function(t2) {
                    var n2, r2 = Object.keys(t2).every((function(r3) {
                        return !0 === (n2 = _(e2, t2[r3], !0));
                    }));
                    return r2 || y("objectOf - value validation error:\n" + P(n2)), r2;
                }
            });
        }
        function R(e2) {
            var t2 = Object.keys(e2), n2 = t2.filter((function(t3) {
                var n3;
                return !!(null === (n3 = e2[t3]) || void 0 === n3 ? void 0 : n3.required);
            })), r2 = T("shape", {
                type: Object,
                validator: function(r3) {
                    var i2 = this;
                    if (!s(r3)) return !1;
                    var o2 = Object.keys(r3);
                    if (n2.length > 0 && n2.some((function(e3) {
                        return -1 === o2.indexOf(e3);
                    }))) {
                        var u2 = n2.filter((function(e3) {
                            return -1 === o2.indexOf(e3);
                        }));
                        return y(1 === u2.length ? 'shape - required property "' + u2[0] + '" is not defined.' : 'shape - required properties "' + u2.join('", "') + '" are not defined.'), 
                        !1;
                    }
                    return o2.every((function(n3) {
                        if (-1 === t2.indexOf(n3)) return !0 === i2._vueTypes_isLoose || (y('shape - shape definition does not include a "' + n3 + '" property. Allowed keys: "' + t2.join('", "') + '".'), 
                        !1);
                        var o3 = _(e2[n3], r3[n3], !0);
                        return "string" == typeof o3 && y('shape - "' + n3 + '" property validation error:\n ' + P(o3)), 
                        !0 === o3;
                    }));
                }
            });
            return Object.defineProperty(r2, "_vueTypes_isLoose", {
                writable: !0,
                value: !1
            }), Object.defineProperty(r2, "loose", {
                get: function() {
                    return this._vueTypes_isLoose = !0, this;
                }
            }), r2;
        }
        var $ = function() {
            function e2() {}
            return e2.extend = function(e3) {
                var t2 = this;
                if (b(e3)) return e3.forEach((function(e4) {
                    return t2.extend(e4);
                })), this;
                var n2 = e3.name, r2 = e3.validate, o2 = void 0 !== r2 && r2, u2 = e3.getter, a2 = void 0 !== u2 && u2, f2 = i(e3, [ "name", "validate", "getter" ]);
                if (d(this, n2)) throw new TypeError('[VueTypes error]: Type "' + n2 + '" already defined');
                var c2, l2 = f2.type;
                return g(l2) ? (delete f2.type, Object.defineProperty(this, n2, a2 ? {
                    get: function() {
                        return k(n2, l2, f2);
                    }
                } : {
                    value: function() {
                        var e4, t3 = k(n2, l2, f2);
                        return t3.validator && (t3.validator = (e4 = t3.validator).bind.apply(e4, [ t3 ].concat([].slice.call(arguments)))), 
                        t3;
                    }
                })) : (c2 = a2 ? {
                    get: function() {
                        var e4 = Object.assign({}, f2);
                        return o2 ? w(n2, e4) : T(n2, e4);
                    },
                    enumerable: !0
                } : {
                    value: function() {
                        var e4, t3, r3 = Object.assign({}, f2);
                        return e4 = o2 ? w(n2, r3) : T(n2, r3), r3.validator && (e4.validator = (t3 = r3.validator).bind.apply(t3, [ e4 ].concat([].slice.call(arguments)))), 
                        e4;
                    },
                    enumerable: !0
                }, Object.defineProperty(this, n2, c2));
            }, t(e2, null, [ {
                key: "any",
                get: function() {
                    return x();
                }
            }, {
                key: "func",
                get: function() {
                    return A().def(this.defaults.func);
                }
            }, {
                key: "bool",
                get: function() {
                    return E().def(this.defaults.bool);
                }
            }, {
                key: "string",
                get: function() {
                    return N().def(this.defaults.string);
                }
            }, {
                key: "number",
                get: function() {
                    return q().def(this.defaults.number);
                }
            }, {
                key: "array",
                get: function() {
                    return S().def(this.defaults.array);
                }
            }, {
                key: "object",
                get: function() {
                    return V().def(this.defaults.object);
                }
            }, {
                key: "integer",
                get: function() {
                    return F().def(this.defaults.integer);
                }
            }, {
                key: "symbol",
                get: function() {
                    return D();
                }
            } ]), e2;
        }();
        function z(e2) {
            var i2;
            return void 0 === e2 && (e2 = {
                func: function() {},
                bool: !0,
                string: "",
                number: 0,
                array: function() {
                    return [];
                },
                object: function() {
                    return {};
                },
                integer: 0
            }), (i2 = function(i3) {
                function o2() {
                    return i3.apply(this, arguments) || this;
                }
                return r(o2, i3), t(o2, null, [ {
                    key: "sensibleDefaults",
                    get: function() {
                        return n({}, this.defaults);
                    },
                    set: function(t2) {
                        this.defaults = !1 !== t2 ? n({}, !0 !== t2 ? t2 : e2) : {};
                    }
                } ]), o2;
            }($)).defaults = n({}, e2), i2;
        }
        $.defaults = {}, $.custom = L, $.oneOf = Y, $.instanceOf = J, $.oneOfType = B, $.arrayOf = I, 
        $.objectOf = M, $.shape = R, $.utils = {
            validate: function(e2, t2) {
                return !0 === _(t2, e2, !0);
            },
            toType: function(e2, t2, n2) {
                return void 0 === n2 && (n2 = !1), n2 ? w(e2, t2) : T(e2, t2);
            }
        }, function(e2) {
            function t2() {
                return e2.apply(this, arguments) || this;
            }
            r(t2, e2);
        }(z());
        const PropTypes = z({
            func: void 0,
            bool: void 0,
            string: void 0,
            number: void 0,
            array: void 0,
            object: void 0,
            integer: void 0
        });
        PropTypes.extend([ {
            name: "looseBool",
            getter: !0,
            type: Boolean,
            default: void 0
        }, {
            name: "style",
            getter: !0,
            type: [ String, Object ],
            default: void 0
        }, {
            name: "VueNode",
            getter: !0,
            type: null
        } ]);
        const devWarning = (valid, component, message) => {
            warningOnce(valid, `[ant-design-vue: ${component}] ${message}`);
        };
        function getKey(data, index2) {
            const {key: key2} = data;
            let value;
            return "value" in data && ({value: value} = data), null != key2 ? key2 : void 0 !== value ? value : `rc-index-key-${index2}`;
        }
        function fillFieldNames(fieldNames, childrenAsData) {
            const {label: label, value: value, options: options} = fieldNames || {};
            return {
                label: label || (childrenAsData ? "children" : "label"),
                value: value || "value",
                options: options || "options"
            };
        }
        function flattenOptions(options) {
            let {fieldNames: fieldNames, childrenAsData: childrenAsData} = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const flattenList = [], {label: fieldLabel, value: fieldValue, options: fieldOptions} = fillFieldNames(fieldNames, !1);
            function dig(list, isGroupOption) {
                list.forEach((data => {
                    const label = data[fieldLabel];
                    if (isGroupOption || !(fieldOptions in data)) {
                        const value = data[fieldValue];
                        flattenList.push({
                            key: getKey(data, flattenList.length),
                            groupOption: isGroupOption,
                            data: data,
                            label: label,
                            value: value
                        });
                    } else {
                        let grpLabel = label;
                        void 0 === grpLabel && childrenAsData && (grpLabel = data.label), flattenList.push({
                            key: getKey(data, flattenList.length),
                            group: !0,
                            data: data,
                            label: grpLabel
                        }), dig(data[fieldOptions], !0);
                    }
                }));
            }
            return dig(options, !1), flattenList;
        }
        function injectPropsWithOption(option) {
            const newOption = _extends$1({}, option);
            return "props" in newOption || Object.defineProperty(newOption, "props", {
                get: () => newOption
            }), newOption;
        }
        function getSeparatedContent(text, tokens) {
            if (!tokens || !tokens.length) return null;
            let match2 = !1;
            function separate(str, _ref) {
                let [token2, ...restTokens] = _ref;
                if (!token2) return [ str ];
                const list2 = str.split(token2);
                return match2 = match2 || list2.length > 1, list2.reduce(((prevList, unitStr) => [ ...prevList, ...separate(unitStr, restTokens) ]), []).filter((unit => unit));
            }
            const list = separate(text, tokens);
            return match2 ? list : null;
        }
        function returnEmptyString() {
            return "";
        }
        function returnDocument(element) {
            return element ? element.ownerDocument : window.document;
        }
        function noop$1() {}
        const triggerProps = () => ({
            action: PropTypes.oneOfType([ PropTypes.string, PropTypes.arrayOf(PropTypes.string) ]).def([]),
            showAction: PropTypes.any.def([]),
            hideAction: PropTypes.any.def([]),
            getPopupClassNameFromAlign: PropTypes.any.def(returnEmptyString),
            onPopupVisibleChange: Function,
            afterPopupVisibleChange: PropTypes.func.def(noop$1),
            popup: PropTypes.any,
            arrow: PropTypes.bool.def(!0),
            popupStyle: {
                type: Object,
                default: void 0
            },
            prefixCls: PropTypes.string.def("rc-trigger-popup"),
            popupClassName: PropTypes.string.def(""),
            popupPlacement: String,
            builtinPlacements: PropTypes.object,
            popupTransitionName: String,
            popupAnimation: PropTypes.any,
            mouseEnterDelay: PropTypes.number.def(0),
            mouseLeaveDelay: PropTypes.number.def(.1),
            zIndex: Number,
            focusDelay: PropTypes.number.def(0),
            blurDelay: PropTypes.number.def(.15),
            getPopupContainer: Function,
            getDocument: PropTypes.func.def(returnDocument),
            forceRender: {
                type: Boolean,
                default: void 0
            },
            destroyPopupOnHide: {
                type: Boolean,
                default: !1
            },
            mask: {
                type: Boolean,
                default: !1
            },
            maskClosable: {
                type: Boolean,
                default: !0
            },
            popupAlign: PropTypes.object.def((() => ({}))),
            popupVisible: {
                type: Boolean,
                default: void 0
            },
            defaultPopupVisible: {
                type: Boolean,
                default: !1
            },
            maskTransitionName: String,
            maskAnimation: String,
            stretch: String,
            alignPoint: {
                type: Boolean,
                default: void 0
            },
            autoDestroy: {
                type: Boolean,
                default: !1
            },
            mobile: Object,
            getTriggerDOMNode: Function
        }), innerProps = {
            visible: Boolean,
            prefixCls: String,
            zIndex: Number,
            destroyPopupOnHide: Boolean,
            forceRender: Boolean,
            arrow: {
                type: Boolean,
                default: !0
            },
            animation: [ String, Object ],
            transitionName: String,
            stretch: {
                type: String
            },
            align: {
                type: Object
            },
            point: {
                type: Object
            },
            getRootDomNode: {
                type: Function
            },
            getClassNameFromAlign: {
                type: Function
            },
            onAlign: {
                type: Function
            },
            onMouseenter: {
                type: Function
            },
            onMouseleave: {
                type: Function
            },
            onMousedown: {
                type: Function
            },
            onTouchstart: {
                type: Function
            }
        }, mobileProps = _extends$1(_extends$1({}, innerProps), {
            mobile: {
                type: Object
            }
        }), popupProps = _extends$1(_extends$1({}, innerProps), {
            mask: Boolean,
            mobile: {
                type: Object
            },
            maskAnimation: String,
            maskTransitionName: String
        });
        function getMotion$1(_ref) {
            let {prefixCls: prefixCls, animation: animation, transitionName: transitionName2} = _ref;
            return animation ? {
                name: `${prefixCls}-${animation}`
            } : transitionName2 ? {
                name: transitionName2
            } : {};
        }
        function Mask(props2) {
            const {prefixCls: prefixCls, visible: visible, zIndex: zIndex, mask: mask, maskAnimation: maskAnimation, maskTransitionName: maskTransitionName} = props2;
            if (!mask) return null;
            let motion = {};
            return (maskTransitionName || maskAnimation) && (motion = getMotion$1({
                prefixCls: prefixCls,
                transitionName: maskTransitionName,
                animation: maskAnimation
            })), createVNode(Transition, _objectSpread2$1({
                appear: !0
            }, motion), {
                default: () => [ withDirectives(createVNode("div", {
                    style: {
                        zIndex: zIndex
                    },
                    class: `${prefixCls}-mask`
                }, null), [ [ resolveDirective("if"), visible ] ]) ]
            });
        }
        Mask.displayName = "Mask";
        const MobilePopupInner = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "MobilePopupInner",
            inheritAttrs: !1,
            props: mobileProps,
            emits: [ "mouseenter", "mouseleave", "mousedown", "touchstart", "align" ],
            setup(props2, _ref) {
                let {expose: expose, slots: slots} = _ref;
                const elementRef = ref();
                return expose({
                    forceAlign: () => {},
                    getElement: () => elementRef.value
                }), () => {
                    var _a;
                    const {zIndex: zIndex, visible: visible, prefixCls: prefixCls, mobile: {popupClassName: popupClassName, popupStyle: popupStyle, popupMotion: popupMotion = {}, popupRender: popupRender} = {}} = props2, mergedStyle = _extends$1({
                        zIndex: zIndex
                    }, popupStyle);
                    let childNode = flattenChildren(null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots));
                    childNode.length > 1 && (childNode = createVNode("div", {
                        class: `${prefixCls}-content`
                    }, [ childNode ])), popupRender && (childNode = popupRender(childNode));
                    const mergedClassName = classNames(prefixCls, popupClassName);
                    return createVNode(Transition, _objectSpread2$1({
                        ref: elementRef
                    }, popupMotion), {
                        default: () => [ visible ? createVNode("div", {
                            class: mergedClassName,
                            style: mergedStyle
                        }, [ childNode ]) : null ]
                    });
                };
            }
        });
        var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
            function adopt(value) {
                return value instanceof P2 ? value : new P2((function(resolve2) {
                    resolve2(value);
                }));
            }
            return new (P2 || (P2 = Promise))((function(resolve2, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e2) {
                        reject(e2);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e2) {
                        reject(e2);
                    }
                }
                function step(result) {
                    result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const StatusQueue = [ "measure", "align", null, "motion" ], useVisibleStatus = (visible, doMeasure) => {
            const status = shallowRef(null), rafRef = shallowRef(), destroyRef = shallowRef(!1);
            function setStatus(nextStatus) {
                destroyRef.value || (status.value = nextStatus);
            }
            function cancelRaf() {
                wrapperRaf.cancel(rafRef.value);
            }
            function goNextStatus(callback) {
                cancelRaf(), rafRef.value = wrapperRaf((() => {
                    let newStatus = status.value;
                    switch (status.value) {
                      case "align":
                        newStatus = "motion";
                        break;

                      case "motion":
                        newStatus = "stable";
                    }
                    setStatus(newStatus), null == callback || callback();
                }));
            }
            return watch(visible, (() => {
                setStatus("measure");
            }), {
                immediate: !0,
                flush: "post"
            }), onMounted((() => {
                watch(status, (() => {
                    if ("measure" === status.value) doMeasure();
                    status.value && (rafRef.value = wrapperRaf((() => __awaiter$1(void 0, void 0, void 0, (function*() {
                        const index2 = StatusQueue.indexOf(status.value), nextStatus = StatusQueue[index2 + 1];
                        nextStatus && -1 !== index2 && setStatus(nextStatus);
                    })))));
                }), {
                    immediate: !0,
                    flush: "post"
                });
            })), onBeforeUnmount((() => {
                destroyRef.value = !0, cancelRaf();
            })), [ status, goNextStatus ];
        }, useStretchStyle = stretch => {
            const targetSize = shallowRef({
                width: 0,
                height: 0
            });
            function measureStretch(element) {
                targetSize.value = {
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            }
            return [ computed((() => {
                const sizeStyle = {};
                if (stretch.value) {
                    const {width: width, height: height} = targetSize.value;
                    -1 !== stretch.value.indexOf("height") && height ? sizeStyle.height = `${height}px` : -1 !== stretch.value.indexOf("minHeight") && height && (sizeStyle.minHeight = `${height}px`), 
                    -1 !== stretch.value.indexOf("width") && width ? sizeStyle.width = `${width}px` : -1 !== stretch.value.indexOf("minWidth") && width && (sizeStyle.minWidth = `${width}px`);
                }
                return sizeStyle;
            })), measureStretch ];
        };
        function ownKeys(object, enumerableOnly) {
            var keys2 = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                enumerableOnly && (symbols = symbols.filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                }))), keys2.push.apply(keys2, symbols);
            }
            return keys2;
        }
        function _objectSpread2(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? arguments[i2] : {};
                i2 % 2 ? ownKeys(Object(source), !0).forEach((function(key2) {
                    _defineProperty$k(target, key2, source[key2]);
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key2) {
                    Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
                }));
            }
            return target;
        }
        function _typeof(obj) {
            return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            })(obj);
        }
        function _defineProperty$k(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var vendorPrefix, jsCssMap = {
            Webkit: "-webkit-",
            Moz: "-moz-",
            ms: "-ms-",
            O: "-o-"
        };
        function getVendorPrefix() {
            if (void 0 !== vendorPrefix) return vendorPrefix;
            vendorPrefix = "";
            var style = document.createElement("p").style, testProp = "Transform";
            for (var key2 in jsCssMap) key2 + testProp in style && (vendorPrefix = key2);
            return vendorPrefix;
        }
        function getTransitionName$1() {
            return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
        }
        function getTransformName() {
            return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
        }
        function setTransitionProperty(node2, value) {
            var name = getTransitionName$1();
            name && (node2.style[name] = value, "transitionProperty" !== name && (node2.style.transitionProperty = value));
        }
        function setTransform(node2, value) {
            var name = getTransformName();
            name && (node2.style[name] = value, "transform" !== name && (node2.style.transform = value));
        }
        function getTransitionProperty(node2) {
            return node2.style.transitionProperty || node2.style[getTransitionName$1()];
        }
        function getTransformXY(node2) {
            var style = window.getComputedStyle(node2, null), transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
            if (transform && "none" !== transform) {
                var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
                return {
                    x: parseFloat(matrix[12] || matrix[4], 0),
                    y: parseFloat(matrix[13] || matrix[5], 0)
                };
            }
            return {
                x: 0,
                y: 0
            };
        }
        var getComputedStyleX, matrix2d = /matrix\((.*)\)/, matrix3d = /matrix3d\((.*)\)/;
        function setTransformXY(node2, xy) {
            var style = window.getComputedStyle(node2, null), transform = style.getPropertyValue("transform") || style.getPropertyValue(getTransformName());
            if (transform && "none" !== transform) {
                var arr, match2d = transform.match(matrix2d);
                if (match2d) (arr = (match2d = match2d[1]).split(",").map((function(item) {
                    return parseFloat(item, 10);
                })))[4] = xy.x, arr[5] = xy.y, setTransform(node2, "matrix(".concat(arr.join(","), ")")); else (arr = transform.match(matrix3d)[1].split(",").map((function(item) {
                    return parseFloat(item, 10);
                })))[12] = xy.x, arr[13] = xy.y, setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
            } else setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
        }
        function forceRelayout(elem) {
            var originalStyle = elem.style.display;
            elem.style.display = "none", elem.offsetHeight, elem.style.display = originalStyle;
        }
        function css(el, name, v2) {
            var value = v2;
            if ("object" !== _typeof(name)) return void 0 !== value ? ("number" == typeof value && (value = "".concat(value, "px")), 
            void (el.style[name] = value)) : getComputedStyleX(el, name);
            for (var i2 in name) name.hasOwnProperty(i2) && css(el, i2, name[i2]);
        }
        function getClientPosition(elem) {
            var box, x2, y2, doc2 = elem.ownerDocument, body = doc2.body, docElem = doc2 && doc2.documentElement;
            return box = elem.getBoundingClientRect(), x2 = Math.floor(box.left), y2 = Math.floor(box.top), 
            {
                left: x2 -= docElem.clientLeft || body.clientLeft || 0,
                top: y2 -= docElem.clientTop || body.clientTop || 0
            };
        }
        function getScroll(w2, top) {
            var ret = w2["page".concat(top ? "Y" : "X", "Offset")], method = "scroll".concat(top ? "Top" : "Left");
            if ("number" != typeof ret) {
                var d2 = w2.document;
                "number" != typeof (ret = d2.documentElement[method]) && (ret = d2.body[method]);
            }
            return ret;
        }
        function getScrollLeft(w2) {
            return getScroll(w2);
        }
        function getScrollTop(w2) {
            return getScroll(w2, !0);
        }
        function getOffset(el) {
            var pos = getClientPosition(el), doc2 = el.ownerDocument, w2 = doc2.defaultView || doc2.parentWindow;
            return pos.left += getScrollLeft(w2), pos.top += getScrollTop(w2), pos;
        }
        function isWindow(obj) {
            return null != obj && obj == obj.window;
        }
        function getDocument(node2) {
            return isWindow(node2) ? node2.document : 9 === node2.nodeType ? node2 : node2.ownerDocument;
        }
        function _getComputedStyle(elem, name, cs) {
            var computedStyle = cs, val = "", d2 = getDocument(elem);
            return (computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null)) && (val = computedStyle.getPropertyValue(name) || computedStyle[name]), 
            val;
        }
        var _RE_NUM_NO_PX = new RegExp("^(".concat(/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, ")(?!px)[a-z%]+$"), "i"), RE_POS = /^(top|right|bottom|left)$/, CURRENT_STYLE = "currentStyle", RUNTIME_STYLE = "runtimeStyle", LEFT = "left", PX = "px";
        function _getComputedStyleIE(elem, name) {
            var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
            if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
                var style = elem.style, left = style[LEFT], rsLeft = elem[RUNTIME_STYLE][LEFT];
                elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT], style[LEFT] = "fontSize" === name ? "1em" : ret || 0, 
                ret = style.pixelLeft + PX, style[LEFT] = left, elem[RUNTIME_STYLE][LEFT] = rsLeft;
            }
            return "" === ret ? "auto" : ret;
        }
        function getOffsetDirection(dir, option) {
            return "left" === dir ? option.useCssRight ? "right" : dir : option.useCssBottom ? "bottom" : dir;
        }
        function oppositeOffsetDirection(dir) {
            return "left" === dir ? "right" : "right" === dir ? "left" : "top" === dir ? "bottom" : "bottom" === dir ? "top" : void 0;
        }
        function setLeftTop(elem, offset, option) {
            "static" === css(elem, "position") && (elem.style.position = "relative");
            var presetH = -999, presetV = -999, horizontalProperty = getOffsetDirection("left", option), verticalProperty = getOffsetDirection("top", option), oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty), oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
            "left" !== horizontalProperty && (presetH = 999), "top" !== verticalProperty && (presetV = 999);
            var originalTransition = "", originalOffset = getOffset(elem);
            ("left" in offset || "top" in offset) && (originalTransition = getTransitionProperty(elem) || "", 
            setTransitionProperty(elem, "none")), "left" in offset && (elem.style[oppositeHorizontalProperty] = "", 
            elem.style[horizontalProperty] = "".concat(presetH, "px")), "top" in offset && (elem.style[oppositeVerticalProperty] = "", 
            elem.style[verticalProperty] = "".concat(presetV, "px")), forceRelayout(elem);
            var old = getOffset(elem), originalStyle = {};
            for (var key2 in offset) if (offset.hasOwnProperty(key2)) {
                var dir = getOffsetDirection(key2, option), preset = "left" === key2 ? presetH : presetV, off = originalOffset[key2] - old[key2];
                originalStyle[dir] = dir === key2 ? preset + off : preset - off;
            }
            css(elem, originalStyle), forceRelayout(elem), ("left" in offset || "top" in offset) && setTransitionProperty(elem, originalTransition);
            var ret = {};
            for (var _key in offset) if (offset.hasOwnProperty(_key)) {
                var _dir = getOffsetDirection(_key, option), _off = offset[_key] - originalOffset[_key];
                ret[_dir] = _key === _dir ? originalStyle[_dir] + _off : originalStyle[_dir] - _off;
            }
            css(elem, ret);
        }
        function setTransform$1(elem, offset) {
            var originalOffset = getOffset(elem), originalXY = getTransformXY(elem), resultXY = {
                x: originalXY.x,
                y: originalXY.y
            };
            "left" in offset && (resultXY.x = originalXY.x + offset.left - originalOffset.left), 
            "top" in offset && (resultXY.y = originalXY.y + offset.top - originalOffset.top), 
            setTransformXY(elem, resultXY);
        }
        function setOffset(elem, offset, option) {
            if (option.ignoreShake) {
                var oriOffset = getOffset(elem), oLeft = oriOffset.left.toFixed(0), oTop = oriOffset.top.toFixed(0), tLeft = offset.left.toFixed(0), tTop = offset.top.toFixed(0);
                if (oLeft === tLeft && oTop === tTop) return;
            }
            option.useCssRight || option.useCssBottom ? setLeftTop(elem, offset, option) : option.useCssTransform && getTransformName() in document.body.style ? setTransform$1(elem, offset) : setLeftTop(elem, offset, option);
        }
        function each(arr, fn) {
            for (var i2 = 0; i2 < arr.length; i2++) fn(arr[i2]);
        }
        function isBorderBoxFn(elem) {
            return "border-box" === getComputedStyleX(elem, "boxSizing");
        }
        "undefined" != typeof window && (getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE);
        var BOX_MODELS = [ "margin", "border", "padding" ], CONTENT_INDEX = -1, PADDING_INDEX = 2, BORDER_INDEX = 1, MARGIN_INDEX = 0;
        function swap(elem, options, callback) {
            var name, old = {}, style = elem.style;
            for (name in options) options.hasOwnProperty(name) && (old[name] = style[name], 
            style[name] = options[name]);
            for (name in callback.call(elem), options) options.hasOwnProperty(name) && (style[name] = old[name]);
        }
        function getPBMWidth(elem, props2, which) {
            var prop, j2, i2, value = 0;
            for (j2 = 0; j2 < props2.length; j2++) if (prop = props2[j2]) for (i2 = 0; i2 < which.length; i2++) {
                var cssProp = void 0;
                cssProp = "border" === prop ? "".concat(prop).concat(which[i2], "Width") : prop + which[i2], 
                value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
            }
            return value;
        }
        var domUtils = {
            getParent: function getParent2(element) {
                var parent2 = element;
                do {
                    parent2 = 11 === parent2.nodeType && parent2.host ? parent2.host : parent2.parentNode;
                } while (parent2 && 1 !== parent2.nodeType && 9 !== parent2.nodeType);
                return parent2;
            }
        };
        function getWH(elem, name, ex) {
            var extra = ex;
            if (isWindow(elem)) return "width" === name ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
            if (9 === elem.nodeType) return "width" === name ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
            var which = "width" === name ? [ "Left", "Right" ] : [ "Top", "Bottom" ], borderBoxValue = "width" === name ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height), isBorderBox = isBorderBoxFn(elem), cssBoxValue = 0;
            (null == borderBoxValue || borderBoxValue <= 0) && (borderBoxValue = void 0, (null == (cssBoxValue = getComputedStyleX(elem, name)) || Number(cssBoxValue) < 0) && (cssBoxValue = elem.style[name] || 0), 
            cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0), void 0 === extra && (extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX);
            var borderBoxValueOrIsBorderBox = void 0 !== borderBoxValue || isBorderBox, val = borderBoxValue || cssBoxValue;
            return extra === CONTENT_INDEX ? borderBoxValueOrIsBorderBox ? val - getPBMWidth(elem, [ "border", "padding" ], which) : cssBoxValue : borderBoxValueOrIsBorderBox ? extra === BORDER_INDEX ? val : val + (extra === PADDING_INDEX ? -getPBMWidth(elem, [ "border" ], which) : getPBMWidth(elem, [ "margin" ], which)) : cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
        }
        each([ "Width", "Height" ], (function(name) {
            domUtils["doc".concat(name)] = function(refWin) {
                var d2 = refWin.document;
                return Math.max(d2.documentElement["scroll".concat(name)], d2.body["scroll".concat(name)], domUtils["viewport".concat(name)](d2));
            }, domUtils["viewport".concat(name)] = function(win) {
                var prop = "client".concat(name), doc2 = win.document, body = doc2.body, documentElementProp = doc2.documentElement[prop];
                return "CSS1Compat" === doc2.compatMode && documentElementProp || body && body[prop] || documentElementProp;
            };
        }));
        var cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        };
        function getWHIgnoreDisplay() {
            for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) args[_key2] = arguments[_key2];
            var val, elem = args[0];
            return 0 !== elem.offsetWidth ? val = getWH.apply(void 0, args) : swap(elem, cssShow, (function() {
                val = getWH.apply(void 0, args);
            })), val;
        }
        function mix(to, from2) {
            for (var i2 in from2) from2.hasOwnProperty(i2) && (to[i2] = from2[i2]);
            return to;
        }
        each([ "width", "height" ], (function(name) {
            var first = name.charAt(0).toUpperCase() + name.slice(1);
            domUtils["outer".concat(first)] = function(el, includeMargin) {
                return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
            };
            var which = "width" === name ? [ "Left", "Right" ] : [ "Top", "Bottom" ];
            domUtils[name] = function(elem, v2) {
                var val = v2;
                return void 0 !== val ? elem ? (isBorderBoxFn(elem) && (val += getPBMWidth(elem, [ "padding", "border" ], which)), 
                css(elem, name, val)) : void 0 : elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
            };
        }));
        var utils = {
            getWindow: function getWindow(node2) {
                if (node2 && node2.document && node2.setTimeout) return node2;
                var doc2 = node2.ownerDocument || node2;
                return doc2.defaultView || doc2.parentWindow;
            },
            getDocument: getDocument,
            offset: function offset(el, value, option) {
                if (void 0 === value) return getOffset(el);
                setOffset(el, value, option || {});
            },
            isWindow: isWindow,
            each: each,
            css: css,
            clone: function clone(obj) {
                var i2, ret = {};
                for (i2 in obj) obj.hasOwnProperty(i2) && (ret[i2] = obj[i2]);
                if (obj.overflow) for (i2 in obj) obj.hasOwnProperty(i2) && (ret.overflow[i2] = obj.overflow[i2]);
                return ret;
            },
            mix: mix,
            getWindowScrollLeft: function getWindowScrollLeft(w2) {
                return getScrollLeft(w2);
            },
            getWindowScrollTop: function getWindowScrollTop(w2) {
                return getScrollTop(w2);
            },
            merge: function merge2() {
                for (var ret = {}, i2 = 0; i2 < arguments.length; i2++) utils.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
                return ret;
            },
            viewportWidth: 0,
            viewportHeight: 0
        };
        mix(utils, domUtils);
        var getParent$1 = utils.getParent;
        function getOffsetParent(element) {
            if (utils.isWindow(element) || 9 === element.nodeType) return null;
            var parent2, body = utils.getDocument(element).body, positionStyle = utils.css(element, "position");
            if (!("fixed" === positionStyle || "absolute" === positionStyle)) return "html" === element.nodeName.toLowerCase() ? null : getParent$1(element);
            for (parent2 = getParent$1(element); parent2 && parent2 !== body && 9 !== parent2.nodeType; parent2 = getParent$1(parent2)) if ("static" !== (positionStyle = utils.css(parent2, "position"))) return parent2;
            return null;
        }
        var getParent$1$1 = utils.getParent;
        function isAncestorFixed(element) {
            if (utils.isWindow(element) || 9 === element.nodeType) return !1;
            var doc2 = utils.getDocument(element), body = doc2.body, parent2 = null;
            for (parent2 = getParent$1$1(element); parent2 && parent2 !== body && parent2 !== doc2; parent2 = getParent$1$1(parent2)) {
                if ("fixed" === utils.css(parent2, "position")) return !0;
            }
            return !1;
        }
        function getVisibleRectForElement(element, alwaysByViewport) {
            for (var visibleRect = {
                left: 0,
                right: 1 / 0,
                top: 0,
                bottom: 1 / 0
            }, el = getOffsetParent(element), doc2 = utils.getDocument(element), win = doc2.defaultView || doc2.parentWindow, body = doc2.body, documentElement = doc2.documentElement; el; ) {
                if (-1 !== navigator.userAgent.indexOf("MSIE") && 0 === el.clientWidth || el === body || el === documentElement || "visible" === utils.css(el, "overflow")) {
                    if (el === body || el === documentElement) break;
                } else {
                    var pos = utils.offset(el);
                    pos.left += el.clientLeft, pos.top += el.clientTop, visibleRect.top = Math.max(visibleRect.top, pos.top), 
                    visibleRect.right = Math.min(visibleRect.right, pos.left + el.clientWidth), visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight), 
                    visibleRect.left = Math.max(visibleRect.left, pos.left);
                }
                el = getOffsetParent(el);
            }
            var originalPosition = null;
            utils.isWindow(element) || 9 === element.nodeType || (originalPosition = element.style.position, 
            "absolute" === utils.css(element, "position") && (element.style.position = "fixed"));
            var scrollX = utils.getWindowScrollLeft(win), scrollY = utils.getWindowScrollTop(win), viewportWidth = utils.viewportWidth(win), viewportHeight = utils.viewportHeight(win), documentWidth = documentElement.scrollWidth, documentHeight = documentElement.scrollHeight, bodyStyle = window.getComputedStyle(body);
            if ("hidden" === bodyStyle.overflowX && (documentWidth = win.innerWidth), "hidden" === bodyStyle.overflowY && (documentHeight = win.innerHeight), 
            element.style && (element.style.position = originalPosition), alwaysByViewport || isAncestorFixed(element)) visibleRect.left = Math.max(visibleRect.left, scrollX), 
            visibleRect.top = Math.max(visibleRect.top, scrollY), visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth), 
            visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight); else {
                var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
                visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
                var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
                visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
            }
            return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
        }
        function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
            var pos = utils.clone(elFuturePos), size2 = {
                width: elRegion.width,
                height: elRegion.height
            };
            return overflow.adjustX && pos.left < visibleRect.left && (pos.left = visibleRect.left), 
            overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size2.width > visibleRect.right && (size2.width -= pos.left + size2.width - visibleRect.right), 
            overflow.adjustX && pos.left + size2.width > visibleRect.right && (pos.left = Math.max(visibleRect.right - size2.width, visibleRect.left)), 
            overflow.adjustY && pos.top < visibleRect.top && (pos.top = visibleRect.top), overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size2.height > visibleRect.bottom && (size2.height -= pos.top + size2.height - visibleRect.bottom), 
            overflow.adjustY && pos.top + size2.height > visibleRect.bottom && (pos.top = Math.max(visibleRect.bottom - size2.height, visibleRect.top)), 
            utils.mix(pos, size2);
        }
        function getRegion(node2) {
            var offset, w2, h2;
            if (utils.isWindow(node2) || 9 === node2.nodeType) {
                var win = utils.getWindow(node2);
                offset = {
                    left: utils.getWindowScrollLeft(win),
                    top: utils.getWindowScrollTop(win)
                }, w2 = utils.viewportWidth(win), h2 = utils.viewportHeight(win);
            } else offset = utils.offset(node2), w2 = utils.outerWidth(node2), h2 = utils.outerHeight(node2);
            return offset.width = w2, offset.height = h2, offset;
        }
        function getAlignOffset(region, align) {
            var V2 = align.charAt(0), H = align.charAt(1), w2 = region.width, h2 = region.height, x2 = region.left, y2 = region.top;
            return "c" === V2 ? y2 += h2 / 2 : "b" === V2 && (y2 += h2), "c" === H ? x2 += w2 / 2 : "r" === H && (x2 += w2), 
            {
                left: x2,
                top: y2
            };
        }
        function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset2) {
            var p1 = getAlignOffset(refNodeRegion, points[1]), p2 = getAlignOffset(elRegion, points[0]), diff = [ p2.left - p1.left, p2.top - p1.top ];
            return {
                left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset2[0]),
                top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset2[1])
            };
        }
        function isFailX(elFuturePos, elRegion, visibleRect) {
            return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
        }
        function isFailY(elFuturePos, elRegion, visibleRect) {
            return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
        }
        function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
            return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
        }
        function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
            return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
        }
        function flip(points, reg, map) {
            var ret = [];
            return utils.each(points, (function(p2) {
                ret.push(p2.replace(reg, (function(m2) {
                    return map[m2];
                })));
            })), ret;
        }
        function flipOffset(offset, index2) {
            return offset[index2] = -offset[index2], offset;
        }
        function convertOffset(str, offsetLen) {
            return (/%$/.test(str) ? parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen : parseInt(str, 10)) || 0;
        }
        function normalizeOffset(offset, el) {
            offset[0] = convertOffset(offset[0], el.width), offset[1] = convertOffset(offset[1], el.height);
        }
        function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
            var points = align.points, offset = align.offset || [ 0, 0 ], targetOffset2 = align.targetOffset || [ 0, 0 ], overflow = align.overflow, source = align.source || el;
            offset = [].concat(offset), targetOffset2 = [].concat(targetOffset2);
            var newOverflowCfg = {}, fail = 0, visibleRect = getVisibleRectForElement(source, !(!(overflow = overflow || {}) || !overflow.alwaysByViewport)), elRegion = getRegion(source);
            normalizeOffset(offset, elRegion), normalizeOffset(targetOffset2, tgtRegion);
            var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset2), newElRegion = utils.merge(elRegion, elFuturePos);
            if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
                if (overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect)) {
                    var newPoints = flip(points, /[lr]/gi, {
                        l: "r",
                        r: "l"
                    }), newOffset = flipOffset(offset, 0), newTargetOffset = flipOffset(targetOffset2, 0);
                    isCompleteFailX(getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset), elRegion, visibleRect) || (fail = 1, 
                    points = newPoints, offset = newOffset, targetOffset2 = newTargetOffset);
                }
                if (overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect)) {
                    var _newPoints = flip(points, /[tb]/gi, {
                        t: "b",
                        b: "t"
                    }), _newOffset = flipOffset(offset, 1), _newTargetOffset = flipOffset(targetOffset2, 1);
                    isCompleteFailY(getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset), elRegion, visibleRect) || (fail = 1, 
                    points = _newPoints, offset = _newOffset, targetOffset2 = _newTargetOffset);
                }
                fail && (elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset2), 
                utils.mix(newElRegion, elFuturePos));
                var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect), isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
                if (isStillFailX || isStillFailY) {
                    var _newPoints2 = points;
                    isStillFailX && (_newPoints2 = flip(points, /[lr]/gi, {
                        l: "r",
                        r: "l"
                    })), isStillFailY && (_newPoints2 = flip(points, /[tb]/gi, {
                        t: "b",
                        b: "t"
                    })), points = _newPoints2, offset = align.offset || [ 0, 0 ], targetOffset2 = align.targetOffset || [ 0, 0 ];
                }
                newOverflowCfg.adjustX = overflow.adjustX && isStillFailX, newOverflowCfg.adjustY = overflow.adjustY && isStillFailY, 
                (newOverflowCfg.adjustX || newOverflowCfg.adjustY) && (newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg));
            }
            return newElRegion.width !== elRegion.width && utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width), 
            newElRegion.height !== elRegion.height && utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height), 
            utils.offset(source, {
                left: newElRegion.left,
                top: newElRegion.top
            }, {
                useCssRight: align.useCssRight,
                useCssBottom: align.useCssBottom,
                useCssTransform: align.useCssTransform,
                ignoreShake: align.ignoreShake
            }), {
                points: points,
                offset: offset,
                targetOffset: targetOffset2,
                overflow: newOverflowCfg
            };
        }
        function isOutOfVisibleRect(target, alwaysByViewport) {
            var visibleRect = getVisibleRectForElement(target, alwaysByViewport), targetRegion = getRegion(target);
            return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
        }
        function alignElement(el, refNode, align) {
            var target = align.target || refNode;
            return doAlign(el, getRegion(target), align, !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport));
        }
        function alignPoint(el, tgtPoint, align) {
            var pageX, pageY, doc2 = utils.getDocument(el), win = doc2.defaultView || doc2.parentWindow, scrollX = utils.getWindowScrollLeft(win), scrollY = utils.getWindowScrollTop(win), viewportWidth = utils.viewportWidth(win), viewportHeight = utils.viewportHeight(win), tgtRegion = {
                left: pageX = "pageX" in tgtPoint ? tgtPoint.pageX : scrollX + tgtPoint.clientX,
                top: pageY = "pageY" in tgtPoint ? tgtPoint.pageY : scrollY + tgtPoint.clientY,
                width: 0,
                height: 0
            }, pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight, points = [ align.points[0], "cc" ];
            return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
                points: points
            }), pointInView);
        }
        function cloneElement(vnode) {
            let nodeProps = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, override = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], mergeRef = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], ele = vnode;
            if (Array.isArray(vnode) && (ele = filterEmpty(vnode)[0]), !ele) return null;
            const node2 = cloneVNode(ele, nodeProps, mergeRef);
            return node2.props = override ? _extends$1(_extends$1({}, node2.props), nodeProps) : node2.props, 
            warning$2("object" != typeof node2.props.class), node2;
        }
        alignElement.__getOffsetParent = getOffsetParent, alignElement.__getVisibleRectForElement = getVisibleRectForElement;
        const isVisible = element => {
            if (!element) return !1;
            if (element.offsetParent) return !0;
            if (element.getBBox) {
                const box = element.getBBox();
                if (box.width || box.height) return !0;
            }
            if (element.getBoundingClientRect) {
                const box = element.getBoundingClientRect();
                if (box.width || box.height) return !0;
            }
            return !1;
        };
        function isSamePoint(prev2, next2) {
            return prev2 === next2 || !(!prev2 || !next2) && ("pageX" in next2 && "pageY" in next2 ? prev2.pageX === next2.pageX && prev2.pageY === next2.pageY : "clientX" in next2 && "clientY" in next2 && (prev2.clientX === next2.clientX && prev2.clientY === next2.clientY));
        }
        function restoreFocus(activeElement, container) {
            activeElement !== document.activeElement && contains$1(container, activeElement) && "function" == typeof activeElement.focus && activeElement.focus();
        }
        function monitorResize(element, callback) {
            let prevWidth = null, prevHeight = null;
            function onResize(_ref) {
                let [{target: target}] = _ref;
                if (!document.documentElement.contains(target)) return;
                const {width: width, height: height} = target.getBoundingClientRect(), fixedWidth = Math.floor(width), fixedHeight = Math.floor(height);
                prevWidth === fixedWidth && prevHeight === fixedHeight || Promise.resolve().then((() => {
                    callback({
                        width: fixedWidth,
                        height: fixedHeight
                    });
                })), prevWidth = fixedWidth, prevHeight = fixedHeight;
            }
            const resizeObserver = new index(onResize);
            return element && resizeObserver.observe(element), () => {
                resizeObserver.disconnect();
            };
        }
        const useBuffer = (callback, buffer) => {
            let called = !1, timeout = null;
            function cancelTrigger() {
                clearTimeout(timeout);
            }
            function trigger2(force) {
                if (called && !0 !== force) cancelTrigger(), timeout = setTimeout((() => {
                    called = !1, trigger2();
                }), buffer.value); else {
                    if (!1 === callback()) return;
                    called = !0, cancelTrigger(), timeout = setTimeout((() => {
                        called = !1;
                    }), buffer.value);
                }
            }
            return [ trigger2, () => {
                called = !1, cancelTrigger();
            } ];
        };
        function getElement(func) {
            return "function" != typeof func ? null : func();
        }
        function getPoint(point) {
            return "object" == typeof point && point ? point : null;
        }
        const Align = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Align",
            props: {
                align: Object,
                target: [ Object, Function ],
                onAlign: Function,
                monitorBufferTime: Number,
                monitorWindowResize: Boolean,
                disabled: Boolean
            },
            emits: [ "align" ],
            setup(props2, _ref) {
                let {expose: expose, slots: slots} = _ref;
                const cacheRef = ref({}), nodeRef = ref(), [forceAlign, cancelForceAlign] = useBuffer((() => {
                    const {disabled: latestDisabled, target: latestTarget, align: latestAlign, onAlign: latestOnAlign} = props2;
                    if (!latestDisabled && latestTarget && nodeRef.value) {
                        const source = nodeRef.value;
                        let result;
                        const element = getElement(latestTarget), point = getPoint(latestTarget);
                        cacheRef.value.element = element, cacheRef.value.point = point, cacheRef.value.align = latestAlign;
                        const {activeElement: activeElement} = document;
                        return element && isVisible(element) ? result = alignElement(source, element, latestAlign) : point && (result = alignPoint(source, point, latestAlign)), 
                        restoreFocus(activeElement, source), latestOnAlign && result && latestOnAlign(source, result), 
                        !0;
                    }
                    return !1;
                }), computed((() => props2.monitorBufferTime))), resizeMonitor = ref({
                    cancel: () => {}
                }), sourceResizeMonitor = ref({
                    cancel: () => {}
                }), goAlign = () => {
                    const target = props2.target, element = getElement(target), point = getPoint(target);
                    nodeRef.value !== sourceResizeMonitor.value.element && (sourceResizeMonitor.value.cancel(), 
                    sourceResizeMonitor.value.element = nodeRef.value, sourceResizeMonitor.value.cancel = monitorResize(nodeRef.value, forceAlign)), 
                    cacheRef.value.element === element && isSamePoint(cacheRef.value.point, point) && isEqual(cacheRef.value.align, props2.align) || (forceAlign(), 
                    resizeMonitor.value.element !== element && (resizeMonitor.value.cancel(), resizeMonitor.value.element = element, 
                    resizeMonitor.value.cancel = monitorResize(element, forceAlign)));
                };
                onMounted((() => {
                    nextTick((() => {
                        goAlign();
                    }));
                })), onUpdated((() => {
                    nextTick((() => {
                        goAlign();
                    }));
                })), watch((() => props2.disabled), (disabled => {
                    disabled ? cancelForceAlign() : forceAlign();
                }), {
                    immediate: !0,
                    flush: "post"
                });
                const winResizeRef = ref(null);
                return watch((() => props2.monitorWindowResize), (monitorWindowResize => {
                    monitorWindowResize ? winResizeRef.value || (winResizeRef.value = addEventListenerWrap(window, "resize", forceAlign)) : winResizeRef.value && (winResizeRef.value.remove(), 
                    winResizeRef.value = null);
                }), {
                    flush: "post"
                }), onUnmounted((() => {
                    resizeMonitor.value.cancel(), sourceResizeMonitor.value.cancel(), winResizeRef.value && winResizeRef.value.remove(), 
                    cancelForceAlign();
                })), expose({
                    forceAlign: () => forceAlign(!0)
                }), () => {
                    const child = null == slots ? void 0 : slots.default();
                    return child ? cloneElement(child[0], {
                        ref: nodeRef
                    }, !0, !0) : null;
                };
            }
        });
        tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
        const getTransitionDirection = placement => void 0 === placement || "topLeft" !== placement && "topRight" !== placement ? "slide-up" : "slide-down", getTransitionProps = function(transitionName2) {
            let opt = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return _extends$1(transitionName2 ? {
                name: transitionName2,
                appear: !0,
                enterFromClass: `${transitionName2}-enter ${transitionName2}-enter-prepare ${transitionName2}-enter-start`,
                enterActiveClass: `${transitionName2}-enter ${transitionName2}-enter-prepare`,
                enterToClass: `${transitionName2}-enter ${transitionName2}-enter-active`,
                leaveFromClass: ` ${transitionName2}-leave`,
                leaveActiveClass: `${transitionName2}-leave ${transitionName2}-leave-active`,
                leaveToClass: `${transitionName2}-leave ${transitionName2}-leave-active`
            } : {
                css: !1
            }, opt);
        }, getTransitionGroupProps = function(transitionName2) {
            let opt = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return _extends$1(transitionName2 ? {
                name: transitionName2,
                appear: !0,
                appearActiveClass: `${transitionName2}`,
                appearToClass: `${transitionName2}-appear ${transitionName2}-appear-active`,
                enterFromClass: `${transitionName2}-appear ${transitionName2}-enter ${transitionName2}-appear-prepare ${transitionName2}-enter-prepare`,
                enterActiveClass: `${transitionName2}`,
                enterToClass: `${transitionName2}-enter ${transitionName2}-appear ${transitionName2}-appear-active ${transitionName2}-enter-active`,
                leaveActiveClass: `${transitionName2} ${transitionName2}-leave`,
                leaveToClass: `${transitionName2}-leave-active`
            } : {
                css: !1
            }, opt);
        }, getTransitionName = (rootPrefixCls, motion, transitionName2) => void 0 !== transitionName2 ? transitionName2 : `${rootPrefixCls}-${motion}`, PopupInner = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "PopupInner",
            inheritAttrs: !1,
            props: innerProps,
            emits: [ "mouseenter", "mouseleave", "mousedown", "touchstart", "align" ],
            setup(props2, _ref) {
                let {expose: expose, attrs: attrs, slots: slots} = _ref;
                const alignRef = shallowRef(), elementRef = shallowRef(), alignedClassName = shallowRef(), [stretchStyle, measureStretchStyle] = useStretchStyle(toRef(props2, "stretch")), doMeasure = () => {
                    props2.stretch && measureStretchStyle(props2.getRootDomNode());
                }, visible = shallowRef(!1);
                let timeoutId;
                watch((() => props2.visible), (val => {
                    clearTimeout(timeoutId), val ? timeoutId = setTimeout((() => {
                        visible.value = props2.visible;
                    })) : visible.value = !1;
                }), {
                    immediate: !0
                });
                const [status, goNextStatus] = useVisibleStatus(visible, doMeasure), prepareResolveRef = shallowRef(), getAlignTarget = () => props2.point ? props2.point : props2.getRootDomNode, forceAlign = () => {
                    var _a;
                    null === (_a = alignRef.value) || void 0 === _a || _a.forceAlign();
                }, onInternalAlign = (popupDomNode, matchAlign) => {
                    var _a;
                    const nextAlignedClassName = props2.getClassNameFromAlign(matchAlign), preAlignedClassName = alignedClassName.value;
                    alignedClassName.value !== nextAlignedClassName && (alignedClassName.value = nextAlignedClassName), 
                    "align" === status.value && (preAlignedClassName !== nextAlignedClassName ? Promise.resolve().then((() => {
                        forceAlign();
                    })) : goNextStatus((() => {
                        var _a2;
                        null === (_a2 = prepareResolveRef.value) || void 0 === _a2 || _a2.call(prepareResolveRef);
                    })), null === (_a = props2.onAlign) || void 0 === _a || _a.call(props2, popupDomNode, matchAlign));
                }, motion = computed((() => {
                    const m2 = "object" == typeof props2.animation ? props2.animation : getMotion$1(props2);
                    return [ "onAfterEnter", "onAfterLeave" ].forEach((eventName => {
                        const originFn = m2[eventName];
                        m2[eventName] = node2 => {
                            goNextStatus(), status.value = "stable", null == originFn || originFn(node2);
                        };
                    })), m2;
                })), onShowPrepare = () => new Promise((resolve2 => {
                    prepareResolveRef.value = resolve2;
                }));
                watch([ motion, status ], (() => {
                    motion.value || "motion" !== status.value || goNextStatus();
                }), {
                    immediate: !0
                }), expose({
                    forceAlign: forceAlign,
                    getElement: () => elementRef.value.$el || elementRef.value
                });
                const alignDisabled = computed((() => {
                    var _a;
                    return !(null === (_a = props2.align) || void 0 === _a ? void 0 : _a.points) || "align" !== status.value && "stable" !== status.value;
                }));
                return () => {
                    var _a;
                    const {zIndex: zIndex, align: align, prefixCls: prefixCls, destroyPopupOnHide: destroyPopupOnHide, onMouseenter: onMouseenter, onMouseleave: onMouseleave, onTouchstart: onTouchstart = () => {}, onMousedown: onMousedown} = props2, statusValue = status.value, mergedStyle = [ _extends$1(_extends$1({}, stretchStyle.value), {
                        zIndex: zIndex,
                        opacity: "motion" !== statusValue && "stable" !== statusValue && visible.value ? 0 : null,
                        pointerEvents: visible.value || "stable" === statusValue ? null : "none"
                    }), attrs.style ];
                    let childNode = flattenChildren(null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots, {
                        visible: props2.visible
                    }));
                    childNode.length > 1 && (childNode = createVNode("div", {
                        class: `${prefixCls}-content`
                    }, [ childNode ]));
                    const mergedClassName = classNames(prefixCls, attrs.class, alignedClassName.value, !props2.arrow && `${prefixCls}-arrow-hidden`), transitionProps = visible.value || !props2.visible ? getTransitionProps(motion.value.name, motion.value) : {};
                    return createVNode(Transition, _objectSpread2$1(_objectSpread2$1({
                        ref: elementRef
                    }, transitionProps), {}, {
                        onBeforeEnter: onShowPrepare
                    }), {
                        default: () => !destroyPopupOnHide || props2.visible ? withDirectives(createVNode(Align, {
                            target: getAlignTarget(),
                            key: "popup",
                            ref: alignRef,
                            monitorWindowResize: !0,
                            disabled: alignDisabled.value,
                            align: align,
                            onAlign: onInternalAlign
                        }, {
                            default: () => createVNode("div", {
                                class: mergedClassName,
                                onMouseenter: onMouseenter,
                                onMouseleave: onMouseleave,
                                onMousedown: withModifiers(onMousedown, [ "capture" ]),
                                [supportsPassive ? "onTouchstartPassive" : "onTouchstart"]: withModifiers(onTouchstart, [ "capture" ]),
                                style: mergedStyle
                            }, [ childNode ])
                        }), [ [ vShow, visible.value ] ]) : null
                    });
                };
            }
        }), Popup = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Popup",
            inheritAttrs: !1,
            props: popupProps,
            setup(props2, _ref) {
                let {attrs: attrs, slots: slots, expose: expose} = _ref;
                const innerVisible = shallowRef(!1), inMobile = shallowRef(!1), popupRef = shallowRef(), rootRef = shallowRef();
                return watch([ () => props2.visible, () => props2.mobile ], (() => {
                    innerVisible.value = props2.visible, props2.visible && props2.mobile && (inMobile.value = !0);
                }), {
                    immediate: !0,
                    flush: "post"
                }), expose({
                    forceAlign: () => {
                        var _a;
                        null === (_a = popupRef.value) || void 0 === _a || _a.forceAlign();
                    },
                    getElement: () => {
                        var _a;
                        return null === (_a = popupRef.value) || void 0 === _a ? void 0 : _a.getElement();
                    }
                }), () => {
                    const cloneProps = _extends$1(_extends$1(_extends$1({}, props2), attrs), {
                        visible: innerVisible.value
                    }), popupNode = inMobile.value ? createVNode(MobilePopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
                        mobile: props2.mobile,
                        ref: popupRef
                    }), {
                        default: slots.default
                    }) : createVNode(PopupInner, _objectSpread2$1(_objectSpread2$1({}, cloneProps), {}, {
                        ref: popupRef
                    }), {
                        default: slots.default
                    });
                    return createVNode("div", {
                        ref: rootRef
                    }, [ createVNode(Mask, cloneProps, null), popupNode ]);
                };
            }
        });
        function isPointsEq(a1, a2, isAlignPoint) {
            return isAlignPoint ? a1[0] === a2[0] : a1[0] === a2[0] && a1[1] === a2[1];
        }
        function getAlignFromPlacement(builtinPlacements, placementStr, align) {
            return _extends$1(_extends$1({}, builtinPlacements[placementStr] || {}), align);
        }
        function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
            const {points: points} = align, placements2 = Object.keys(builtinPlacements);
            for (let i2 = 0; i2 < placements2.length; i2 += 1) {
                const placement = placements2[i2];
                if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) return `${prefixCls}-placement-${placement}`;
            }
            return "";
        }
        const BaseMixin = {
            methods: {
                setState() {
                    let state = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, callback = arguments.length > 1 ? arguments[1] : void 0, newState = "function" == typeof state ? state(this.$data, this.$props) : state;
                    if (this.getDerivedStateFromProps) {
                        const s2 = this.getDerivedStateFromProps(getOptionProps(this), _extends$1(_extends$1({}, this.$data), newState));
                        if (null === s2) return;
                        newState = _extends$1(_extends$1({}, newState), s2 || {});
                    }
                    _extends$1(this.$data, newState), this._.isMounted && this.$forceUpdate(), nextTick((() => {
                        callback && callback();
                    }));
                },
                __emit() {
                    const args = [].slice.call(arguments, 0);
                    let eventName = args[0];
                    eventName = `on${eventName[0].toUpperCase()}${eventName.substring(1)}`;
                    const event = this.$props[eventName] || this.$attrs[eventName];
                    if (args.length && event) if (Array.isArray(event)) for (let i2 = 0, l2 = event.length; i2 < l2; i2++) event[i2](...args.slice(1)); else event(...args.slice(1));
                }
            }
        }, PortalContextKey = Symbol("PortalContextKey"), useProvidePortal = function(instance) {
            provide(PortalContextKey, {
                inTriggerContext: (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    inTriggerContext: !0
                }).inTriggerContext,
                shouldRender: computed((() => {
                    const {sPopupVisible: sPopupVisible, popupRef: popupRef, forceRender: forceRender, autoDestroy: autoDestroy} = instance || {};
                    let shouldRender = !1;
                    return (sPopupVisible || popupRef || forceRender) && (shouldRender = !0), !sPopupVisible && autoDestroy && (shouldRender = !1), 
                    shouldRender;
                }))
            });
        }, useInjectPortal = () => {
            useProvidePortal({}, {
                inTriggerContext: !1
            });
            const portalContext = inject(PortalContextKey, {
                shouldRender: computed((() => !1)),
                inTriggerContext: !1
            });
            return {
                shouldRender: computed((() => portalContext.shouldRender.value || !1 === portalContext.inTriggerContext))
            };
        }, Portal$1 = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Portal",
            inheritAttrs: !1,
            props: {
                getContainer: PropTypes.func.isRequired,
                didUpdate: Function
            },
            setup(props2, _ref) {
                let container, {slots: slots} = _ref, isSSR = !0;
                const {shouldRender: shouldRender} = useInjectPortal();
                function setContainer() {
                    shouldRender.value && (container = props2.getContainer());
                }
                onBeforeMount((() => {
                    isSSR = !1, setContainer();
                })), onMounted((() => {
                    container || setContainer();
                }));
                const stopWatch = watch(shouldRender, (() => {
                    shouldRender.value && !container && (container = props2.getContainer()), container && stopWatch();
                }));
                return onUpdated((() => {
                    nextTick((() => {
                        var _a;
                        shouldRender.value && (null === (_a = props2.didUpdate) || void 0 === _a || _a.call(props2, props2));
                    }));
                })), () => {
                    var _a;
                    return shouldRender.value ? isSSR ? null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) : container ? createVNode(Teleport, {
                        to: container
                    }, slots) : null : null;
                };
            }
        });
        let cached;
        function getScrollBarSize(fresh) {
            if ("undefined" == typeof document) return 0;
            if (void 0 === cached) {
                const inner = document.createElement("div");
                inner.style.width = "100%", inner.style.height = "200px";
                const outer = document.createElement("div"), outerStyle = outer.style;
                outerStyle.position = "absolute", outerStyle.top = "0", outerStyle.left = "0", outerStyle.pointerEvents = "none", 
                outerStyle.visibility = "hidden", outerStyle.width = "200px", outerStyle.height = "150px", 
                outerStyle.overflow = "hidden", outer.appendChild(inner), document.body.appendChild(outer);
                const widthContained = inner.offsetWidth;
                outer.style.overflow = "scroll";
                let widthScroll = inner.offsetWidth;
                widthContained === widthScroll && (widthScroll = outer.clientWidth), document.body.removeChild(outer), 
                cached = widthContained - widthScroll;
            }
            return cached;
        }
        const UNIQUE_ID = `vc-util-locker-${Date.now()}`;
        let uuid$1 = 0;
        function isBodyOverflowing() {
            return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
        }
        function useScrollLocker(lock) {
            const mergedLock = computed((() => !!lock && !!lock.value));
            uuid$1 += 1;
            const id = `${UNIQUE_ID}_${uuid$1}`;
            watchEffect((onClear => {
                if (canUseDom$1()) {
                    if (mergedLock.value) {
                        const scrollbarSize = getScrollBarSize();
                        updateCSS$1(`\nhtml body {\n  overflow-y: hidden;\n  ${isBodyOverflowing() ? `width: calc(100% - ${scrollbarSize}px);` : ""}\n}`, id);
                    } else removeCSS(id);
                    onClear((() => {
                        removeCSS(id);
                    }));
                }
            }), {
                flush: "post"
            });
        }
        let openCount = 0;
        const supportDom = canUseDom$1(), getParent = getContainer2 => {
            if (!supportDom) return null;
            if (getContainer2) {
                if ("string" == typeof getContainer2) return document.querySelectorAll(getContainer2)[0];
                if ("function" == typeof getContainer2) return getContainer2();
                if ("object" == typeof getContainer2 && getContainer2 instanceof window.HTMLElement) return getContainer2;
            }
            return document.body;
        }, Portal = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "PortalWrapper",
            inheritAttrs: !1,
            props: {
                wrapperClassName: String,
                forceRender: {
                    type: Boolean,
                    default: void 0
                },
                getContainer: PropTypes.any,
                visible: {
                    type: Boolean,
                    default: void 0
                },
                autoLock: booleanType(),
                didUpdate: Function
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const container = shallowRef(), componentRef = shallowRef(), rafId = shallowRef(), triggerUpdate = shallowRef(1), defaultContainer = canUseDom$1() && document.createElement("div"), removeCurrentContainer = () => {
                    var _a, _b;
                    container.value === defaultContainer && (null === (_b = null === (_a = container.value) || void 0 === _a ? void 0 : _a.parentNode) || void 0 === _b || _b.removeChild(container.value)), 
                    container.value = null;
                };
                let parent2 = null;
                const attachToParent = function() {
                    return !(arguments.length > 0 && void 0 !== arguments[0] && arguments[0] || container.value && !container.value.parentNode) || (parent2 = getParent(props2.getContainer), 
                    !!parent2 && (parent2.appendChild(container.value), !0));
                }, getContainer2 = () => supportDom ? (container.value || (container.value = defaultContainer, 
                attachToParent(!0)), setWrapperClassName(), container.value) : null, setWrapperClassName = () => {
                    const {wrapperClassName: wrapperClassName} = props2;
                    container.value && wrapperClassName && wrapperClassName !== container.value.className && (container.value.className = wrapperClassName);
                };
                return onUpdated((() => {
                    setWrapperClassName(), attachToParent();
                })), useScrollLocker(computed((() => props2.autoLock && props2.visible && canUseDom$1() && (container.value === document.body || container.value === defaultContainer)))), 
                onMounted((() => {
                    let init = !1;
                    watch([ () => props2.visible, () => props2.getContainer ], ((_ref2, _ref3) => {
                        let [visible, getContainer22] = _ref2, [prevVisible, prevGetContainer] = _ref3;
                        if (supportDom && (parent2 = getParent(props2.getContainer), parent2 === document.body && (visible && !prevVisible ? openCount += 1 : init && (openCount -= 1))), 
                        init) {
                            ("function" == typeof getContainer22 && "function" == typeof prevGetContainer ? getContainer22.toString() !== prevGetContainer.toString() : getContainer22 !== prevGetContainer) && removeCurrentContainer();
                        }
                        init = !0;
                    }), {
                        immediate: !0,
                        flush: "post"
                    }), nextTick((() => {
                        attachToParent() || (rafId.value = wrapperRaf((() => {
                            triggerUpdate.value += 1;
                        })));
                    }));
                })), onBeforeUnmount((() => {
                    const {visible: visible} = props2;
                    supportDom && parent2 === document.body && (openCount = visible && openCount ? openCount - 1 : openCount), 
                    removeCurrentContainer(), wrapperRaf.cancel(rafId.value);
                })), () => {
                    const {forceRender: forceRender, visible: visible} = props2;
                    let portal = null;
                    const childProps = {
                        getOpenCount: () => openCount,
                        getContainer: getContainer2
                    };
                    return triggerUpdate.value && (forceRender || visible || componentRef.value) && (portal = createVNode(Portal$1, {
                        getContainer: getContainer2,
                        ref: componentRef,
                        didUpdate: props2.didUpdate
                    }, {
                        default: () => {
                            var _a;
                            return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots, childProps);
                        }
                    })), portal;
                };
            }
        }), ALL_HANDLERS = [ "onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu" ], Trigger = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Trigger",
            mixins: [ BaseMixin ],
            inheritAttrs: !1,
            props: triggerProps(),
            setup(props2) {
                const align = computed((() => {
                    const {popupPlacement: popupPlacement, popupAlign: popupAlign, builtinPlacements: builtinPlacements} = props2;
                    return popupPlacement && builtinPlacements ? getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign) : popupAlign;
                })), popupRef = shallowRef(null), setPopupRef = val => {
                    popupRef.value = val;
                };
                return {
                    vcTriggerContext: inject("vcTriggerContext", {}),
                    popupRef: popupRef,
                    setPopupRef: setPopupRef,
                    triggerRef: shallowRef(null),
                    align: align,
                    focusTime: null,
                    clickOutsideHandler: null,
                    contextmenuOutsideHandler1: null,
                    contextmenuOutsideHandler2: null,
                    touchOutsideHandler: null,
                    attachId: null,
                    delayTimer: null,
                    hasPopupMouseDown: !1,
                    preClickTime: null,
                    preTouchTime: null,
                    mouseDownTimeout: null,
                    childOriginEvents: {}
                };
            },
            data() {
                const props2 = this.$props;
                let popupVisible;
                return popupVisible = void 0 !== this.popupVisible ? !!props2.popupVisible : !!props2.defaultPopupVisible, 
                ALL_HANDLERS.forEach((h2 => {
                    this[`fire${h2}`] = e2 => {
                        this.fireEvents(h2, e2);
                    };
                })), {
                    prevPopupVisible: popupVisible,
                    sPopupVisible: popupVisible,
                    point: null
                };
            },
            watch: {
                popupVisible(val) {
                    void 0 !== val && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = val);
                }
            },
            created() {
                provide("vcTriggerContext", {
                    onPopupMouseDown: this.onPopupMouseDown,
                    onPopupMouseenter: this.onPopupMouseenter,
                    onPopupMouseleave: this.onPopupMouseleave
                }), useProvidePortal(this);
            },
            deactivated() {
                this.setPopupVisible(!1);
            },
            mounted() {
                this.$nextTick((() => {
                    this.updatedCal();
                }));
            },
            updated() {
                this.$nextTick((() => {
                    this.updatedCal();
                }));
            },
            beforeUnmount() {
                this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), 
                wrapperRaf.cancel(this.attachId);
            },
            methods: {
                updatedCal() {
                    const props2 = this.$props;
                    if (this.$data.sPopupVisible) {
                        let currentDocument;
                        this.clickOutsideHandler || !this.isClickToHide() && !this.isContextmenuToShow() || (currentDocument = props2.getDocument(this.getRootDomNode()), 
                        this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick)), 
                        this.touchOutsideHandler || (currentDocument = currentDocument || props2.getDocument(this.getRootDomNode()), 
                        this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick, !!supportsPassive && {
                            passive: !1
                        })), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (currentDocument = currentDocument || props2.getDocument(this.getRootDomNode()), 
                        this.contextmenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextmenuClose)), 
                        !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextmenuClose));
                    } else this.clearOutsideHandler();
                },
                onMouseenter(e2) {
                    const {mouseEnterDelay: mouseEnterDelay} = this.$props;
                    this.fireEvents("onMouseenter", e2), this.delaySetPopupVisible(!0, mouseEnterDelay, mouseEnterDelay ? null : e2);
                },
                onMouseMove(e2) {
                    this.fireEvents("onMousemove", e2), this.setPoint(e2);
                },
                onMouseleave(e2) {
                    this.fireEvents("onMouseleave", e2), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
                },
                onPopupMouseenter() {
                    const {vcTriggerContext: vcTriggerContext = {}} = this;
                    vcTriggerContext.onPopupMouseenter && vcTriggerContext.onPopupMouseenter(), this.clearDelayTimer();
                },
                onPopupMouseleave(e2) {
                    var _a;
                    if (e2 && e2.relatedTarget && !e2.relatedTarget.setTimeout && contains$1(null === (_a = this.popupRef) || void 0 === _a ? void 0 : _a.getElement(), e2.relatedTarget)) return;
                    this.isMouseLeaveToHide() && this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
                    const {vcTriggerContext: vcTriggerContext = {}} = this;
                    vcTriggerContext.onPopupMouseleave && vcTriggerContext.onPopupMouseleave(e2);
                },
                onFocus(e2) {
                    this.fireEvents("onFocus", e2), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), 
                    this.delaySetPopupVisible(!0, this.$props.focusDelay));
                },
                onMousedown(e2) {
                    this.fireEvents("onMousedown", e2), this.preClickTime = Date.now();
                },
                onTouchstart(e2) {
                    this.fireEvents("onTouchstart", e2), this.preTouchTime = Date.now();
                },
                onBlur(e2) {
                    contains$1(e2.target, e2.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", e2), 
                    this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay));
                },
                onContextmenu(e2) {
                    e2.preventDefault(), this.fireEvents("onContextmenu", e2), this.setPopupVisible(!0, e2);
                },
                onContextmenuClose() {
                    this.isContextmenuToShow() && this.close();
                },
                onClick(event) {
                    if (this.fireEvents("onClick", event), this.focusTime) {
                        let preTime;
                        if (this.preClickTime && this.preTouchTime ? preTime = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? preTime = this.preClickTime : this.preTouchTime && (preTime = this.preTouchTime), 
                        Math.abs(preTime - this.focusTime) < 20) return;
                        this.focusTime = 0;
                    }
                    this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && event && event.preventDefault && event.preventDefault(), 
                    event && event.domEvent && event.domEvent.preventDefault();
                    const nextVisible = !this.$data.sPopupVisible;
                    (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, event);
                },
                onPopupMouseDown() {
                    const {vcTriggerContext: vcTriggerContext = {}} = this;
                    this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout((() => {
                        this.hasPopupMouseDown = !1;
                    }), 0), vcTriggerContext.onPopupMouseDown && vcTriggerContext.onPopupMouseDown(...arguments);
                },
                onDocumentClick(event) {
                    if (this.$props.mask && !this.$props.maskClosable) return;
                    const target = event.target, root2 = this.getRootDomNode(), popupNode = this.getPopupDomNode();
                    contains$1(root2, target) && !this.isContextMenuOnly() || contains$1(popupNode, target) || this.hasPopupMouseDown || this.delaySetPopupVisible(!1, .1);
                },
                getPopupDomNode() {
                    var _a;
                    return (null === (_a = this.popupRef) || void 0 === _a ? void 0 : _a.getElement()) || null;
                },
                getRootDomNode() {
                    var _a, _b, _c, _d;
                    const {getTriggerDOMNode: getTriggerDOMNode} = this.$props;
                    if (getTriggerDOMNode) {
                        const domNode = "#comment" === (null === (_b = null === (_a = this.triggerRef) || void 0 === _a ? void 0 : _a.$el) || void 0 === _b ? void 0 : _b.nodeName) ? null : findDOMNode(this.triggerRef);
                        return findDOMNode(getTriggerDOMNode(domNode));
                    }
                    try {
                        const domNode = "#comment" === (null === (_d = null === (_c = this.triggerRef) || void 0 === _c ? void 0 : _c.$el) || void 0 === _d ? void 0 : _d.nodeName) ? null : findDOMNode(this.triggerRef);
                        if (domNode) return domNode;
                    } catch (err) {}
                    return findDOMNode(this);
                },
                handleGetPopupClassFromAlign(align) {
                    const className = [], props2 = this.$props, {popupPlacement: popupPlacement, builtinPlacements: builtinPlacements, prefixCls: prefixCls, alignPoint: alignPoint2, getPopupClassNameFromAlign: getPopupClassNameFromAlign} = props2;
                    return popupPlacement && builtinPlacements && className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2)), 
                    getPopupClassNameFromAlign && className.push(getPopupClassNameFromAlign(align)), 
                    className.join(" ");
                },
                getPopupAlign() {
                    const props2 = this.$props, {popupPlacement: popupPlacement, popupAlign: popupAlign, builtinPlacements: builtinPlacements} = props2;
                    return popupPlacement && builtinPlacements ? getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign) : popupAlign;
                },
                getComponent() {
                    const mouseProps = {};
                    this.isMouseEnterToShow() && (mouseProps.onMouseenter = this.onPopupMouseenter), 
                    this.isMouseLeaveToHide() && (mouseProps.onMouseleave = this.onPopupMouseleave), 
                    mouseProps.onMousedown = this.onPopupMouseDown, mouseProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
                    const {handleGetPopupClassFromAlign: handleGetPopupClassFromAlign, getRootDomNode: getRootDomNode, $attrs: $attrs} = this, {prefixCls: prefixCls, destroyPopupOnHide: destroyPopupOnHide, popupClassName: popupClassName, popupAnimation: popupAnimation, popupTransitionName: popupTransitionName, popupStyle: popupStyle, mask: mask, maskAnimation: maskAnimation, maskTransitionName: maskTransitionName, zIndex: zIndex, stretch: stretch, alignPoint: alignPoint2, mobile: mobile, arrow: arrow, forceRender: forceRender} = this.$props, {sPopupVisible: sPopupVisible, point: point} = this.$data, popupProps2 = _extends$1(_extends$1({
                        prefixCls: prefixCls,
                        arrow: arrow,
                        destroyPopupOnHide: destroyPopupOnHide,
                        visible: sPopupVisible,
                        point: alignPoint2 ? point : null,
                        align: this.align,
                        animation: popupAnimation,
                        getClassNameFromAlign: handleGetPopupClassFromAlign,
                        stretch: stretch,
                        getRootDomNode: getRootDomNode,
                        mask: mask,
                        zIndex: zIndex,
                        transitionName: popupTransitionName,
                        maskAnimation: maskAnimation,
                        maskTransitionName: maskTransitionName,
                        class: popupClassName,
                        style: popupStyle,
                        onAlign: $attrs.onPopupAlign || noop$1
                    }, mouseProps), {
                        ref: this.setPopupRef,
                        mobile: mobile,
                        forceRender: forceRender
                    });
                    return createVNode(Popup, popupProps2, {
                        default: this.$slots.popup || (() => getComponent(this, "popup"))
                    });
                },
                attachParent(popupContainer) {
                    wrapperRaf.cancel(this.attachId);
                    const {getPopupContainer: getPopupContainer, getDocument: getDocument2} = this.$props, domNode = this.getRootDomNode();
                    let mountNode;
                    getPopupContainer ? (domNode || 0 === getPopupContainer.length) && (mountNode = getPopupContainer(domNode)) : mountNode = getDocument2(this.getRootDomNode()).body, 
                    mountNode ? mountNode.appendChild(popupContainer) : this.attachId = wrapperRaf((() => {
                        this.attachParent(popupContainer);
                    }));
                },
                getContainer() {
                    const {$props: props2} = this, {getDocument: getDocument2} = props2, popupContainer = getDocument2(this.getRootDomNode()).createElement("div");
                    return popupContainer.style.position = "absolute", popupContainer.style.top = "0", 
                    popupContainer.style.left = "0", popupContainer.style.width = "100%", this.attachParent(popupContainer), 
                    popupContainer;
                },
                setPopupVisible(sPopupVisible, event) {
                    const {alignPoint: alignPoint2, sPopupVisible: prevPopupVisible, onPopupVisibleChange: onPopupVisibleChange} = this;
                    this.clearDelayTimer(), prevPopupVisible !== sPopupVisible && (hasProp(this, "popupVisible") || this.setState({
                        sPopupVisible: sPopupVisible,
                        prevPopupVisible: prevPopupVisible
                    }), onPopupVisibleChange && onPopupVisibleChange(sPopupVisible)), alignPoint2 && event && sPopupVisible && this.setPoint(event);
                },
                setPoint(point) {
                    const {alignPoint: alignPoint2} = this.$props;
                    alignPoint2 && point && this.setState({
                        point: {
                            pageX: point.pageX,
                            pageY: point.pageY
                        }
                    });
                },
                handlePortalUpdate() {
                    this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible);
                },
                delaySetPopupVisible(visible, delayS, event) {
                    const delay = 1e3 * delayS;
                    if (this.clearDelayTimer(), delay) {
                        const point = event ? {
                            pageX: event.pageX,
                            pageY: event.pageY
                        } : null;
                        this.delayTimer = setTimeout((() => {
                            this.setPopupVisible(visible, point), this.clearDelayTimer();
                        }), delay);
                    } else this.setPopupVisible(visible, event);
                },
                clearDelayTimer() {
                    this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null);
                },
                clearOutsideHandler() {
                    this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), 
                    this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), 
                    this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), 
                    this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
                },
                createTwoChains(event) {
                    let fn = () => {};
                    const events = getEvents(this);
                    return this.childOriginEvents[event] && events[event] ? this[`fire${event}`] : (fn = this.childOriginEvents[event] || events[event] || fn, 
                    fn);
                },
                isClickToShow() {
                    const {action: action, showAction: showAction} = this.$props;
                    return -1 !== action.indexOf("click") || -1 !== showAction.indexOf("click");
                },
                isContextMenuOnly() {
                    const {action: action} = this.$props;
                    return "contextmenu" === action || 1 === action.length && "contextmenu" === action[0];
                },
                isContextmenuToShow() {
                    const {action: action, showAction: showAction} = this.$props;
                    return -1 !== action.indexOf("contextmenu") || -1 !== showAction.indexOf("contextmenu");
                },
                isClickToHide() {
                    const {action: action, hideAction: hideAction} = this.$props;
                    return -1 !== action.indexOf("click") || -1 !== hideAction.indexOf("click");
                },
                isMouseEnterToShow() {
                    const {action: action, showAction: showAction} = this.$props;
                    return -1 !== action.indexOf("hover") || -1 !== showAction.indexOf("mouseenter");
                },
                isMouseLeaveToHide() {
                    const {action: action, hideAction: hideAction} = this.$props;
                    return -1 !== action.indexOf("hover") || -1 !== hideAction.indexOf("mouseleave");
                },
                isFocusToShow() {
                    const {action: action, showAction: showAction} = this.$props;
                    return -1 !== action.indexOf("focus") || -1 !== showAction.indexOf("focus");
                },
                isBlurToHide() {
                    const {action: action, hideAction: hideAction} = this.$props;
                    return -1 !== action.indexOf("focus") || -1 !== hideAction.indexOf("blur");
                },
                forcePopupAlign() {
                    var _a;
                    this.$data.sPopupVisible && (null === (_a = this.popupRef) || void 0 === _a || _a.forceAlign());
                },
                fireEvents(type, e2) {
                    this.childOriginEvents[type] && this.childOriginEvents[type](e2);
                    const event = this.$props[type] || this.$attrs[type];
                    event && event(e2);
                },
                close() {
                    this.setPopupVisible(!1);
                }
            },
            render() {
                const {$attrs: $attrs} = this, children = filterEmpty(getSlot(this)), {alignPoint: alignPoint2, getPopupContainer: getPopupContainer} = this.$props, child = children[0];
                this.childOriginEvents = getEvents(child);
                const newChildProps = {
                    key: "trigger"
                };
                this.isContextmenuToShow() ? newChildProps.onContextmenu = this.onContextmenu : newChildProps.onContextmenu = this.createTwoChains("onContextmenu"), 
                this.isClickToHide() || this.isClickToShow() ? (newChildProps.onClick = this.onClick, 
                newChildProps.onMousedown = this.onMousedown, newChildProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (newChildProps.onClick = this.createTwoChains("onClick"), 
                newChildProps.onMousedown = this.createTwoChains("onMousedown"), newChildProps[supportsPassive ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), 
                this.isMouseEnterToShow() ? (newChildProps.onMouseenter = this.onMouseenter, alignPoint2 && (newChildProps.onMousemove = this.onMouseMove)) : newChildProps.onMouseenter = this.createTwoChains("onMouseenter"), 
                this.isMouseLeaveToHide() ? newChildProps.onMouseleave = this.onMouseleave : newChildProps.onMouseleave = this.createTwoChains("onMouseleave"), 
                this.isFocusToShow() || this.isBlurToHide() ? (newChildProps.onFocus = this.onFocus, 
                newChildProps.onBlur = this.onBlur) : (newChildProps.onFocus = this.createTwoChains("onFocus"), 
                newChildProps.onBlur = e2 => {
                    !e2 || e2.relatedTarget && contains$1(e2.target, e2.relatedTarget) || this.createTwoChains("onBlur")(e2);
                });
                const childrenClassName = classNames(child && child.props && child.props.class, $attrs.class);
                childrenClassName && (newChildProps.class = childrenClassName);
                const trigger2 = cloneElement(child, _extends$1(_extends$1({}, newChildProps), {
                    ref: "triggerRef"
                }), !0, !0), portal = createVNode(Portal, {
                    key: "portal",
                    getContainer: getPopupContainer && (() => getPopupContainer(this.getRootDomNode())),
                    didUpdate: this.handlePortalUpdate,
                    visible: this.$data.sPopupVisible
                }, {
                    default: this.getComponent
                });
                return createVNode(Fragment, null, [ trigger2, portal ]);
            }
        });
        var __rest$k = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const getBuiltInPlacements = dropdownMatchSelectWidth => {
            const adjustX = !0 === dropdownMatchSelectWidth ? 0 : 1;
            return {
                bottomLeft: {
                    points: [ "tl", "bl" ],
                    offset: [ 0, 4 ],
                    overflow: {
                        adjustX: adjustX,
                        adjustY: 1
                    }
                },
                bottomRight: {
                    points: [ "tr", "br" ],
                    offset: [ 0, 4 ],
                    overflow: {
                        adjustX: adjustX,
                        adjustY: 1
                    }
                },
                topLeft: {
                    points: [ "bl", "tl" ],
                    offset: [ 0, -4 ],
                    overflow: {
                        adjustX: adjustX,
                        adjustY: 1
                    }
                },
                topRight: {
                    points: [ "br", "tr" ],
                    offset: [ 0, -4 ],
                    overflow: {
                        adjustX: adjustX,
                        adjustY: 1
                    }
                }
            };
        }, SelectTrigger = defineComponent({
            name: "SelectTrigger",
            inheritAttrs: !1,
            props: {
                dropdownAlign: Object,
                visible: {
                    type: Boolean,
                    default: void 0
                },
                disabled: {
                    type: Boolean,
                    default: void 0
                },
                dropdownClassName: String,
                dropdownStyle: PropTypes.object,
                placement: String,
                empty: {
                    type: Boolean,
                    default: void 0
                },
                prefixCls: String,
                popupClassName: String,
                animation: String,
                transitionName: String,
                getPopupContainer: Function,
                dropdownRender: Function,
                containerWidth: Number,
                dropdownMatchSelectWidth: PropTypes.oneOfType([ Number, Boolean ]).def(!0),
                popupElement: PropTypes.any,
                direction: String,
                getTriggerDOMNode: Function,
                onPopupVisibleChange: Function,
                onPopupMouseEnter: Function,
                onPopupFocusin: Function,
                onPopupFocusout: Function
            },
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs, expose: expose} = _ref;
                const builtInPlacements = computed((() => {
                    const {dropdownMatchSelectWidth: dropdownMatchSelectWidth} = props2;
                    return getBuiltInPlacements(dropdownMatchSelectWidth);
                })), popupRef = ref();
                return expose({
                    getPopupElement: () => popupRef.value
                }), () => {
                    const _a = _extends$1(_extends$1({}, props2), attrs), {empty: empty = !1} = _a, restProps = __rest$k(_a, [ "empty" ]), {visible: visible, dropdownAlign: dropdownAlign, prefixCls: prefixCls, popupElement: popupElement, dropdownClassName: dropdownClassName, dropdownStyle: dropdownStyle, direction: direction = "ltr", placement: placement, dropdownMatchSelectWidth: dropdownMatchSelectWidth, containerWidth: containerWidth, dropdownRender: dropdownRender, animation: animation, transitionName: transitionName2, getPopupContainer: getPopupContainer, getTriggerDOMNode: getTriggerDOMNode, onPopupVisibleChange: onPopupVisibleChange, onPopupMouseEnter: onPopupMouseEnter, onPopupFocusin: onPopupFocusin, onPopupFocusout: onPopupFocusout} = restProps, dropdownPrefixCls = `${prefixCls}-dropdown`;
                    let popupNode = popupElement;
                    dropdownRender && (popupNode = dropdownRender({
                        menuNode: popupElement,
                        props: props2
                    }));
                    const mergedTransitionName = animation ? `${dropdownPrefixCls}-${animation}` : transitionName2, popupStyle = _extends$1({
                        minWidth: `${containerWidth}px`
                    }, dropdownStyle);
                    return "number" == typeof dropdownMatchSelectWidth ? popupStyle.width = `${dropdownMatchSelectWidth}px` : dropdownMatchSelectWidth && (popupStyle.width = `${containerWidth}px`), 
                    createVNode(Trigger, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
                        showAction: onPopupVisibleChange ? [ "click" ] : [],
                        hideAction: onPopupVisibleChange ? [ "click" ] : [],
                        popupPlacement: placement || ("rtl" === direction ? "bottomRight" : "bottomLeft"),
                        builtinPlacements: builtInPlacements.value,
                        prefixCls: dropdownPrefixCls,
                        popupTransitionName: mergedTransitionName,
                        popupAlign: dropdownAlign,
                        popupVisible: visible,
                        getPopupContainer: getPopupContainer,
                        popupClassName: classNames(dropdownClassName, {
                            [`${dropdownPrefixCls}-empty`]: empty
                        }),
                        popupStyle: popupStyle,
                        getTriggerDOMNode: getTriggerDOMNode,
                        onPopupVisibleChange: onPopupVisibleChange
                    }), {
                        default: slots.default,
                        popup: () => createVNode("div", {
                            ref: popupRef,
                            onMouseenter: onPopupMouseEnter,
                            onFocusin: onPopupFocusin,
                            onFocusout: onPopupFocusout
                        }, [ popupNode ])
                    });
                };
            }
        }), KeyCode = {
            MAC_ENTER: 3,
            BACKSPACE: 8,
            TAB: 9,
            NUM_CENTER: 12,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAUSE: 19,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PRINT_SCREEN: 44,
            INSERT: 45,
            DELETE: 46,
            ZERO: 48,
            ONE: 49,
            TWO: 50,
            THREE: 51,
            FOUR: 52,
            FIVE: 53,
            SIX: 54,
            SEVEN: 55,
            EIGHT: 56,
            NINE: 57,
            QUESTION_MARK: 63,
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 90,
            META: 91,
            WIN_KEY_RIGHT: 92,
            CONTEXT_MENU: 93,
            NUM_ZERO: 96,
            NUM_ONE: 97,
            NUM_TWO: 98,
            NUM_THREE: 99,
            NUM_FOUR: 100,
            NUM_FIVE: 101,
            NUM_SIX: 102,
            NUM_SEVEN: 103,
            NUM_EIGHT: 104,
            NUM_NINE: 105,
            NUM_MULTIPLY: 106,
            NUM_PLUS: 107,
            NUM_MINUS: 109,
            NUM_PERIOD: 110,
            NUM_DIVISION: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            NUMLOCK: 144,
            SEMICOLON: 186,
            DASH: 189,
            EQUALS: 187,
            COMMA: 188,
            PERIOD: 190,
            SLASH: 191,
            APOSTROPHE: 192,
            SINGLE_QUOTE: 222,
            OPEN_SQUARE_BRACKET: 219,
            BACKSLASH: 220,
            CLOSE_SQUARE_BRACKET: 221,
            WIN_KEY: 224,
            MAC_FF_META: 224,
            WIN_IME: 229,
            isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
                const {keyCode: keyCode} = e2;
                if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return !1;
                switch (keyCode) {
                  case KeyCode.ALT:
                  case KeyCode.CAPS_LOCK:
                  case KeyCode.CONTEXT_MENU:
                  case KeyCode.CTRL:
                  case KeyCode.DOWN:
                  case KeyCode.END:
                  case KeyCode.ESC:
                  case KeyCode.HOME:
                  case KeyCode.INSERT:
                  case KeyCode.LEFT:
                  case KeyCode.MAC_FF_META:
                  case KeyCode.META:
                  case KeyCode.NUMLOCK:
                  case KeyCode.NUM_CENTER:
                  case KeyCode.PAGE_DOWN:
                  case KeyCode.PAGE_UP:
                  case KeyCode.PAUSE:
                  case KeyCode.PRINT_SCREEN:
                  case KeyCode.RIGHT:
                  case KeyCode.SHIFT:
                  case KeyCode.UP:
                  case KeyCode.WIN_KEY:
                  case KeyCode.WIN_KEY_RIGHT:
                    return !1;

                  default:
                    return !0;
                }
            },
            isCharacterKey: function isCharacterKey(keyCode) {
                if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return !0;
                if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return !0;
                if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return !0;
                if (-1 !== window.navigator.userAgent.indexOf("WebKit") && 0 === keyCode) return !0;
                switch (keyCode) {
                  case KeyCode.SPACE:
                  case KeyCode.QUESTION_MARK:
                  case KeyCode.NUM_PLUS:
                  case KeyCode.NUM_MINUS:
                  case KeyCode.NUM_PERIOD:
                  case KeyCode.NUM_DIVISION:
                  case KeyCode.SEMICOLON:
                  case KeyCode.DASH:
                  case KeyCode.EQUALS:
                  case KeyCode.COMMA:
                  case KeyCode.PERIOD:
                  case KeyCode.SLASH:
                  case KeyCode.APOSTROPHE:
                  case KeyCode.SINGLE_QUOTE:
                  case KeyCode.OPEN_SQUARE_BRACKET:
                  case KeyCode.BACKSLASH:
                  case KeyCode.CLOSE_SQUARE_BRACKET:
                    return !0;

                  default:
                    return !1;
                }
            }
        }, TransBtn = (props2, _ref) => {
            let {slots: slots} = _ref;
            var _a;
            const {class: className, customizeIcon: customizeIcon, customizeIconProps: customizeIconProps, onMousedown: onMousedown, onClick: onClick} = props2;
            let icon;
            return icon = "function" == typeof customizeIcon ? customizeIcon(customizeIconProps) : isVNode(customizeIcon) ? cloneVNode(customizeIcon) : customizeIcon, 
            createVNode("span", {
                class: className,
                onMousedown: event => {
                    event.preventDefault(), onMousedown && onMousedown(event);
                },
                style: {
                    userSelect: "none",
                    WebkitUserSelect: "none"
                },
                unselectable: "on",
                onClick: onClick,
                "aria-hidden": !0
            }, [ void 0 !== icon ? icon : createVNode("span", {
                class: className.split(/\s+/).map((cls => `${cls}-icon`))
            }, [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]) ]);
        };
        TransBtn.inheritAttrs = !1, TransBtn.displayName = "TransBtn", TransBtn.props = {
            class: String,
            customizeIcon: PropTypes.any,
            customizeIconProps: PropTypes.any,
            onMousedown: Function,
            onClick: Function
        };
        var __rest$j = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const BaseInputInner = defineComponent({
            compatConfig: {
                MODE: 3
            },
            props: {
                disabled: PropTypes.looseBool,
                type: PropTypes.string,
                value: PropTypes.any,
                tag: {
                    type: String,
                    default: "input"
                },
                size: PropTypes.string,
                onChange: Function,
                onInput: Function,
                onBlur: Function,
                onFocus: Function,
                onKeydown: Function,
                onCompositionstart: Function,
                onCompositionend: Function,
                onKeyup: Function,
                onPaste: Function,
                onMousedown: Function
            },
            emits: [ "change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown" ],
            setup(props2, _ref) {
                let {expose: expose} = _ref;
                const inputRef = shallowRef(null);
                return expose({
                    focus: () => {
                        inputRef.value && inputRef.value.focus();
                    },
                    blur: () => {
                        inputRef.value && inputRef.value.blur();
                    },
                    input: inputRef,
                    setSelectionRange: (start, end, direction) => {
                        var _a;
                        null === (_a = inputRef.value) || void 0 === _a || _a.setSelectionRange(start, end, direction);
                    },
                    select: () => {
                        var _a;
                        null === (_a = inputRef.value) || void 0 === _a || _a.select();
                    },
                    getSelectionStart: () => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.selectionStart;
                    },
                    getSelectionEnd: () => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.selectionEnd;
                    },
                    getScrollTop: () => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.scrollTop;
                    }
                }), () => {
                    const {tag: Tag2, value: value} = props2, restProps = __rest$j(props2, [ "tag", "value" ]);
                    return createVNode(Tag2, _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
                        ref: inputRef,
                        value: value
                    }), null);
                };
            }
        });
        function styleObjectToString(style) {
            return Object.keys(style).reduce(((acc, name) => {
                const styleValue = style[name];
                return null == styleValue ? acc : acc += `${name}: ${style[name]};`;
            }), "");
        }
        var __rest$i = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const BaseInput = defineComponent({
            compatConfig: {
                MODE: 3
            },
            inheritAttrs: !1,
            props: {
                disabled: PropTypes.looseBool,
                type: PropTypes.string,
                value: PropTypes.any,
                lazy: PropTypes.bool.def(!0),
                tag: {
                    type: String,
                    default: "input"
                },
                size: PropTypes.string,
                style: PropTypes.oneOfType([ String, Object ]),
                class: PropTypes.string
            },
            emits: [ "change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown" ],
            setup(props2, _ref) {
                let {emit: emit2, attrs: attrs, expose: expose} = _ref;
                const inputRef = shallowRef(null), renderValue = ref(), isComposing = ref(!1);
                watch([ () => props2.value, isComposing ], (() => {
                    isComposing.value || (renderValue.value = props2.value);
                }), {
                    immediate: !0
                });
                const handleChange = e2 => {
                    emit2("change", e2);
                }, onCompositionstart = e2 => {
                    isComposing.value = !0, e2.target.composing = !0, emit2("compositionstart", e2);
                }, onCompositionend = e2 => {
                    isComposing.value = !1, e2.target.composing = !1, emit2("compositionend", e2);
                    const event = document.createEvent("HTMLEvents");
                    event.initEvent("input", !0, !0), e2.target.dispatchEvent(event), handleChange(e2);
                }, handleInput = e2 => {
                    isComposing.value && props2.lazy ? renderValue.value = e2.target.value : emit2("input", e2);
                }, handleBlur = e2 => {
                    emit2("blur", e2);
                }, handleFocus = e2 => {
                    emit2("focus", e2);
                }, handleKeyDown = e2 => {
                    emit2("keydown", e2);
                }, handleKeyUp = e2 => {
                    emit2("keyup", e2);
                }, setSelectionRange = (start, end, direction) => {
                    var _a;
                    null === (_a = inputRef.value) || void 0 === _a || _a.setSelectionRange(start, end, direction);
                }, select = () => {
                    var _a;
                    null === (_a = inputRef.value) || void 0 === _a || _a.select();
                };
                expose({
                    focus: () => {
                        inputRef.value && inputRef.value.focus();
                    },
                    blur: () => {
                        inputRef.value && inputRef.value.blur();
                    },
                    input: computed((() => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.input;
                    })),
                    setSelectionRange: setSelectionRange,
                    select: select,
                    getSelectionStart: () => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.getSelectionStart();
                    },
                    getSelectionEnd: () => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.getSelectionEnd();
                    },
                    getScrollTop: () => {
                        var _a;
                        return null === (_a = inputRef.value) || void 0 === _a ? void 0 : _a.getScrollTop();
                    }
                });
                const handleMousedown = e2 => {
                    emit2("mousedown", e2);
                }, handlePaste = e2 => {
                    emit2("paste", e2);
                }, styleString = computed((() => props2.style && "string" != typeof props2.style ? styleObjectToString(props2.style) : props2.style));
                return () => {
                    const restProps = __rest$i(props2, [ "style", "lazy" ]);
                    return createVNode(BaseInputInner, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, restProps), attrs), {}, {
                        style: styleString.value,
                        onInput: handleInput,
                        onChange: handleChange,
                        onBlur: handleBlur,
                        onFocus: handleFocus,
                        ref: inputRef,
                        value: renderValue.value,
                        onCompositionstart: onCompositionstart,
                        onCompositionend: onCompositionend,
                        onKeyup: handleKeyUp,
                        onKeydown: handleKeyDown,
                        onPaste: handlePaste,
                        onMousedown: handleMousedown
                    }), null);
                };
            }
        }), Input = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "SelectInput",
            inheritAttrs: !1,
            props: {
                inputRef: PropTypes.any,
                prefixCls: String,
                id: String,
                inputElement: PropTypes.VueNode,
                disabled: {
                    type: Boolean,
                    default: void 0
                },
                autofocus: {
                    type: Boolean,
                    default: void 0
                },
                autocomplete: String,
                editable: {
                    type: Boolean,
                    default: void 0
                },
                activeDescendantId: String,
                value: String,
                open: {
                    type: Boolean,
                    default: void 0
                },
                tabindex: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),
                attrs: PropTypes.object,
                onKeydown: {
                    type: Function
                },
                onMousedown: {
                    type: Function
                },
                onChange: {
                    type: Function
                },
                onPaste: {
                    type: Function
                },
                onCompositionstart: {
                    type: Function
                },
                onCompositionend: {
                    type: Function
                },
                onFocus: {
                    type: Function
                },
                onBlur: {
                    type: Function
                }
            },
            setup(props2) {
                let blurTimeout = null;
                const VCSelectContainerEvent = inject("VCSelectContainerEvent");
                return () => {
                    var _a;
                    const {prefixCls: prefixCls, id: id, inputElement: inputElement, disabled: disabled, tabindex: tabindex, autofocus: autofocus, autocomplete: autocomplete, editable: editable, activeDescendantId: activeDescendantId, value: value, onKeydown: onKeydown, onMousedown: onMousedown, onChange: onChange, onPaste: onPaste, onCompositionstart: onCompositionstart, onCompositionend: onCompositionend, onFocus: onFocus, onBlur: onBlur, open: open2, inputRef: inputRef, attrs: attrs} = props2;
                    let inputNode = inputElement || createVNode(BaseInput, null, null);
                    const inputProps2 = inputNode.props || {}, {onKeydown: onOriginKeyDown, onInput: onOriginInput, onFocus: onOriginFocus, onBlur: onOriginBlur, onMousedown: onOriginMouseDown, onCompositionstart: onOriginCompositionStart, onCompositionend: onOriginCompositionEnd, style: style} = inputProps2;
                    return inputNode = cloneElement(inputNode, _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({
                        type: "search"
                    }, inputProps2), {
                        id: id,
                        ref: inputRef,
                        disabled: disabled,
                        tabindex: tabindex,
                        lazy: !1,
                        autocomplete: autocomplete || "off",
                        autofocus: autofocus,
                        class: classNames(`${prefixCls}-selection-search-input`, null === (_a = null == inputNode ? void 0 : inputNode.props) || void 0 === _a ? void 0 : _a.class),
                        role: "combobox",
                        "aria-expanded": open2,
                        "aria-haspopup": "listbox",
                        "aria-owns": `${id}_list`,
                        "aria-autocomplete": "list",
                        "aria-controls": `${id}_list`,
                        "aria-activedescendant": activeDescendantId
                    }), attrs), {
                        value: editable ? value : "",
                        readonly: !editable,
                        unselectable: editable ? null : "on",
                        style: _extends$1(_extends$1({}, style), {
                            opacity: editable ? null : 0
                        }),
                        onKeydown: event => {
                            onKeydown(event), onOriginKeyDown && onOriginKeyDown(event);
                        },
                        onMousedown: event => {
                            onMousedown(event), onOriginMouseDown && onOriginMouseDown(event);
                        },
                        onInput: event => {
                            onChange(event), onOriginInput && onOriginInput(event);
                        },
                        onCompositionstart(event) {
                            onCompositionstart(event), onOriginCompositionStart && onOriginCompositionStart(event);
                        },
                        onCompositionend(event) {
                            onCompositionend(event), onOriginCompositionEnd && onOriginCompositionEnd(event);
                        },
                        onPaste: onPaste,
                        onFocus: function() {
                            clearTimeout(blurTimeout), onOriginFocus && onOriginFocus(arguments.length <= 0 ? void 0 : arguments[0]), 
                            onFocus && onFocus(arguments.length <= 0 ? void 0 : arguments[0]), null == VCSelectContainerEvent || VCSelectContainerEvent.focus(arguments.length <= 0 ? void 0 : arguments[0]);
                        },
                        onBlur: function() {
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                            blurTimeout = setTimeout((() => {
                                onOriginBlur && onOriginBlur(args[0]), onBlur && onBlur(args[0]), null == VCSelectContainerEvent || VCSelectContainerEvent.blur(args[0]);
                            }), 100);
                        }
                    }), "textarea" === inputNode.type ? {} : {
                        type: "search"
                    }), !0, !0), inputNode;
                };
            }
        }), propList = `${"accept acceptcharset accesskey action allowfullscreen allowtransparency\nalt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge\ncharset checked classid classname colspan cols content contenteditable contextmenu\ncontrols coords crossorigin data datetime default defer dir disabled download draggable\nenctype form formaction formenctype formmethod formnovalidate formtarget frameborder\nheaders height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity\nis keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media\nmediagroup method min minlength multiple muted name novalidate nonce open\noptimum pattern placeholder poster preload radiogroup readonly rel required\nreversed role rowspan rows sandbox scope scoped scrolling seamless selected\nshape size sizes span spellcheck src srcdoc srclang srcset start step style\nsummary tabindex target title type usemap value width wmode wrap"} ${"onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown\n    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick\n    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown\n    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel\n    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough\n    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata\n    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError"}`.split(/[\s\n]+/), ariaPrefix = "aria-", dataPrefix = "data-";
        function match(key2, prefix) {
            return 0 === key2.indexOf(prefix);
        }
        function pickAttrs(props2) {
            let mergedConfig, ariaOnly = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            mergedConfig = !1 === ariaOnly ? {
                aria: !0,
                data: !0,
                attr: !0
            } : !0 === ariaOnly ? {
                aria: !0
            } : _extends$1({}, ariaOnly);
            const attrs = {};
            return Object.keys(props2).forEach((key2 => {
                (mergedConfig.aria && ("role" === key2 || match(key2, ariaPrefix)) || mergedConfig.data && match(key2, dataPrefix) || mergedConfig.attr && (propList.includes(key2) || propList.includes(key2.toLowerCase()))) && (attrs[key2] = props2[key2]);
            })), attrs;
        }
        const OverflowContextProviderKey = Symbol("OverflowContextProviderKey"), OverflowContextProvider = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "OverflowContextProvider",
            inheritAttrs: !1,
            props: {
                value: {
                    type: Object
                }
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                return provide(OverflowContextProviderKey, computed((() => props2.value))), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        }), useInjectOverflowContext = () => inject(OverflowContextProviderKey, computed((() => null)));
        var __rest$h = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const UNDEFINED = void 0, Item$1 = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Item",
            props: {
                prefixCls: String,
                item: PropTypes.any,
                renderItem: Function,
                responsive: Boolean,
                itemKey: {
                    type: [ String, Number ]
                },
                registerSize: Function,
                display: Boolean,
                order: Number,
                component: PropTypes.any,
                invalidate: Boolean
            },
            setup(props2, _ref) {
                let {slots: slots, expose: expose} = _ref;
                const mergedHidden = computed((() => props2.responsive && !props2.display)), itemNodeRef = ref();
                function internalRegisterSize(width) {
                    props2.registerSize(props2.itemKey, width);
                }
                return expose({
                    itemNodeRef: itemNodeRef
                }), onUnmounted((() => {
                    internalRegisterSize(null);
                })), () => {
                    var _a;
                    const {prefixCls: prefixCls, invalidate: invalidate, item: item, renderItem: renderItem, responsive: responsive, registerSize: registerSize, itemKey: itemKey, display: display, order: order, component: Component = "div"} = props2, restProps = __rest$h(props2, [ "prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component" ]), children = null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots), childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
                    let overflowStyle;
                    invalidate || (overflowStyle = {
                        opacity: mergedHidden.value ? 0 : 1,
                        height: mergedHidden.value ? 0 : UNDEFINED,
                        overflowY: mergedHidden.value ? "hidden" : UNDEFINED,
                        order: responsive ? order : UNDEFINED,
                        pointerEvents: mergedHidden.value ? "none" : UNDEFINED,
                        position: mergedHidden.value ? "absolute" : UNDEFINED
                    });
                    const overflowProps2 = {};
                    return mergedHidden.value && (overflowProps2["aria-hidden"] = !0), createVNode(ResizeObserver$1, {
                        disabled: !responsive,
                        onResize: _ref2 => {
                            let {offsetWidth: offsetWidth} = _ref2;
                            internalRegisterSize(offsetWidth);
                        }
                    }, {
                        default: () => createVNode(Component, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                            class: classNames(!invalidate && prefixCls),
                            style: overflowStyle
                        }, overflowProps2), restProps), {}, {
                            ref: itemNodeRef
                        }), {
                            default: () => [ childNode ]
                        })
                    });
                };
            }
        });
        var __rest$g = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const RawItem = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "RawItem",
            inheritAttrs: !1,
            props: {
                component: PropTypes.any,
                title: PropTypes.any,
                id: String,
                onMouseenter: {
                    type: Function
                },
                onMouseleave: {
                    type: Function
                },
                onClick: {
                    type: Function
                },
                onKeydown: {
                    type: Function
                },
                onFocus: {
                    type: Function
                },
                role: String,
                tabindex: Number
            },
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs} = _ref;
                const context = useInjectOverflowContext();
                return () => {
                    var _a;
                    if (!context.value) {
                        const {component: Component = "div"} = props2, restProps2 = __rest$g(props2, [ "component" ]);
                        return createVNode(Component, _objectSpread2$1(_objectSpread2$1({}, restProps2), attrs), {
                            default: () => [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]
                        });
                    }
                    const _b = context.value, {className: contextClassName} = _b, restContext = __rest$g(_b, [ "className" ]), {class: className} = attrs, restProps = __rest$g(attrs, [ "class" ]);
                    return createVNode(OverflowContextProvider, {
                        value: null
                    }, {
                        default: () => [ createVNode(Item$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                            class: classNames(contextClassName, className)
                        }, restContext), restProps), props2), slots) ]
                    });
                };
            }
        });
        var __rest$f = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const RESPONSIVE = "responsive", INVALIDATE = "invalidate";
        function defaultRenderRest(omittedItems) {
            return `+ ${omittedItems.length} ...`;
        }
        const Overflow = defineComponent({
            name: "Overflow",
            inheritAttrs: !1,
            props: (() => ({
                id: String,
                prefixCls: String,
                data: Array,
                itemKey: [ String, Number, Function ],
                itemWidth: {
                    type: Number,
                    default: 10
                },
                renderItem: Function,
                renderRawItem: Function,
                maxCount: [ Number, String ],
                renderRest: Function,
                renderRawRest: Function,
                suffix: PropTypes.any,
                component: String,
                itemComponent: PropTypes.any,
                onVisibleChange: Function,
                ssr: String,
                onMousedown: Function
            }))(),
            emits: [ "visibleChange" ],
            setup(props2, _ref) {
                let {attrs: attrs, emit: emit2, slots: slots} = _ref;
                const fullySSR = computed((() => "full" === props2.ssr)), containerWidth = shallowRef(null), mergedContainerWidth = computed((() => containerWidth.value || 0)), itemWidths = shallowRef(new Map), prevRestWidth = shallowRef(0), restWidth = shallowRef(0), suffixWidth = shallowRef(0), suffixFixedStart = shallowRef(null), displayCount = shallowRef(null), mergedDisplayCount = computed((() => null === displayCount.value && fullySSR.value ? Number.MAX_SAFE_INTEGER : displayCount.value || 0)), restReady = shallowRef(!1), itemPrefixCls = computed((() => `${props2.prefixCls}-item`)), mergedRestWidth = computed((() => Math.max(prevRestWidth.value, restWidth.value))), isResponsive = computed((() => !(!props2.data.length || props2.maxCount !== RESPONSIVE))), invalidate = computed((() => props2.maxCount === INVALIDATE)), showRest = computed((() => isResponsive.value || "number" == typeof props2.maxCount && props2.data.length > props2.maxCount)), mergedData = computed((() => {
                    let items = props2.data;
                    return isResponsive.value ? items = null === containerWidth.value && fullySSR.value ? props2.data : props2.data.slice(0, Math.min(props2.data.length, mergedContainerWidth.value / props2.itemWidth)) : "number" == typeof props2.maxCount && (items = props2.data.slice(0, props2.maxCount)), 
                    items;
                })), omittedItems = computed((() => isResponsive.value ? props2.data.slice(mergedDisplayCount.value + 1) : props2.data.slice(mergedData.value.length))), getKey2 = (item, index2) => {
                    var _a;
                    return "function" == typeof props2.itemKey ? props2.itemKey(item) : null !== (_a = props2.itemKey && (null == item ? void 0 : item[props2.itemKey])) && void 0 !== _a ? _a : index2;
                }, mergedRenderItem = computed((() => props2.renderItem || (item => item))), updateDisplayCount = (count, notReady) => {
                    displayCount.value = count, notReady || (restReady.value = count < props2.data.length - 1, 
                    emit2("visibleChange", count));
                }, onOverflowResize = (_2, element) => {
                    containerWidth.value = element.clientWidth;
                }, registerSize = (key2, width) => {
                    const clone = new Map(itemWidths.value);
                    null === width ? clone.delete(key2) : clone.set(key2, width), itemWidths.value = clone;
                }, registerOverflowSize = (_2, width) => {
                    prevRestWidth.value = restWidth.value, restWidth.value = width;
                }, registerSuffixSize = (_2, width) => {
                    suffixWidth.value = width;
                }, getItemWidth = index2 => itemWidths.value.get(getKey2(mergedData.value[index2], index2));
                return watch([ mergedContainerWidth, itemWidths, restWidth, suffixWidth, () => props2.itemKey, mergedData ], (() => {
                    if (mergedContainerWidth.value && mergedRestWidth.value && mergedData.value) {
                        let totalWidth = suffixWidth.value;
                        const len = mergedData.value.length, lastIndex = len - 1;
                        if (!len) return updateDisplayCount(0), void (suffixFixedStart.value = null);
                        for (let i2 = 0; i2 < len; i2 += 1) {
                            const currentItemWidth = getItemWidth(i2);
                            if (void 0 === currentItemWidth) {
                                updateDisplayCount(i2 - 1, !0);
                                break;
                            }
                            if (totalWidth += currentItemWidth, 0 === lastIndex && totalWidth <= mergedContainerWidth.value || i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth.value) {
                                updateDisplayCount(lastIndex), suffixFixedStart.value = null;
                                break;
                            }
                            if (totalWidth + mergedRestWidth.value > mergedContainerWidth.value) {
                                updateDisplayCount(i2 - 1), suffixFixedStart.value = totalWidth - currentItemWidth - suffixWidth.value + restWidth.value;
                                break;
                            }
                        }
                        props2.suffix && getItemWidth(0) + suffixWidth.value > mergedContainerWidth.value && (suffixFixedStart.value = null);
                    }
                })), () => {
                    const displayRest = restReady.value && !!omittedItems.value.length, {itemComponent: itemComponent, renderRawItem: renderRawItem, renderRawRest: renderRawRest, renderRest: renderRest, prefixCls: prefixCls = "rc-overflow", suffix: suffix, component: Component = "div", id: id, onMousedown: onMousedown} = props2, {class: className, style: style} = attrs, restAttrs = __rest$f(attrs, [ "class", "style" ]);
                    let suffixStyle = {};
                    null !== suffixFixedStart.value && isResponsive.value && (suffixStyle = {
                        position: "absolute",
                        left: `${suffixFixedStart.value}px`,
                        top: 0
                    });
                    const itemSharedProps = {
                        prefixCls: itemPrefixCls.value,
                        responsive: isResponsive.value,
                        component: itemComponent,
                        invalidate: invalidate.value
                    }, internalRenderItemNode = renderRawItem ? (item, index2) => {
                        const key2 = getKey2(item, index2);
                        return createVNode(OverflowContextProvider, {
                            key: key2,
                            value: _extends$1(_extends$1({}, itemSharedProps), {
                                order: index2,
                                item: item,
                                itemKey: key2,
                                registerSize: registerSize,
                                display: index2 <= mergedDisplayCount.value
                            })
                        }, {
                            default: () => [ renderRawItem(item, index2) ]
                        });
                    } : (item, index2) => {
                        const key2 = getKey2(item, index2);
                        return createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
                            order: index2,
                            key: key2,
                            item: item,
                            renderItem: mergedRenderItem.value,
                            itemKey: key2,
                            registerSize: registerSize,
                            display: index2 <= mergedDisplayCount.value
                        }), null);
                    };
                    let restNode = () => null;
                    const restContextProps = {
                        order: displayRest ? mergedDisplayCount.value : Number.MAX_SAFE_INTEGER,
                        className: `${itemPrefixCls.value} ${itemPrefixCls.value}-rest`,
                        registerSize: registerOverflowSize,
                        display: displayRest
                    };
                    if (renderRawRest) renderRawRest && (restNode = () => createVNode(OverflowContextProvider, {
                        value: _extends$1(_extends$1({}, itemSharedProps), restContextProps)
                    }, {
                        default: () => [ renderRawRest(omittedItems.value) ]
                    })); else {
                        const mergedRenderRest = renderRest || defaultRenderRest;
                        restNode = () => createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps), {
                            default: () => "function" == typeof mergedRenderRest ? mergedRenderRest(omittedItems.value) : mergedRenderRest
                        });
                    }
                    const overflowNode = () => {
                        var _a;
                        return createVNode(Component, _objectSpread2$1({
                            id: id,
                            class: classNames(!invalidate.value && prefixCls, className),
                            style: style,
                            onMousedown: onMousedown
                        }, restAttrs), {
                            default: () => [ mergedData.value.map(internalRenderItemNode), showRest.value ? restNode() : null, suffix && createVNode(Item$1, _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
                                order: mergedDisplayCount.value,
                                class: `${itemPrefixCls.value}-suffix`,
                                registerSize: registerSuffixSize,
                                display: !0,
                                style: suffixStyle
                            }), {
                                default: () => suffix
                            }), null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]
                        });
                    };
                    return createVNode(ResizeObserver$1, {
                        disabled: !isResponsive.value,
                        onResize: onOverflowResize
                    }, {
                        default: overflowNode
                    });
                };
            }
        });
        Overflow.Item = RawItem, Overflow.RESPONSIVE = RESPONSIVE, Overflow.INVALIDATE = INVALIDATE;
        const TreeSelectLegacyContextPropsKey = Symbol("TreeSelectLegacyContextPropsKey");
        function useInjectLegacySelectContext() {
            return inject(TreeSelectLegacyContextPropsKey, {});
        }
        const props$2 = {
            id: String,
            prefixCls: String,
            values: PropTypes.array,
            open: {
                type: Boolean,
                default: void 0
            },
            searchValue: String,
            inputRef: PropTypes.any,
            placeholder: PropTypes.any,
            disabled: {
                type: Boolean,
                default: void 0
            },
            mode: String,
            showSearch: {
                type: Boolean,
                default: void 0
            },
            autofocus: {
                type: Boolean,
                default: void 0
            },
            autocomplete: String,
            activeDescendantId: String,
            tabindex: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),
            compositionStatus: Boolean,
            removeIcon: PropTypes.any,
            choiceTransitionName: String,
            maxTagCount: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),
            maxTagTextLength: Number,
            maxTagPlaceholder: PropTypes.any.def((() => omittedValues => `+ ${omittedValues.length} ...`)),
            tagRender: Function,
            onToggleOpen: {
                type: Function
            },
            onRemove: Function,
            onInputChange: Function,
            onInputPaste: Function,
            onInputKeyDown: Function,
            onInputMouseDown: Function,
            onInputCompositionStart: Function,
            onInputCompositionEnd: Function
        }, onPreventMouseDown = event => {
            event.preventDefault(), event.stopPropagation();
        }, SelectSelector = defineComponent({
            name: "MultipleSelectSelector",
            inheritAttrs: !1,
            props: props$2,
            setup(props2) {
                const measureRef = shallowRef(), inputWidth = shallowRef(0), focused = shallowRef(!1), legacyTreeSelectContext = useInjectLegacySelectContext(), selectionPrefixCls = computed((() => `${props2.prefixCls}-selection`)), inputValue = computed((() => props2.open || "tags" === props2.mode ? props2.searchValue : "")), inputEditable = computed((() => "tags" === props2.mode || props2.showSearch && (props2.open || focused.value))), targetValue = ref("");
                function defaultRenderSelector(title, content, itemDisabled, closable, onClose) {
                    return createVNode("span", {
                        class: classNames(`${selectionPrefixCls.value}-item`, {
                            [`${selectionPrefixCls.value}-item-disabled`]: itemDisabled
                        }),
                        title: "string" == typeof title || "number" == typeof title ? title.toString() : void 0
                    }, [ createVNode("span", {
                        class: `${selectionPrefixCls.value}-item-content`
                    }, [ content ]), closable && createVNode(TransBtn, {
                        class: `${selectionPrefixCls.value}-item-remove`,
                        onMousedown: onPreventMouseDown,
                        onClick: onClose,
                        customizeIcon: props2.removeIcon
                    }, {
                        default: () => [ createTextVNode("×") ]
                    }) ]);
                }
                function customizeRenderSelector(value, content, itemDisabled, closable, onClose, option) {
                    var _a;
                    const onMouseDown = e2 => {
                        onPreventMouseDown(e2), props2.onToggleOpen(!open);
                    };
                    let originData = option;
                    return legacyTreeSelectContext.keyEntities && (originData = (null === (_a = legacyTreeSelectContext.keyEntities[value]) || void 0 === _a ? void 0 : _a.node) || {}), 
                    createVNode("span", {
                        key: value,
                        onMousedown: onMouseDown
                    }, [ props2.tagRender({
                        label: content,
                        value: value,
                        disabled: itemDisabled,
                        closable: closable,
                        onClose: onClose,
                        option: originData
                    }) ]);
                }
                function renderItem(valueItem) {
                    const {disabled: itemDisabled, label: label, value: value, option: option} = valueItem, closable = !props2.disabled && !itemDisabled;
                    let displayLabel = label;
                    if ("number" == typeof props2.maxTagTextLength && ("string" == typeof label || "number" == typeof label)) {
                        const strLabel = String(displayLabel);
                        strLabel.length > props2.maxTagTextLength && (displayLabel = `${strLabel.slice(0, props2.maxTagTextLength)}...`);
                    }
                    const onClose = event => {
                        var _a;
                        event && event.stopPropagation(), null === (_a = props2.onRemove) || void 0 === _a || _a.call(props2, valueItem);
                    };
                    return "function" == typeof props2.tagRender ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, option) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose);
                }
                function renderRest(omittedValues) {
                    const {maxTagPlaceholder: maxTagPlaceholder = omittedValues2 => `+ ${omittedValues2.length} ...`} = props2, content = "function" == typeof maxTagPlaceholder ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
                    return defaultRenderSelector(content, content, !1);
                }
                watchEffect((() => {
                    targetValue.value = inputValue.value;
                })), onMounted((() => {
                    watch(targetValue, (() => {
                        inputWidth.value = measureRef.value.scrollWidth;
                    }), {
                        flush: "post",
                        immediate: !0
                    });
                }));
                const handleInput = e2 => {
                    const composing = e2.target.composing;
                    targetValue.value = e2.target.value, composing || props2.onInputChange(e2);
                };
                return () => {
                    const {id: id, prefixCls: prefixCls, values: values, open: open2, inputRef: inputRef, placeholder: placeholder, disabled: disabled, autofocus: autofocus, autocomplete: autocomplete, activeDescendantId: activeDescendantId, tabindex: tabindex, compositionStatus: compositionStatus, onInputPaste: onInputPaste, onInputKeyDown: onInputKeyDown, onInputMouseDown: onInputMouseDown, onInputCompositionStart: onInputCompositionStart, onInputCompositionEnd: onInputCompositionEnd} = props2, inputNode = createVNode("div", {
                        class: `${selectionPrefixCls.value}-search`,
                        style: {
                            width: inputWidth.value + "px"
                        },
                        key: "input"
                    }, [ createVNode(Input, {
                        inputRef: inputRef,
                        open: open2,
                        prefixCls: prefixCls,
                        id: id,
                        inputElement: null,
                        disabled: disabled,
                        autofocus: autofocus,
                        autocomplete: autocomplete,
                        editable: inputEditable.value,
                        activeDescendantId: activeDescendantId,
                        value: targetValue.value,
                        onKeydown: onInputKeyDown,
                        onMousedown: onInputMouseDown,
                        onChange: handleInput,
                        onPaste: onInputPaste,
                        onCompositionstart: onInputCompositionStart,
                        onCompositionend: onInputCompositionEnd,
                        tabindex: tabindex,
                        attrs: pickAttrs(props2, !0),
                        onFocus: () => focused.value = !0,
                        onBlur: () => focused.value = !1
                    }, null), createVNode("span", {
                        ref: measureRef,
                        class: `${selectionPrefixCls.value}-search-mirror`,
                        "aria-hidden": !0
                    }, [ targetValue.value, createTextVNode(" ") ]) ]), selectionNode = createVNode(Overflow, {
                        prefixCls: `${selectionPrefixCls.value}-overflow`,
                        data: values,
                        renderItem: renderItem,
                        renderRest: renderRest,
                        suffix: inputNode,
                        itemKey: "key",
                        maxCount: props2.maxTagCount,
                        key: "overflow"
                    }, null);
                    return createVNode(Fragment, null, [ selectionNode, !values.length && !inputValue.value && !compositionStatus && createVNode("span", {
                        class: `${selectionPrefixCls.value}-placeholder`
                    }, [ placeholder ]) ]);
                };
            }
        }), props$1 = {
            inputElement: PropTypes.any,
            id: String,
            prefixCls: String,
            values: PropTypes.array,
            open: {
                type: Boolean,
                default: void 0
            },
            searchValue: String,
            inputRef: PropTypes.any,
            placeholder: PropTypes.any,
            compositionStatus: {
                type: Boolean,
                default: void 0
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            mode: String,
            showSearch: {
                type: Boolean,
                default: void 0
            },
            autofocus: {
                type: Boolean,
                default: void 0
            },
            autocomplete: String,
            activeDescendantId: String,
            tabindex: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),
            activeValue: String,
            backfill: {
                type: Boolean,
                default: void 0
            },
            optionLabelRender: Function,
            onInputChange: Function,
            onInputPaste: Function,
            onInputKeyDown: Function,
            onInputMouseDown: Function,
            onInputCompositionStart: Function,
            onInputCompositionEnd: Function
        }, SingleSelector = defineComponent({
            name: "SingleSelector",
            setup(props2) {
                const inputChanged = shallowRef(!1), combobox = computed((() => "combobox" === props2.mode)), inputEditable = computed((() => combobox.value || props2.showSearch)), inputValue = computed((() => {
                    let inputValue2 = props2.searchValue || "";
                    return combobox.value && props2.activeValue && !inputChanged.value && (inputValue2 = props2.activeValue), 
                    inputValue2;
                })), legacyTreeSelectContext = useInjectLegacySelectContext();
                watch([ combobox, () => props2.activeValue ], (() => {
                    combobox.value && (inputChanged.value = !1);
                }), {
                    immediate: !0
                });
                const hasTextInput = computed((() => !("combobox" !== props2.mode && !props2.open && !props2.showSearch) && (!!inputValue.value || props2.compositionStatus))), title = computed((() => {
                    const item = props2.values[0];
                    return !item || "string" != typeof item.label && "number" != typeof item.label ? void 0 : item.label.toString();
                })), renderPlaceholder = () => {
                    if (props2.values[0]) return null;
                    const hiddenStyle = hasTextInput.value ? {
                        visibility: "hidden"
                    } : void 0;
                    return createVNode("span", {
                        class: `${props2.prefixCls}-selection-placeholder`,
                        style: hiddenStyle
                    }, [ props2.placeholder ]);
                }, handleInput = e2 => {
                    e2.target.composing || (inputChanged.value = !0, props2.onInputChange(e2));
                };
                return () => {
                    var _a, _b, _c, _d;
                    const {inputElement: inputElement, prefixCls: prefixCls, id: id, values: values, inputRef: inputRef, disabled: disabled, autofocus: autofocus, autocomplete: autocomplete, activeDescendantId: activeDescendantId, open: open2, tabindex: tabindex, optionLabelRender: optionLabelRender, onInputKeyDown: onInputKeyDown, onInputMouseDown: onInputMouseDown, onInputPaste: onInputPaste, onInputCompositionStart: onInputCompositionStart, onInputCompositionEnd: onInputCompositionEnd} = props2, item = values[0];
                    let titleNode = null;
                    if (item && legacyTreeSelectContext.customSlots) {
                        const key2 = null !== (_a = item.key) && void 0 !== _a ? _a : item.value, originData = (null === (_b = legacyTreeSelectContext.keyEntities[key2]) || void 0 === _b ? void 0 : _b.node) || {};
                        titleNode = legacyTreeSelectContext.customSlots[null === (_c = originData.slots) || void 0 === _c ? void 0 : _c.title] || legacyTreeSelectContext.customSlots.title || item.label, 
                        "function" == typeof titleNode && (titleNode = titleNode(originData));
                    } else titleNode = optionLabelRender && item ? optionLabelRender(item.option) : null == item ? void 0 : item.label;
                    return createVNode(Fragment, null, [ createVNode("span", {
                        class: `${prefixCls}-selection-search`
                    }, [ createVNode(Input, {
                        inputRef: inputRef,
                        prefixCls: prefixCls,
                        id: id,
                        open: open2,
                        inputElement: inputElement,
                        disabled: disabled,
                        autofocus: autofocus,
                        autocomplete: autocomplete,
                        editable: inputEditable.value,
                        activeDescendantId: activeDescendantId,
                        value: inputValue.value,
                        onKeydown: onInputKeyDown,
                        onMousedown: onInputMouseDown,
                        onChange: handleInput,
                        onPaste: onInputPaste,
                        onCompositionstart: onInputCompositionStart,
                        onCompositionend: onInputCompositionEnd,
                        tabindex: tabindex,
                        attrs: pickAttrs(props2, !0)
                    }, null) ]), !combobox.value && item && !hasTextInput.value && createVNode("span", {
                        class: `${prefixCls}-selection-item`,
                        title: title.value
                    }, [ createVNode(Fragment, {
                        key: null !== (_d = item.key) && void 0 !== _d ? _d : item.value
                    }, [ titleNode ]) ]), renderPlaceholder() ]);
                };
            }
        });
        function isValidateOpenKey(currentKeyCode) {
            return ![ KeyCode.ESC, KeyCode.SHIFT, KeyCode.BACKSPACE, KeyCode.TAB, KeyCode.WIN_KEY, KeyCode.ALT, KeyCode.META, KeyCode.WIN_KEY_RIGHT, KeyCode.CTRL, KeyCode.SEMICOLON, KeyCode.EQUALS, KeyCode.CAPS_LOCK, KeyCode.CONTEXT_MENU, KeyCode.F1, KeyCode.F2, KeyCode.F3, KeyCode.F4, KeyCode.F5, KeyCode.F6, KeyCode.F7, KeyCode.F8, KeyCode.F9, KeyCode.F10, KeyCode.F11, KeyCode.F12 ].includes(currentKeyCode);
        }
        function useLock() {
            let timeout, duration = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 250, lock = null;
            function doLock(locked) {
                (locked || null === lock) && (lock = locked), clearTimeout(timeout), timeout = setTimeout((() => {
                    lock = null;
                }), duration);
            }
            return onBeforeUnmount((() => {
                clearTimeout(timeout);
            })), [ () => lock, doLock ];
        }
        function createRef() {
            const func = node2 => {
                func.current = node2;
            };
            return func;
        }
        SingleSelector.props = props$1, SingleSelector.inheritAttrs = !1;
        const Selector = defineComponent({
            name: "Selector",
            inheritAttrs: !1,
            props: {
                id: String,
                prefixCls: String,
                showSearch: {
                    type: Boolean,
                    default: void 0
                },
                open: {
                    type: Boolean,
                    default: void 0
                },
                values: PropTypes.array,
                multiple: {
                    type: Boolean,
                    default: void 0
                },
                mode: String,
                searchValue: String,
                activeValue: String,
                inputElement: PropTypes.any,
                autofocus: {
                    type: Boolean,
                    default: void 0
                },
                activeDescendantId: String,
                tabindex: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),
                disabled: {
                    type: Boolean,
                    default: void 0
                },
                placeholder: PropTypes.any,
                removeIcon: PropTypes.any,
                maxTagCount: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),
                maxTagTextLength: Number,
                maxTagPlaceholder: PropTypes.any,
                tagRender: Function,
                optionLabelRender: Function,
                tokenWithEnter: {
                    type: Boolean,
                    default: void 0
                },
                choiceTransitionName: String,
                onToggleOpen: {
                    type: Function
                },
                onSearch: Function,
                onSearchSubmit: Function,
                onRemove: Function,
                onInputKeyDown: {
                    type: Function
                },
                domRef: Function
            },
            setup(props2, _ref) {
                let {expose: expose} = _ref;
                const inputRef = createRef(), compositionStatus = ref(!1), [getInputMouseDown, setInputMouseDown] = useLock(0), onInternalInputKeyDown = event => {
                    const {which: which} = event;
                    which !== KeyCode.UP && which !== KeyCode.DOWN || event.preventDefault(), props2.onInputKeyDown && props2.onInputKeyDown(event), 
                    which !== KeyCode.ENTER || "tags" !== props2.mode || compositionStatus.value || props2.open || props2.onSearchSubmit(event.target.value), 
                    isValidateOpenKey(which) && props2.onToggleOpen(!0);
                }, onInternalInputMouseDown = () => {
                    setInputMouseDown(!0);
                };
                let pastedText = null;
                const triggerOnSearch = value => {
                    !1 !== props2.onSearch(value, !0, compositionStatus.value) && props2.onToggleOpen(!0);
                }, onInputCompositionStart = () => {
                    compositionStatus.value = !0;
                }, onInputCompositionEnd = e2 => {
                    compositionStatus.value = !1, "combobox" !== props2.mode && triggerOnSearch(e2.target.value);
                }, onInputChange = event => {
                    let {target: {value: value}} = event;
                    if (props2.tokenWithEnter && pastedText && /[\r\n]/.test(pastedText)) {
                        const replacedText = pastedText.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
                        value = value.replace(replacedText, pastedText);
                    }
                    pastedText = null, triggerOnSearch(value);
                }, onInputPaste = e2 => {
                    const {clipboardData: clipboardData} = e2, value = clipboardData.getData("text");
                    pastedText = value;
                }, onClick = _ref2 => {
                    let {target: target} = _ref2;
                    if (target !== inputRef.current) {
                        void 0 !== document.body.style.msTouchAction ? setTimeout((() => {
                            inputRef.current.focus();
                        })) : inputRef.current.focus();
                    }
                }, onMousedown = event => {
                    const inputMouseDown = getInputMouseDown();
                    event.target === inputRef.current || inputMouseDown || event.preventDefault(), ("combobox" === props2.mode || props2.showSearch && inputMouseDown) && props2.open || (props2.open && props2.onSearch("", !0, !1), 
                    props2.onToggleOpen());
                };
                return expose({
                    focus: () => {
                        inputRef.current.focus();
                    },
                    blur: () => {
                        inputRef.current.blur();
                    }
                }), () => {
                    const {prefixCls: prefixCls, domRef: domRef, mode: mode} = props2, sharedProps = {
                        inputRef: inputRef,
                        onInputKeyDown: onInternalInputKeyDown,
                        onInputMouseDown: onInternalInputMouseDown,
                        onInputChange: onInputChange,
                        onInputPaste: onInputPaste,
                        compositionStatus: compositionStatus.value,
                        onInputCompositionStart: onInputCompositionStart,
                        onInputCompositionEnd: onInputCompositionEnd
                    }, selectNode = createVNode("multiple" === mode || "tags" === mode ? SelectSelector : SingleSelector, _objectSpread2$1(_objectSpread2$1({}, props2), sharedProps), null);
                    return createVNode("div", {
                        ref: domRef,
                        class: `${prefixCls}-selector`,
                        onClick: onClick,
                        onMousedown: onMousedown
                    }, [ selectNode ]);
                };
            }
        });
        function useSelectTriggerControl(refs, open2, triggerOpen) {
            function onGlobalMouseDown(event) {
                var _a, _b, _c;
                let target = event.target;
                target.shadowRoot && event.composed && (target = event.composedPath()[0] || target);
                const elements = [ null === (_a = refs[0]) || void 0 === _a ? void 0 : _a.value, null === (_c = null === (_b = refs[1]) || void 0 === _b ? void 0 : _b.value) || void 0 === _c ? void 0 : _c.getPopupElement() ];
                open2.value && elements.every((element => element && !element.contains(target) && element !== target)) && triggerOpen(!1);
            }
            onMounted((() => {
                window.addEventListener("mousedown", onGlobalMouseDown);
            })), onBeforeUnmount((() => {
                window.removeEventListener("mousedown", onGlobalMouseDown);
            }));
        }
        function useDelayReset() {
            let timeout = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10;
            const bool = shallowRef(!1);
            let delay;
            const cancelLatest = () => {
                clearTimeout(delay);
            };
            onMounted((() => {
                cancelLatest();
            }));
            const delaySetBool = (value, callback) => {
                cancelLatest(), delay = setTimeout((() => {
                    bool.value = value, callback && callback();
                }), timeout);
            };
            return [ bool, delaySetBool, cancelLatest ];
        }
        const BaseSelectContextKey = Symbol("BaseSelectContextKey");
        function useProvideBaseSelectProps(props2) {
            return provide(BaseSelectContextKey, props2);
        }
        function useBaseProps() {
            return inject(BaseSelectContextKey, {});
        }
        const isMobile = () => {
            if ("undefined" == typeof navigator || "undefined" == typeof window) return !1;
            const agent = navigator.userAgent || navigator.vendor || window.opera;
            return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(null == agent ? void 0 : agent.substring(0, 4));
        };
        function toReactive(objectRef) {
            if (!isRef(objectRef)) return reactive(objectRef);
            return reactive(new Proxy({}, {
                get: (_2, p2, receiver) => Reflect.get(objectRef.value, p2, receiver),
                set: (_2, p2, value) => (objectRef.value[p2] = value, !0),
                deleteProperty: (_2, p2) => Reflect.deleteProperty(objectRef.value, p2),
                has: (_2, p2) => Reflect.has(objectRef.value, p2),
                ownKeys: () => Object.keys(objectRef.value),
                getOwnPropertyDescriptor: () => ({
                    enumerable: !0,
                    configurable: !0
                })
            }));
        }
        var __rest$e = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const DEFAULT_OMIT_PROPS = [ "value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent" ], baseSelectPrivateProps = () => ({
            prefixCls: String,
            id: String,
            omitDomProps: Array,
            displayValues: Array,
            onDisplayValuesChange: Function,
            activeValue: String,
            activeDescendantId: String,
            onActiveValueChange: Function,
            searchValue: String,
            onSearch: Function,
            onSearchSplit: Function,
            maxLength: Number,
            OptionList: PropTypes.any,
            emptyOptions: Boolean
        }), baseSelectPropsWithoutPrivate = () => ({
            showSearch: {
                type: Boolean,
                default: void 0
            },
            tagRender: {
                type: Function
            },
            optionLabelRender: {
                type: Function
            },
            direction: {
                type: String
            },
            tabindex: Number,
            autofocus: Boolean,
            notFoundContent: PropTypes.any,
            placeholder: PropTypes.any,
            onClear: Function,
            choiceTransitionName: String,
            mode: String,
            disabled: {
                type: Boolean,
                default: void 0
            },
            loading: {
                type: Boolean,
                default: void 0
            },
            open: {
                type: Boolean,
                default: void 0
            },
            defaultOpen: {
                type: Boolean,
                default: void 0
            },
            onDropdownVisibleChange: {
                type: Function
            },
            getInputElement: {
                type: Function
            },
            getRawInputElement: {
                type: Function
            },
            maxTagTextLength: Number,
            maxTagCount: {
                type: [ String, Number ]
            },
            maxTagPlaceholder: PropTypes.any,
            tokenSeparators: {
                type: Array
            },
            allowClear: {
                type: Boolean,
                default: void 0
            },
            showArrow: {
                type: Boolean,
                default: void 0
            },
            inputIcon: PropTypes.any,
            clearIcon: PropTypes.any,
            removeIcon: PropTypes.any,
            animation: String,
            transitionName: String,
            dropdownStyle: {
                type: Object
            },
            dropdownClassName: String,
            dropdownMatchSelectWidth: {
                type: [ Boolean, Number ],
                default: void 0
            },
            dropdownRender: {
                type: Function
            },
            dropdownAlign: Object,
            placement: {
                type: String
            },
            getPopupContainer: {
                type: Function
            },
            showAction: {
                type: Array
            },
            onBlur: {
                type: Function
            },
            onFocus: {
                type: Function
            },
            onKeyup: Function,
            onKeydown: Function,
            onMousedown: Function,
            onPopupScroll: Function,
            onInputKeyDown: Function,
            onMouseenter: Function,
            onMouseleave: Function,
            onClick: Function
        });
        function isMultiple(mode) {
            return "tags" === mode || "multiple" === mode;
        }
        const BaseSelect = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "BaseSelect",
            inheritAttrs: !1,
            props: initDefaultProps((() => _extends$1(_extends$1({}, baseSelectPrivateProps()), baseSelectPropsWithoutPrivate()))(), {
                showAction: [],
                notFoundContent: "Not Found"
            }),
            setup(props2, _ref) {
                let {attrs: attrs, expose: expose, slots: slots} = _ref;
                const multiple = computed((() => isMultiple(props2.mode))), mergedShowSearch = computed((() => void 0 !== props2.showSearch ? props2.showSearch : multiple.value || "combobox" === props2.mode)), mobile = shallowRef(!1);
                onMounted((() => {
                    mobile.value = isMobile();
                }));
                const legacyTreeSelectContext = useInjectLegacySelectContext(), containerRef = shallowRef(null), selectorDomRef = createRef(), triggerRef2 = shallowRef(null), selectorRef = shallowRef(null), listRef = shallowRef(null), blurRef = ref(!1), [mockFocused, setMockFocused, cancelSetMockFocused] = useDelayReset();
                expose({
                    focus: () => {
                        var _a;
                        null === (_a = selectorRef.value) || void 0 === _a || _a.focus();
                    },
                    blur: () => {
                        var _a;
                        null === (_a = selectorRef.value) || void 0 === _a || _a.blur();
                    },
                    scrollTo: arg => {
                        var _a;
                        return null === (_a = listRef.value) || void 0 === _a ? void 0 : _a.scrollTo(arg);
                    }
                });
                const mergedSearchValue = computed((() => {
                    var _a;
                    if ("combobox" !== props2.mode) return props2.searchValue;
                    const val = null === (_a = props2.displayValues[0]) || void 0 === _a ? void 0 : _a.value;
                    return "string" == typeof val || "number" == typeof val ? String(val) : "";
                })), initOpen = void 0 !== props2.open ? props2.open : props2.defaultOpen, innerOpen = shallowRef(initOpen), mergedOpen = shallowRef(initOpen), setInnerOpen = val => {
                    innerOpen.value = void 0 !== props2.open ? props2.open : val, mergedOpen.value = innerOpen.value;
                };
                watch((() => props2.open), (() => {
                    setInnerOpen(props2.open);
                }));
                const emptyListContent = computed((() => !props2.notFoundContent && props2.emptyOptions));
                watchEffect((() => {
                    mergedOpen.value = innerOpen.value, (props2.disabled || emptyListContent.value && mergedOpen.value && "combobox" === props2.mode) && (mergedOpen.value = !1);
                }));
                const triggerOpen = computed((() => !emptyListContent.value && mergedOpen.value)), onToggleOpen = newOpen => {
                    const nextOpen = void 0 !== newOpen ? newOpen : !mergedOpen.value;
                    mergedOpen.value === nextOpen || props2.disabled || (setInnerOpen(nextOpen), props2.onDropdownVisibleChange && props2.onDropdownVisibleChange(nextOpen));
                }, tokenWithEnter = computed((() => (props2.tokenSeparators || []).some((tokenSeparator => [ "\n", "\r\n" ].includes(tokenSeparator))))), onInternalSearch = (searchText, fromTyping, isCompositing) => {
                    var _a, _b;
                    let ret = !0, newSearchText = searchText;
                    null === (_a = props2.onActiveValueChange) || void 0 === _a || _a.call(props2, null);
                    const patchLabels = isCompositing ? null : getSeparatedContent(searchText, props2.tokenSeparators);
                    return "combobox" !== props2.mode && patchLabels && (newSearchText = "", null === (_b = props2.onSearchSplit) || void 0 === _b || _b.call(props2, patchLabels), 
                    onToggleOpen(!1), ret = !1), props2.onSearch && mergedSearchValue.value !== newSearchText && props2.onSearch(newSearchText, {
                        source: fromTyping ? "typing" : "effect"
                    }), ret;
                }, onInternalSearchSubmit = searchText => {
                    var _a;
                    searchText && searchText.trim() && (null === (_a = props2.onSearch) || void 0 === _a || _a.call(props2, searchText, {
                        source: "submit"
                    }));
                };
                watch(mergedOpen, (() => {
                    mergedOpen.value || multiple.value || "combobox" === props2.mode || onInternalSearch("", !1, !1);
                }), {
                    immediate: !0,
                    flush: "post"
                }), watch((() => props2.disabled), (() => {
                    innerOpen.value && props2.disabled && setInnerOpen(!1), props2.disabled && !blurRef.value && setMockFocused(!1);
                }), {
                    immediate: !0
                });
                const [getClearLock, setClearLock] = useLock(), onInternalKeyDown = function(event) {
                    var _a;
                    const clearLock = getClearLock(), {which: which} = event;
                    if (which === KeyCode.ENTER && ("combobox" !== props2.mode && event.preventDefault(), 
                    mergedOpen.value || onToggleOpen(!0)), setClearLock(!!mergedSearchValue.value), 
                    which === KeyCode.BACKSPACE && !clearLock && multiple.value && !mergedSearchValue.value && props2.displayValues.length) {
                        const cloneDisplayValues = [ ...props2.displayValues ];
                        let removedDisplayValue = null;
                        for (let i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
                            const current = cloneDisplayValues[i2];
                            if (!current.disabled) {
                                cloneDisplayValues.splice(i2, 1), removedDisplayValue = current;
                                break;
                            }
                        }
                        removedDisplayValue && props2.onDisplayValuesChange(cloneDisplayValues, {
                            type: "remove",
                            values: [ removedDisplayValue ]
                        });
                    }
                    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) rest[_key - 1] = arguments[_key];
                    mergedOpen.value && listRef.value && listRef.value.onKeydown(event, ...rest), null === (_a = props2.onKeydown) || void 0 === _a || _a.call(props2, event, ...rest);
                }, onInternalKeyUp = function(event) {
                    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) rest[_key2 - 1] = arguments[_key2];
                    mergedOpen.value && listRef.value && listRef.value.onKeyup(event, ...rest), props2.onKeyup && props2.onKeyup(event, ...rest);
                }, onSelectorRemove = val => {
                    const newValues = props2.displayValues.filter((i2 => i2 !== val));
                    props2.onDisplayValuesChange(newValues, {
                        type: "remove",
                        values: [ val ]
                    });
                }, focusRef = shallowRef(!1), onContainerFocus = function() {
                    setMockFocused(!0), props2.disabled || (props2.onFocus && !focusRef.value && props2.onFocus(...arguments), 
                    props2.showAction && props2.showAction.includes("focus") && onToggleOpen(!0)), focusRef.value = !0;
                }, popupFocused = ref(!1), onContainerBlur = function() {
                    if (popupFocused.value) return;
                    if (blurRef.value = !0, setMockFocused(!1, (() => {
                        focusRef.value = !1, blurRef.value = !1, onToggleOpen(!1);
                    })), props2.disabled) return;
                    const searchVal = mergedSearchValue.value;
                    searchVal && ("tags" === props2.mode ? props2.onSearch(searchVal, {
                        source: "submit"
                    }) : "multiple" === props2.mode && props2.onSearch("", {
                        source: "blur"
                    })), props2.onBlur && props2.onBlur(...arguments);
                }, onPopupFocusin = () => {
                    popupFocused.value = !0;
                }, onPopupFocusout = () => {
                    popupFocused.value = !1;
                };
                provide("VCSelectContainerEvent", {
                    focus: onContainerFocus,
                    blur: onContainerBlur
                });
                const activeTimeoutIds = [];
                onMounted((() => {
                    activeTimeoutIds.forEach((timeoutId => clearTimeout(timeoutId))), activeTimeoutIds.splice(0, activeTimeoutIds.length);
                })), onBeforeUnmount((() => {
                    activeTimeoutIds.forEach((timeoutId => clearTimeout(timeoutId))), activeTimeoutIds.splice(0, activeTimeoutIds.length);
                }));
                const onInternalMouseDown = function(event) {
                    var _a, _b;
                    const {target: target} = event, popupElement = null === (_a = triggerRef2.value) || void 0 === _a ? void 0 : _a.getPopupElement();
                    if (popupElement && popupElement.contains(target)) {
                        const timeoutId = setTimeout((() => {
                            var _a2;
                            const index2 = activeTimeoutIds.indexOf(timeoutId);
                            -1 !== index2 && activeTimeoutIds.splice(index2, 1), cancelSetMockFocused(), mobile.value || popupElement.contains(document.activeElement) || null === (_a2 = selectorRef.value) || void 0 === _a2 || _a2.focus();
                        }));
                        activeTimeoutIds.push(timeoutId);
                    }
                    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) restArgs[_key3 - 1] = arguments[_key3];
                    null === (_b = props2.onMousedown) || void 0 === _b || _b.call(props2, event, ...restArgs);
                }, containerWidth = shallowRef(null), onPopupMouseEnter = () => {};
                return onMounted((() => {
                    watch(triggerOpen, (() => {
                        var _a;
                        if (triggerOpen.value) {
                            const newWidth = Math.ceil(null === (_a = containerRef.value) || void 0 === _a ? void 0 : _a.offsetWidth);
                            containerWidth.value === newWidth || Number.isNaN(newWidth) || (containerWidth.value = newWidth);
                        }
                    }), {
                        immediate: !0,
                        flush: "post"
                    });
                })), useSelectTriggerControl([ containerRef, triggerRef2 ], triggerOpen, onToggleOpen), 
                useProvideBaseSelectProps(toReactive(_extends$1(_extends$1({}, toRefs(props2)), {
                    open: mergedOpen,
                    triggerOpen: triggerOpen,
                    showSearch: mergedShowSearch,
                    multiple: multiple,
                    toggleOpen: onToggleOpen
                }))), () => {
                    const _a = _extends$1(_extends$1({}, props2), attrs), {prefixCls: prefixCls, id: id, open: open2, defaultOpen: defaultOpen, mode: mode, showSearch: showSearch, searchValue: searchValue, onSearch: onSearch, allowClear: allowClear, clearIcon: clearIcon, showArrow: showArrow, inputIcon: inputIcon, disabled: disabled, loading: loading, getInputElement: getInputElement, getPopupContainer: getPopupContainer, placement: placement, animation: animation, transitionName: transitionName2, dropdownStyle: dropdownStyle, dropdownClassName: dropdownClassName, dropdownMatchSelectWidth: dropdownMatchSelectWidth, dropdownRender: dropdownRender, dropdownAlign: dropdownAlign, showAction: showAction, direction: direction, tokenSeparators: tokenSeparators, tagRender: tagRender, optionLabelRender: optionLabelRender, onPopupScroll: onPopupScroll, onDropdownVisibleChange: onDropdownVisibleChange, onFocus: onFocus, onBlur: onBlur, onKeyup: onKeyup, onKeydown: onKeydown, onMousedown: onMousedown, onClear: onClear, omitDomProps: omitDomProps, getRawInputElement: getRawInputElement, displayValues: displayValues, onDisplayValuesChange: onDisplayValuesChange, emptyOptions: emptyOptions, activeDescendantId: activeDescendantId, activeValue: activeValue, OptionList: OptionList2} = _a, restProps = __rest$e(_a, [ "prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList" ]), customizeInputElement = "combobox" === mode && getInputElement && getInputElement() || null, customizeRawInputElement = "function" == typeof getRawInputElement && getRawInputElement(), domProps = _extends$1({}, restProps);
                    let onTriggerVisibleChange;
                    customizeRawInputElement && (onTriggerVisibleChange = newOpen => {
                        onToggleOpen(newOpen);
                    }), DEFAULT_OMIT_PROPS.forEach((propName => {
                        delete domProps[propName];
                    })), null == omitDomProps || omitDomProps.forEach((propName => {
                        delete domProps[propName];
                    }));
                    const mergedShowArrow = void 0 !== showArrow ? showArrow : loading || !multiple.value && "combobox" !== mode;
                    let arrowNode, clearNode;
                    mergedShowArrow && (arrowNode = createVNode(TransBtn, {
                        class: classNames(`${prefixCls}-arrow`, {
                            [`${prefixCls}-arrow-loading`]: loading
                        }),
                        customizeIcon: inputIcon,
                        customizeIconProps: {
                            loading: loading,
                            searchValue: mergedSearchValue.value,
                            open: mergedOpen.value,
                            focused: mockFocused.value,
                            showSearch: mergedShowSearch.value
                        }
                    }, null));
                    const onClearMouseDown = () => {
                        null == onClear || onClear(), onDisplayValuesChange([], {
                            type: "clear",
                            values: displayValues
                        }), onInternalSearch("", !1, !1);
                    };
                    !disabled && allowClear && (displayValues.length || mergedSearchValue.value) && (clearNode = createVNode(TransBtn, {
                        class: `${prefixCls}-clear`,
                        onMousedown: onClearMouseDown,
                        customizeIcon: clearIcon
                    }, {
                        default: () => [ createTextVNode("×") ]
                    }));
                    const optionList = createVNode(OptionList2, {
                        ref: listRef
                    }, _extends$1(_extends$1({}, legacyTreeSelectContext.customSlots), {
                        option: slots.option
                    })), mergedClassName = classNames(prefixCls, attrs.class, {
                        [`${prefixCls}-focused`]: mockFocused.value,
                        [`${prefixCls}-multiple`]: multiple.value,
                        [`${prefixCls}-single`]: !multiple.value,
                        [`${prefixCls}-allow-clear`]: allowClear,
                        [`${prefixCls}-show-arrow`]: mergedShowArrow,
                        [`${prefixCls}-disabled`]: disabled,
                        [`${prefixCls}-loading`]: loading,
                        [`${prefixCls}-open`]: mergedOpen.value,
                        [`${prefixCls}-customize-input`]: customizeInputElement,
                        [`${prefixCls}-show-search`]: mergedShowSearch.value
                    }), selectorNode = createVNode(SelectTrigger, {
                        ref: triggerRef2,
                        disabled: disabled,
                        prefixCls: prefixCls,
                        visible: triggerOpen.value,
                        popupElement: optionList,
                        containerWidth: containerWidth.value,
                        animation: animation,
                        transitionName: transitionName2,
                        dropdownStyle: dropdownStyle,
                        dropdownClassName: dropdownClassName,
                        direction: direction,
                        dropdownMatchSelectWidth: dropdownMatchSelectWidth,
                        dropdownRender: dropdownRender,
                        dropdownAlign: dropdownAlign,
                        placement: placement,
                        getPopupContainer: getPopupContainer,
                        empty: emptyOptions,
                        getTriggerDOMNode: () => selectorDomRef.current,
                        onPopupVisibleChange: onTriggerVisibleChange,
                        onPopupMouseEnter: onPopupMouseEnter,
                        onPopupFocusin: onPopupFocusin,
                        onPopupFocusout: onPopupFocusout
                    }, {
                        default: () => customizeRawInputElement ? isValidElement(customizeRawInputElement) && cloneElement(customizeRawInputElement, {
                            ref: selectorDomRef
                        }, !1, !0) : createVNode(Selector, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
                            domRef: selectorDomRef,
                            prefixCls: prefixCls,
                            inputElement: customizeInputElement,
                            ref: selectorRef,
                            id: id,
                            showSearch: mergedShowSearch.value,
                            mode: mode,
                            activeDescendantId: activeDescendantId,
                            tagRender: tagRender,
                            optionLabelRender: optionLabelRender,
                            values: displayValues,
                            open: mergedOpen.value,
                            onToggleOpen: onToggleOpen,
                            activeValue: activeValue,
                            searchValue: mergedSearchValue.value,
                            onSearch: onInternalSearch,
                            onSearchSubmit: onInternalSearchSubmit,
                            onRemove: onSelectorRemove,
                            tokenWithEnter: tokenWithEnter.value
                        }), null)
                    });
                    let renderNode;
                    return renderNode = customizeRawInputElement ? selectorNode : createVNode("div", _objectSpread2$1(_objectSpread2$1({}, domProps), {}, {
                        class: mergedClassName,
                        ref: containerRef,
                        onMousedown: onInternalMouseDown,
                        onKeydown: onInternalKeyDown,
                        onKeyup: onInternalKeyUp
                    }), [ mockFocused.value && !mergedOpen.value && createVNode("span", {
                        style: {
                            width: 0,
                            height: 0,
                            position: "absolute",
                            overflow: "hidden",
                            opacity: 0
                        },
                        "aria-live": "polite"
                    }, [ `${displayValues.map((_ref2 => {
                        let {label: label, value: value} = _ref2;
                        return [ "number", "string" ].includes(typeof label) ? label : value;
                    })).join(", ")}` ]), selectorNode, arrowNode, clearNode ]), renderNode;
                };
            }
        }), Filter = (_ref, _ref2) => {
            let {height: height, offset: offset, prefixCls: prefixCls, onInnerResize: onInnerResize} = _ref, {slots: slots} = _ref2;
            var _a;
            let outerStyle = {}, innerStyle = {
                display: "flex",
                flexDirection: "column"
            };
            return void 0 !== offset && (outerStyle = {
                height: `${height}px`,
                position: "relative",
                overflow: "hidden"
            }, innerStyle = _extends$1(_extends$1({}, innerStyle), {
                transform: `translateY(${offset}px)`,
                position: "absolute",
                left: 0,
                right: 0,
                top: 0
            })), createVNode("div", {
                style: outerStyle
            }, [ createVNode(ResizeObserver$1, {
                onResize: _ref3 => {
                    let {offsetHeight: offsetHeight} = _ref3;
                    offsetHeight && onInnerResize && onInnerResize();
                }
            }, {
                default: () => [ createVNode("div", {
                    style: innerStyle,
                    class: classNames({
                        [`${prefixCls}-holder-inner`]: prefixCls
                    })
                }, [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]) ]
            }) ]);
        };
        Filter.displayName = "Filter", Filter.inheritAttrs = !1, Filter.props = {
            prefixCls: String,
            height: Number,
            offset: Number,
            onInnerResize: Function
        };
        const Item = (_ref, _ref2) => {
            let {setRef: setRef2} = _ref, {slots: slots} = _ref2;
            var _a;
            const children = flattenChildren(null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots));
            return children && children.length ? cloneVNode(children[0], {
                ref: setRef2
            }) : children;
        };
        Item.props = {
            setRef: {
                type: Function,
                default: () => {}
            }
        };
        const MIN_SIZE = 20;
        function getPageY(e2) {
            return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
        }
        const ScrollBar = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ScrollBar",
            inheritAttrs: !1,
            props: {
                prefixCls: String,
                scrollTop: Number,
                scrollHeight: Number,
                height: Number,
                count: Number,
                onScroll: {
                    type: Function
                },
                onStartMove: {
                    type: Function
                },
                onStopMove: {
                    type: Function
                }
            },
            setup: () => ({
                moveRaf: null,
                scrollbarRef: createRef(),
                thumbRef: createRef(),
                visibleTimeout: null,
                state: reactive({
                    dragging: !1,
                    pageY: null,
                    startTop: null,
                    visible: !1
                })
            }),
            watch: {
                scrollTop: {
                    handler() {
                        this.delayHidden();
                    },
                    flush: "post"
                }
            },
            mounted() {
                var _a, _b;
                null === (_a = this.scrollbarRef.current) || void 0 === _a || _a.addEventListener("touchstart", this.onScrollbarTouchStart, !!supportsPassive && {
                    passive: !1
                }), null === (_b = this.thumbRef.current) || void 0 === _b || _b.addEventListener("touchstart", this.onMouseDown, !!supportsPassive && {
                    passive: !1
                });
            },
            beforeUnmount() {
                this.removeEvents(), clearTimeout(this.visibleTimeout);
            },
            methods: {
                delayHidden() {
                    clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout((() => {
                        this.state.visible = !1;
                    }), 2e3);
                },
                onScrollbarTouchStart(e2) {
                    e2.preventDefault();
                },
                onContainerMouseDown(e2) {
                    e2.stopPropagation(), e2.preventDefault();
                },
                patchEvents() {
                    window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this.onMouseUp), 
                    this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, !!supportsPassive && {
                        passive: !1
                    }), this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
                },
                removeEvents() {
                    window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), 
                    this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, !!supportsPassive && {
                        passive: !1
                    }), this.thumbRef.current && (this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, !!supportsPassive && {
                        passive: !1
                    }), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, !!supportsPassive && {
                        passive: !1
                    }), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp)), wrapperRaf.cancel(this.moveRaf);
                },
                onMouseDown(e2) {
                    const {onStartMove: onStartMove} = this.$props;
                    _extends$1(this.state, {
                        dragging: !0,
                        pageY: getPageY(e2),
                        startTop: this.getTop()
                    }), onStartMove(), this.patchEvents(), e2.stopPropagation(), e2.preventDefault();
                },
                onMouseMove(e2) {
                    const {dragging: dragging, pageY: pageY, startTop: startTop} = this.state, {onScroll: onScroll} = this.$props;
                    if (wrapperRaf.cancel(this.moveRaf), dragging) {
                        const newTop = startTop + (getPageY(e2) - pageY), enableScrollRange = this.getEnableScrollRange(), enableHeightRange = this.getEnableHeightRange(), ptg = enableHeightRange ? newTop / enableHeightRange : 0, newScrollTop = Math.ceil(ptg * enableScrollRange);
                        this.moveRaf = wrapperRaf((() => {
                            onScroll(newScrollTop);
                        }));
                    }
                },
                onMouseUp() {
                    const {onStopMove: onStopMove} = this.$props;
                    this.state.dragging = !1, onStopMove(), this.removeEvents();
                },
                getSpinHeight() {
                    const {height: height, scrollHeight: scrollHeight} = this.$props;
                    let baseHeight = height / scrollHeight * 100;
                    return baseHeight = Math.max(baseHeight, MIN_SIZE), baseHeight = Math.min(baseHeight, height / 2), 
                    Math.floor(baseHeight);
                },
                getEnableScrollRange() {
                    const {scrollHeight: scrollHeight, height: height} = this.$props;
                    return scrollHeight - height || 0;
                },
                getEnableHeightRange() {
                    const {height: height} = this.$props;
                    return height - this.getSpinHeight() || 0;
                },
                getTop() {
                    const {scrollTop: scrollTop} = this.$props, enableScrollRange = this.getEnableScrollRange(), enableHeightRange = this.getEnableHeightRange();
                    if (0 === scrollTop || 0 === enableScrollRange) return 0;
                    return scrollTop / enableScrollRange * enableHeightRange;
                },
                showScroll() {
                    const {height: height, scrollHeight: scrollHeight} = this.$props;
                    return scrollHeight > height;
                }
            },
            render() {
                const {dragging: dragging, visible: visible} = this.state, {prefixCls: prefixCls} = this.$props, spinHeight = this.getSpinHeight() + "px", top = this.getTop() + "px", canScroll = this.showScroll(), mergedVisible = canScroll && visible;
                return createVNode("div", {
                    ref: this.scrollbarRef,
                    class: classNames(`${prefixCls}-scrollbar`, {
                        [`${prefixCls}-scrollbar-show`]: canScroll
                    }),
                    style: {
                        width: "8px",
                        top: 0,
                        bottom: 0,
                        right: 0,
                        position: "absolute",
                        display: mergedVisible ? void 0 : "none"
                    },
                    onMousedown: this.onContainerMouseDown,
                    onMousemove: this.delayHidden
                }, [ createVNode("div", {
                    ref: this.thumbRef,
                    class: classNames(`${prefixCls}-scrollbar-thumb`, {
                        [`${prefixCls}-scrollbar-thumb-moving`]: dragging
                    }),
                    style: {
                        width: "100%",
                        height: spinHeight,
                        top: top,
                        left: 0,
                        position: "absolute",
                        background: "rgba(0, 0, 0, 0.5)",
                        borderRadius: "99px",
                        cursor: "pointer",
                        userSelect: "none"
                    },
                    onMousedown: this.onMouseDown
                }, null) ]);
            }
        });
        function useHeights(mergedData, getKey2, onItemAdd, onItemRemove) {
            const instance = new Map, heights = new Map, updatedMark = ref(Symbol("update"));
            let collectRaf;
            function cancelRaf() {
                wrapperRaf.cancel(collectRaf);
            }
            function collectHeight() {
                cancelRaf(), collectRaf = wrapperRaf((() => {
                    instance.forEach(((element, key2) => {
                        if (element && element.offsetParent) {
                            const {offsetHeight: offsetHeight} = element;
                            heights.get(key2) !== offsetHeight && (updatedMark.value = Symbol("update"), heights.set(key2, element.offsetHeight));
                        }
                    }));
                }));
            }
            function setInstance(item, ins) {
                const key2 = getKey2(item);
                instance.get(key2), ins ? (instance.set(key2, ins.$el || ins), collectHeight()) : instance.delete(key2);
            }
            return watch(mergedData, (() => {
                updatedMark.value = Symbol("update");
            })), onUnmounted((() => {
                cancelRaf();
            })), [ setInstance, collectHeight, heights, updatedMark ];
        }
        function useScrollTo(containerRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, triggerFlash) {
            let scroll;
            return arg => {
                if (null == arg) return void triggerFlash();
                wrapperRaf.cancel(scroll);
                const data = mergedData.value, itemHeight = props2.itemHeight;
                if ("number" == typeof arg) syncScrollTop(arg); else if (arg && "object" == typeof arg) {
                    let index2;
                    const {align: align} = arg;
                    "index" in arg ? ({index: index2} = arg) : index2 = data.findIndex((item => getKey2(item) === arg.key));
                    const {offset: offset = 0} = arg, syncScroll = (times, targetAlign) => {
                        if (times < 0 || !containerRef.value) return;
                        const height = containerRef.value.clientHeight;
                        let needCollectHeight = !1, newTargetAlign = targetAlign;
                        if (height) {
                            const mergedAlign = targetAlign || align;
                            let stackTop = 0, itemTop = 0, itemBottom = 0;
                            const maxLen = Math.min(data.length, index2);
                            for (let i2 = 0; i2 <= maxLen; i2 += 1) {
                                const key2 = getKey2(data[i2]);
                                itemTop = stackTop;
                                const cacheHeight = heights.get(key2);
                                itemBottom = itemTop + (void 0 === cacheHeight ? itemHeight : cacheHeight), stackTop = itemBottom, 
                                i2 === index2 && void 0 === cacheHeight && (needCollectHeight = !0);
                            }
                            const scrollTop = containerRef.value.scrollTop;
                            let targetTop = null;
                            switch (mergedAlign) {
                              case "top":
                                targetTop = itemTop - offset;
                                break;

                              case "bottom":
                                targetTop = itemBottom - height + offset;
                                break;

                              default:
                                itemTop < scrollTop ? newTargetAlign = "top" : itemBottom > scrollTop + height && (newTargetAlign = "bottom");
                            }
                            null !== targetTop && targetTop !== scrollTop && syncScrollTop(targetTop);
                        }
                        scroll = wrapperRaf((() => {
                            needCollectHeight && collectHeight(), syncScroll(times - 1, newTargetAlign);
                        }), 2);
                    };
                    syncScroll(5);
                }
            };
        }
        const isFF = "object" == typeof navigator && /Firefox/i.test(navigator.userAgent), useOriginScroll = (isScrollAtTop, isScrollAtBottom) => {
            let lock = !1, lockTimeout = null;
            function lockScroll() {
                clearTimeout(lockTimeout), lock = !0, lockTimeout = setTimeout((() => {
                    lock = !1;
                }), 50);
            }
            return function(deltaY) {
                let smoothOffset = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                const originScroll = deltaY < 0 && isScrollAtTop.value || deltaY > 0 && isScrollAtBottom.value;
                return smoothOffset && originScroll ? (clearTimeout(lockTimeout), lock = !1) : originScroll && !lock || lockScroll(), 
                !lock && originScroll;
            };
        };
        function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
            let offsetRef = 0, nextFrame2 = null, wheelValue = null, isMouseScroll = !1;
            const originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
            function onWheel(event) {
                if (!inVirtual.value) return;
                wrapperRaf.cancel(nextFrame2);
                const {deltaY: deltaY} = event;
                offsetRef += deltaY, wheelValue = deltaY, originScroll(deltaY) || (isFF || event.preventDefault(), 
                nextFrame2 = wrapperRaf((() => {
                    onWheelDelta(offsetRef * (isMouseScroll ? 10 : 1)), offsetRef = 0;
                })));
            }
            function onFireFoxScroll(event) {
                inVirtual.value && (isMouseScroll = event.detail === wheelValue);
            }
            return [ onWheel, onFireFoxScroll ];
        }
        const SMOOTH_PTG = 14 / 15;
        function useMobileTouchMove(inVirtual, listRef, callback) {
            let touched = !1, touchY = 0, element = null, interval = null;
            const cleanUpEvents = () => {
                element && (element.removeEventListener("touchmove", onTouchMove), element.removeEventListener("touchend", onTouchEnd));
            }, onTouchMove = e2 => {
                if (touched) {
                    const currentY = Math.ceil(e2.touches[0].pageY);
                    let offsetY = touchY - currentY;
                    touchY = currentY, callback(offsetY) && e2.preventDefault(), clearInterval(interval), 
                    interval = setInterval((() => {
                        offsetY *= SMOOTH_PTG, (!callback(offsetY, !0) || Math.abs(offsetY) <= .1) && clearInterval(interval);
                    }), 16);
                }
            }, onTouchEnd = () => {
                touched = !1, cleanUpEvents();
            }, onTouchStart = e2 => {
                cleanUpEvents(), 1 !== e2.touches.length || touched || (touched = !0, touchY = Math.ceil(e2.touches[0].pageY), 
                element = e2.target, element.addEventListener("touchmove", onTouchMove, {
                    passive: !1
                }), element.addEventListener("touchend", onTouchEnd));
            }, noop2 = () => {};
            onMounted((() => {
                document.addEventListener("touchmove", noop2, {
                    passive: !1
                }), watch(inVirtual, (val => {
                    listRef.value.removeEventListener("touchstart", onTouchStart), cleanUpEvents(), 
                    clearInterval(interval), val && listRef.value.addEventListener("touchstart", onTouchStart, {
                        passive: !1
                    });
                }), {
                    immediate: !0
                });
            })), onBeforeUnmount((() => {
                document.removeEventListener("touchmove", noop2);
            }));
        }
        var __rest$d = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const EMPTY_DATA = [], ScrollStyle = {
            overflowY: "auto",
            overflowAnchor: "none"
        };
        function renderChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
            let {getKey: getKey2} = _ref;
            return list.slice(startIndex, endIndex + 1).map(((item, index2) => {
                const node2 = renderFunc(item, startIndex + index2, {}), key2 = getKey2(item);
                return createVNode(Item, {
                    key: key2,
                    setRef: ele => setNodeRef(item, ele)
                }, {
                    default: () => [ node2 ]
                });
            }));
        }
        const List = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "List",
            inheritAttrs: !1,
            props: {
                prefixCls: String,
                data: PropTypes.array,
                height: Number,
                itemHeight: Number,
                fullHeight: {
                    type: Boolean,
                    default: void 0
                },
                itemKey: {
                    type: [ String, Number, Function ],
                    required: !0
                },
                component: {
                    type: [ String, Object ]
                },
                virtual: {
                    type: Boolean,
                    default: void 0
                },
                children: Function,
                onScroll: Function,
                onMousedown: Function,
                onMouseenter: Function,
                onVisibleChange: Function
            },
            setup(props2, _ref2) {
                let {expose: expose} = _ref2;
                const useVirtual = computed((() => {
                    const {height: height, itemHeight: itemHeight, virtual: virtual} = props2;
                    return !(!1 === virtual || !height || !itemHeight);
                })), inVirtual = computed((() => {
                    const {height: height, itemHeight: itemHeight, data: data2} = props2;
                    return useVirtual.value && data2 && itemHeight * data2.length > height;
                })), state = reactive({
                    scrollTop: 0,
                    scrollMoving: !1
                }), data = computed((() => props2.data || EMPTY_DATA)), mergedData = shallowRef([]);
                watch(data, (() => {
                    mergedData.value = toRaw(data.value).slice();
                }), {
                    immediate: !0
                });
                const itemKey = shallowRef((_item => {}));
                watch((() => props2.itemKey), (val => {
                    itemKey.value = "function" == typeof val ? val : item => null == item ? void 0 : item[val];
                }), {
                    immediate: !0
                });
                const componentRef = shallowRef(), fillerInnerRef = shallowRef(), scrollBarRef = shallowRef(), getKey2 = item => itemKey.value(item), sharedConfig = {
                    getKey: getKey2
                };
                function syncScrollTop(newTop) {
                    let value;
                    value = "function" == typeof newTop ? newTop(state.scrollTop) : newTop;
                    const alignedTop = keepInRange(value);
                    componentRef.value && (componentRef.value.scrollTop = alignedTop), state.scrollTop = alignedTop;
                }
                const [setInstance, collectHeight, heights, updatedMark] = useHeights(mergedData, getKey2), calRes = reactive({
                    scrollHeight: void 0,
                    start: 0,
                    end: 0,
                    offset: void 0
                }), offsetHeight = shallowRef(0);
                onMounted((() => {
                    nextTick((() => {
                        var _a;
                        offsetHeight.value = (null === (_a = fillerInnerRef.value) || void 0 === _a ? void 0 : _a.offsetHeight) || 0;
                    }));
                })), onUpdated((() => {
                    nextTick((() => {
                        var _a;
                        offsetHeight.value = (null === (_a = fillerInnerRef.value) || void 0 === _a ? void 0 : _a.offsetHeight) || 0;
                    }));
                })), watch([ useVirtual, mergedData ], (() => {
                    useVirtual.value || _extends$1(calRes, {
                        scrollHeight: void 0,
                        start: 0,
                        end: mergedData.value.length - 1,
                        offset: void 0
                    });
                }), {
                    immediate: !0
                }), watch([ useVirtual, mergedData, offsetHeight, inVirtual ], (() => {
                    useVirtual.value && !inVirtual.value && _extends$1(calRes, {
                        scrollHeight: offsetHeight.value,
                        start: 0,
                        end: mergedData.value.length - 1,
                        offset: void 0
                    }), componentRef.value && (state.scrollTop = componentRef.value.scrollTop);
                }), {
                    immediate: !0
                }), watch([ inVirtual, useVirtual, () => state.scrollTop, mergedData, updatedMark, () => props2.height, offsetHeight ], (() => {
                    if (!useVirtual.value || !inVirtual.value) return;
                    let startIndex, startOffset, endIndex, itemTop = 0;
                    const dataLen = mergedData.value.length, data2 = mergedData.value, scrollTop = state.scrollTop, {itemHeight: itemHeight, height: height} = props2, scrollTopHeight = scrollTop + height;
                    for (let i2 = 0; i2 < dataLen; i2 += 1) {
                        const item = data2[i2], key2 = getKey2(item);
                        let cacheHeight = heights.get(key2);
                        void 0 === cacheHeight && (cacheHeight = itemHeight);
                        const currentItemBottom = itemTop + cacheHeight;
                        void 0 === startIndex && currentItemBottom >= scrollTop && (startIndex = i2, startOffset = itemTop), 
                        void 0 === endIndex && currentItemBottom > scrollTopHeight && (endIndex = i2), itemTop = currentItemBottom;
                    }
                    void 0 === startIndex && (startIndex = 0, startOffset = 0, endIndex = Math.ceil(height / itemHeight)), 
                    void 0 === endIndex && (endIndex = dataLen - 1), endIndex = Math.min(endIndex + 1, dataLen), 
                    _extends$1(calRes, {
                        scrollHeight: itemTop,
                        start: startIndex,
                        end: endIndex,
                        offset: startOffset
                    });
                }), {
                    immediate: !0
                });
                const maxScrollHeight = computed((() => calRes.scrollHeight - props2.height));
                function keepInRange(newScrollTop) {
                    let newTop = newScrollTop;
                    return Number.isNaN(maxScrollHeight.value) || (newTop = Math.min(newTop, maxScrollHeight.value)), 
                    newTop = Math.max(newTop, 0), newTop;
                }
                const isScrollAtTop = computed((() => state.scrollTop <= 0)), isScrollAtBottom = computed((() => state.scrollTop >= maxScrollHeight.value)), originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
                function onScrollBar(newScrollTop) {
                    syncScrollTop(newScrollTop);
                }
                function onFallbackScroll(e2) {
                    var _a;
                    const {scrollTop: newScrollTop} = e2.currentTarget;
                    newScrollTop !== state.scrollTop && syncScrollTop(newScrollTop), null === (_a = props2.onScroll) || void 0 === _a || _a.call(props2, e2);
                }
                const [onRawWheel, onFireFoxScroll] = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, (offsetY => {
                    syncScrollTop((top => top + offsetY));
                }));
                function onMozMousePixelScroll(e2) {
                    useVirtual.value && e2.preventDefault();
                }
                useMobileTouchMove(useVirtual, componentRef, ((deltaY, smoothOffset) => !originScroll(deltaY, smoothOffset) && (onRawWheel({
                    preventDefault() {},
                    deltaY: deltaY
                }), !0)));
                const removeEventListener2 = () => {
                    componentRef.value && (componentRef.value.removeEventListener("wheel", onRawWheel, !!supportsPassive && {
                        passive: !1
                    }), componentRef.value.removeEventListener("DOMMouseScroll", onFireFoxScroll), componentRef.value.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll));
                };
                watchEffect((() => {
                    nextTick((() => {
                        componentRef.value && (removeEventListener2(), componentRef.value.addEventListener("wheel", onRawWheel, !!supportsPassive && {
                            passive: !1
                        }), componentRef.value.addEventListener("DOMMouseScroll", onFireFoxScroll), componentRef.value.addEventListener("MozMousePixelScroll", onMozMousePixelScroll));
                    }));
                })), onBeforeUnmount((() => {
                    removeEventListener2();
                }));
                expose({
                    scrollTo: useScrollTo(componentRef, mergedData, heights, props2, getKey2, collectHeight, syncScrollTop, (() => {
                        var _a;
                        null === (_a = scrollBarRef.value) || void 0 === _a || _a.delayHidden();
                    }))
                });
                const componentStyle = computed((() => {
                    let cs = null;
                    return props2.height && (cs = _extends$1({
                        [props2.fullHeight ? "height" : "maxHeight"]: props2.height + "px"
                    }, ScrollStyle), useVirtual.value && (cs.overflowY = "hidden", state.scrollMoving && (cs.pointerEvents = "none"))), 
                    cs;
                }));
                watch([ () => calRes.start, () => calRes.end, mergedData ], (() => {
                    if (props2.onVisibleChange) {
                        const renderList2 = mergedData.value.slice(calRes.start, calRes.end + 1);
                        props2.onVisibleChange(renderList2, mergedData.value);
                    }
                }), {
                    flush: "post"
                });
                return {
                    state: state,
                    mergedData: mergedData,
                    componentStyle: componentStyle,
                    onFallbackScroll: onFallbackScroll,
                    onScrollBar: onScrollBar,
                    componentRef: componentRef,
                    useVirtual: useVirtual,
                    calRes: calRes,
                    collectHeight: collectHeight,
                    setInstance: setInstance,
                    sharedConfig: sharedConfig,
                    scrollBarRef: scrollBarRef,
                    fillerInnerRef: fillerInnerRef,
                    delayHideScrollBar: () => {
                        var _a;
                        null === (_a = scrollBarRef.value) || void 0 === _a || _a.delayHidden();
                    }
                };
            },
            render() {
                const _a = _extends$1(_extends$1({}, this.$props), this.$attrs), {prefixCls: prefixCls = "rc-virtual-list", height: height, itemHeight: itemHeight, fullHeight: fullHeight, data: data, itemKey: itemKey, virtual: virtual, component: Component = "div", onScroll: onScroll, children: children = this.$slots.default, style: style, class: className} = _a, restProps = __rest$d(_a, [ "prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class" ]), mergedClassName = classNames(prefixCls, className), {scrollTop: scrollTop} = this.state, {scrollHeight: scrollHeight, offset: offset, start: start, end: end} = this.calRes, {componentStyle: componentStyle, onFallbackScroll: onFallbackScroll, onScrollBar: onScrollBar, useVirtual: useVirtual, collectHeight: collectHeight, sharedConfig: sharedConfig, setInstance: setInstance, mergedData: mergedData, delayHideScrollBar: delayHideScrollBar} = this;
                return createVNode("div", _objectSpread2$1({
                    style: _extends$1(_extends$1({}, style), {
                        position: "relative"
                    }),
                    class: mergedClassName
                }, restProps), [ createVNode(Component, {
                    class: `${prefixCls}-holder`,
                    style: componentStyle,
                    ref: "componentRef",
                    onScroll: onFallbackScroll,
                    onMouseenter: delayHideScrollBar
                }, {
                    default: () => [ createVNode(Filter, {
                        prefixCls: prefixCls,
                        height: scrollHeight,
                        offset: offset,
                        onInnerResize: collectHeight,
                        ref: "fillerInnerRef"
                    }, {
                        default: () => renderChildren(mergedData, start, end, setInstance, children, sharedConfig)
                    }) ]
                }), useVirtual && createVNode(ScrollBar, {
                    ref: "scrollBarRef",
                    prefixCls: prefixCls,
                    scrollTop: scrollTop,
                    height: height,
                    scrollHeight: scrollHeight,
                    count: mergedData.length,
                    onScroll: onScrollBar,
                    onStartMove: () => {
                        this.state.scrollMoving = !0;
                    },
                    onStopMove: () => {
                        this.state.scrollMoving = !1;
                    }
                }, null) ]);
            }
        });
        function useMemo(getValue2, condition, shouldUpdate) {
            const cacheRef = ref(getValue2());
            return watch(condition, ((next2, pre) => {
                shouldUpdate ? shouldUpdate(next2, pre) && (cacheRef.value = getValue2()) : cacheRef.value = getValue2();
            })), cacheRef;
        }
        function isPlatformMac() {
            return /(mac\sos|macintosh)/i.test(navigator.appVersion);
        }
        const SelectContextKey = Symbol("SelectContextKey");
        function useProvideSelectProps(props2) {
            return provide(SelectContextKey, props2);
        }
        function useSelectProps() {
            return inject(SelectContextKey, {});
        }
        var __rest$c = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        function isTitleType(content) {
            return "string" == typeof content || "number" == typeof content;
        }
        const OptionList = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "OptionList",
            inheritAttrs: !1,
            setup(_2, _ref) {
                let {expose: expose, slots: slots} = _ref;
                const baseProps = useBaseProps(), props2 = useSelectProps(), itemPrefixCls = computed((() => `${baseProps.prefixCls}-item`)), memoFlattenOptions = useMemo((() => props2.flattenOptions), [ () => baseProps.open, () => props2.flattenOptions ], (next2 => next2[0])), listRef = createRef(), onListMouseDown = event => {
                    event.preventDefault();
                }, scrollIntoView2 = args => {
                    listRef.current && listRef.current.scrollTo("number" == typeof args ? {
                        index: args
                    } : args);
                }, getEnabledActiveIndex = function(index2) {
                    let offset = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    const len = memoFlattenOptions.value.length;
                    for (let i2 = 0; i2 < len; i2 += 1) {
                        const current = (index2 + i2 * offset + len) % len, {group: group, data: data} = memoFlattenOptions.value[current];
                        if (!group && !data.disabled) return current;
                    }
                    return -1;
                }, state = reactive({
                    activeIndex: getEnabledActiveIndex(0)
                }), setActive = function(index2) {
                    let fromKeyboard = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    state.activeIndex = index2;
                    const info = {
                        source: fromKeyboard ? "keyboard" : "mouse"
                    }, flattenItem = memoFlattenOptions.value[index2];
                    flattenItem ? props2.onActiveValue(flattenItem.value, index2, info) : props2.onActiveValue(null, -1, info);
                };
                watch([ () => memoFlattenOptions.value.length, () => baseProps.searchValue ], (() => {
                    setActive(!1 !== props2.defaultActiveFirstOption ? getEnabledActiveIndex(0) : -1);
                }), {
                    immediate: !0
                });
                const isSelected = value => props2.rawValues.has(value) && "combobox" !== baseProps.mode;
                watch([ () => baseProps.open, () => baseProps.searchValue ], (() => {
                    if (!baseProps.multiple && baseProps.open && 1 === props2.rawValues.size) {
                        const value = Array.from(props2.rawValues)[0], index2 = toRaw(memoFlattenOptions.value).findIndex((_ref2 => {
                            let {data: data} = _ref2;
                            return data[props2.fieldNames.value] === value;
                        }));
                        -1 !== index2 && (setActive(index2), nextTick((() => {
                            scrollIntoView2(index2);
                        })));
                    }
                    baseProps.open && nextTick((() => {
                        var _a;
                        null === (_a = listRef.current) || void 0 === _a || _a.scrollTo(void 0);
                    }));
                }), {
                    immediate: !0,
                    flush: "post"
                });
                const onSelectValue = value => {
                    void 0 !== value && props2.onSelect(value, {
                        selected: !props2.rawValues.has(value)
                    }), baseProps.multiple || baseProps.toggleOpen(!1);
                }, getLabel = item => "function" == typeof item.label ? item.label() : item.label;
                function renderItem(index2) {
                    const item = memoFlattenOptions.value[index2];
                    if (!item) return null;
                    const itemData = item.data || {}, {value: value} = itemData, {group: group} = item, attrs = pickAttrs(itemData, !0), mergedLabel = getLabel(item);
                    return item ? createVNode("div", _objectSpread2$1(_objectSpread2$1({
                        "aria-label": "string" != typeof mergedLabel || group ? null : mergedLabel
                    }, attrs), {}, {
                        key: index2,
                        role: group ? "presentation" : "option",
                        id: `${baseProps.id}_list_${index2}`,
                        "aria-selected": isSelected(value)
                    }), [ value ]) : null;
                }
                return expose({
                    onKeydown: event => {
                        const {which: which, ctrlKey: ctrlKey} = event;
                        switch (which) {
                          case KeyCode.N:
                          case KeyCode.P:
                          case KeyCode.UP:
                          case KeyCode.DOWN:
                            {
                                let offset = 0;
                                if (which === KeyCode.UP ? offset = -1 : which === KeyCode.DOWN ? offset = 1 : isPlatformMac() && ctrlKey && (which === KeyCode.N ? offset = 1 : which === KeyCode.P && (offset = -1)), 
                                0 !== offset) {
                                    const nextActiveIndex = getEnabledActiveIndex(state.activeIndex + offset, offset);
                                    scrollIntoView2(nextActiveIndex), setActive(nextActiveIndex, !0);
                                }
                                break;
                            }

                          case KeyCode.ENTER:
                            {
                                const item = memoFlattenOptions.value[state.activeIndex];
                                item && !item.data.disabled ? onSelectValue(item.value) : onSelectValue(void 0), 
                                baseProps.open && event.preventDefault();
                                break;
                            }

                          case KeyCode.ESC:
                            baseProps.toggleOpen(!1), baseProps.open && event.stopPropagation();
                        }
                    },
                    onKeyup: () => {},
                    scrollTo: index2 => {
                        scrollIntoView2(index2);
                    }
                }), () => {
                    const {id: id, notFoundContent: notFoundContent, onPopupScroll: onPopupScroll} = baseProps, {menuItemSelectedIcon: menuItemSelectedIcon, fieldNames: fieldNames, virtual: virtual, listHeight: listHeight, listItemHeight: listItemHeight} = props2, renderOption = slots.option, {activeIndex: activeIndex} = state, omitFieldNameList = Object.keys(fieldNames).map((key2 => fieldNames[key2]));
                    return 0 === memoFlattenOptions.value.length ? createVNode("div", {
                        role: "listbox",
                        id: `${id}_list`,
                        class: `${itemPrefixCls.value}-empty`,
                        onMousedown: onListMouseDown
                    }, [ notFoundContent ]) : createVNode(Fragment, null, [ createVNode("div", {
                        role: "listbox",
                        id: `${id}_list`,
                        style: {
                            height: 0,
                            width: 0,
                            overflow: "hidden"
                        }
                    }, [ renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1) ]), createVNode(List, {
                        itemKey: "key",
                        ref: listRef,
                        data: memoFlattenOptions.value,
                        height: listHeight,
                        itemHeight: listItemHeight,
                        fullHeight: !1,
                        onMousedown: onListMouseDown,
                        onScroll: onPopupScroll,
                        virtual: virtual
                    }, {
                        default: (item, itemIndex) => {
                            var _a;
                            const {group: group, groupOption: groupOption, data: data, value: value} = item, {key: key2} = data, label = "function" == typeof item.label ? item.label() : item.label;
                            if (group) {
                                const groupTitle = null !== (_a = data.title) && void 0 !== _a ? _a : isTitleType(label) && label;
                                return createVNode("div", {
                                    class: classNames(itemPrefixCls.value, `${itemPrefixCls.value}-group`),
                                    title: groupTitle
                                }, [ renderOption ? renderOption(data) : void 0 !== label ? label : key2 ]);
                            }
                            const {disabled: disabled, title: title, children: children, style: style, class: cls, className: className} = data, otherProps = __rest$c(data, [ "disabled", "title", "children", "style", "class", "className" ]), passedProps = omit(otherProps, omitFieldNameList), selected = isSelected(value), optionPrefixCls = `${itemPrefixCls.value}-option`, optionClassName = classNames(itemPrefixCls.value, optionPrefixCls, cls, className, {
                                [`${optionPrefixCls}-grouped`]: groupOption,
                                [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !disabled,
                                [`${optionPrefixCls}-disabled`]: disabled,
                                [`${optionPrefixCls}-selected`]: selected
                            }), mergedLabel = getLabel(item), iconVisible = !menuItemSelectedIcon || "function" == typeof menuItemSelectedIcon || selected, content = "number" == typeof mergedLabel ? mergedLabel : mergedLabel || value;
                            let optionTitle = isTitleType(content) ? content.toString() : void 0;
                            return void 0 !== title && (optionTitle = title), createVNode("div", _objectSpread2$1(_objectSpread2$1({}, passedProps), {}, {
                                "aria-selected": selected,
                                class: optionClassName,
                                title: optionTitle,
                                onMousemove: e2 => {
                                    otherProps.onMousemove && otherProps.onMousemove(e2), activeIndex === itemIndex || disabled || setActive(itemIndex);
                                },
                                onClick: e2 => {
                                    disabled || onSelectValue(value), otherProps.onClick && otherProps.onClick(e2);
                                },
                                style: style
                            }), [ createVNode("div", {
                                class: `${optionPrefixCls}-content`
                            }, [ renderOption ? renderOption(data) : content ]), isValidElement(menuItemSelectedIcon) || selected, iconVisible && createVNode(TransBtn, {
                                class: `${itemPrefixCls.value}-option-state`,
                                customizeIcon: menuItemSelectedIcon,
                                customizeIconProps: {
                                    isSelected: selected
                                }
                            }, {
                                default: () => [ selected ? "✓" : null ]
                            }) ]);
                        }
                    }) ]);
                };
            }
        });
        var __rest$b = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        function convertNodeToOption(node2) {
            const _a = node2, {key: key2, children: children} = _a, _b = _a.props, {value: value, disabled: disabled} = _b, restProps = __rest$b(_b, [ "value", "disabled" ]);
            return _extends$1({
                key: key2,
                value: void 0 !== value ? value : key2,
                children: null == children ? void 0 : children.default,
                disabled: disabled || "" === disabled
            }, restProps);
        }
        function convertChildrenToData(nodes) {
            let optionOnly = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return flattenChildren(nodes).map(((node2, index2) => {
                var _a;
                if (!isValidElement(node2) || !node2.type) return null;
                const {type: {isSelectOptGroup: isSelectOptGroup}, key: key2, children: children, props: props2} = node2;
                if (optionOnly || !isSelectOptGroup) return convertNodeToOption(node2);
                const child = children && children.default ? children.default() : void 0, label = (null == props2 ? void 0 : props2.label) || (null === (_a = children.label) || void 0 === _a ? void 0 : _a.call(children)) || key2;
                return _extends$1(_extends$1({
                    key: `__RC_SELECT_GRP__${null === key2 ? index2 : String(key2)}__`
                }, props2), {
                    label: label,
                    options: convertChildrenToData(child || [])
                });
            })).filter((data => data));
        }
        function useOptions(options, children, fieldNames) {
            const mergedOptions = shallowRef(), valueOptions = shallowRef(), labelOptions = shallowRef(), tempMergedOptions = shallowRef([]);
            return watch([ options, children ], (() => {
                options.value ? tempMergedOptions.value = toRaw(options.value).slice() : tempMergedOptions.value = convertChildrenToData(children.value);
            }), {
                immediate: !0,
                deep: !0
            }), watchEffect((() => {
                const newOptions = tempMergedOptions.value, newValueOptions = new Map, newLabelOptions = new Map, fieldNamesValue = fieldNames.value;
                function dig(optionList) {
                    let isChildren = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    for (let i2 = 0; i2 < optionList.length; i2 += 1) {
                        const option = optionList[i2];
                        !option[fieldNamesValue.options] || isChildren ? (newValueOptions.set(option[fieldNamesValue.value], option), 
                        newLabelOptions.set(option[fieldNamesValue.label], option)) : dig(option[fieldNamesValue.options], !0);
                    }
                }
                dig(newOptions), mergedOptions.value = newOptions, valueOptions.value = newValueOptions, 
                labelOptions.value = newLabelOptions;
            })), {
                options: mergedOptions,
                valueOptions: valueOptions,
                labelOptions: labelOptions
            };
        }
        let uuid = 0;
        const isBrowserClient = canUseDom$1();
        function getUUID() {
            let retId;
            return isBrowserClient ? (retId = uuid, uuid += 1) : retId = "TEST_OR_SSR", retId;
        }
        function useId() {
            let id = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ref("");
            const innerId = `rc_select_${getUUID()}`;
            return id.value || innerId;
        }
        function toArray$2(value) {
            return Array.isArray(value) ? value : void 0 !== value ? [ value ] : [];
        }
        function includes(test, search) {
            return toArray$2(test).join("").toUpperCase().includes(search);
        }
        const useFilterOptions = (options, fieldNames, searchValue, filterOption, optionFilterProp) => computed((() => {
            const searchValueVal = searchValue.value, optionFilterPropValue = null == optionFilterProp ? void 0 : optionFilterProp.value, filterOptionValue = null == filterOption ? void 0 : filterOption.value;
            if (!searchValueVal || !1 === filterOptionValue) return options.value;
            const {options: fieldOptions, label: fieldLabel, value: fieldValue} = fieldNames.value, filteredOptions = [], customizeFilter = "function" == typeof filterOptionValue, upperSearch = searchValueVal.toUpperCase(), filterFunc = customizeFilter ? filterOptionValue : (_2, option) => optionFilterPropValue ? includes(option[optionFilterPropValue], upperSearch) : option[fieldOptions] ? includes(option["children" !== fieldLabel ? fieldLabel : "label"], upperSearch) : includes(option[fieldValue], upperSearch), wrapOption = customizeFilter ? opt => injectPropsWithOption(opt) : opt => opt;
            return options.value.forEach((item => {
                if (item[fieldOptions]) {
                    if (filterFunc(searchValueVal, wrapOption(item))) filteredOptions.push(item); else {
                        const subOptions = item[fieldOptions].filter((subItem => filterFunc(searchValueVal, wrapOption(subItem))));
                        subOptions.length && filteredOptions.push(_extends$1(_extends$1({}, item), {
                            [fieldOptions]: subOptions
                        }));
                    }
                } else filterFunc(searchValueVal, wrapOption(item)) && filteredOptions.push(item);
            })), filteredOptions;
        })), useCache = (labeledValues, valueOptions) => {
            const cacheRef = shallowRef({
                values: new Map,
                options: new Map
            });
            return [ computed((() => {
                const {values: prevValueCache, options: prevOptionCache} = cacheRef.value, patchedValues = labeledValues.value.map((item => {
                    var _a;
                    return void 0 === item.label ? _extends$1(_extends$1({}, item), {
                        label: null === (_a = prevValueCache.get(item.value)) || void 0 === _a ? void 0 : _a.label
                    }) : item;
                })), valueCache = new Map, optionCache = new Map;
                return patchedValues.forEach((item => {
                    valueCache.set(item.value, item), optionCache.set(item.value, valueOptions.value.get(item.value) || prevOptionCache.get(item.value));
                })), cacheRef.value.values = valueCache, cacheRef.value.options = optionCache, patchedValues;
            })), val => valueOptions.value.get(val) || cacheRef.value.options.get(val) ];
        };
        function useMergedState(defaultStateValue, option) {
            const {defaultValue: defaultValue, value: value = ref()} = option || {};
            let initValue = "function" == typeof defaultStateValue ? defaultStateValue() : defaultStateValue;
            void 0 !== value.value && (initValue = unref(value)), void 0 !== defaultValue && (initValue = "function" == typeof defaultValue ? defaultValue() : defaultValue);
            const innerValue = ref(initValue), mergedValue = ref(initValue);
            function triggerChange(newValue) {
                const preVal = mergedValue.value;
                innerValue.value = newValue, toRaw(mergedValue.value) !== newValue && option.onChange && option.onChange(newValue, preVal);
            }
            return watchEffect((() => {
                let val = void 0 !== value.value ? value.value : innerValue.value;
                option.postState && (val = option.postState(val)), mergedValue.value = val;
            })), watch(value, (() => {
                innerValue.value = value.value;
            })), [ mergedValue, triggerChange ];
        }
        function useState(defaultStateValue) {
            const innerValue = ref("function" == typeof defaultStateValue ? defaultStateValue() : defaultStateValue);
            function triggerChange(newValue) {
                innerValue.value = newValue;
            }
            return [ innerValue, triggerChange ];
        }
        const OMIT_DOM_PROPS = [ "inputValue" ];
        function selectProps$1() {
            return _extends$1(_extends$1({}, baseSelectPropsWithoutPrivate()), {
                prefixCls: String,
                id: String,
                backfill: {
                    type: Boolean,
                    default: void 0
                },
                fieldNames: Object,
                inputValue: String,
                searchValue: String,
                onSearch: Function,
                autoClearSearchValue: {
                    type: Boolean,
                    default: void 0
                },
                onSelect: Function,
                onDeselect: Function,
                filterOption: {
                    type: [ Boolean, Function ],
                    default: void 0
                },
                filterSort: Function,
                optionFilterProp: String,
                optionLabelProp: String,
                options: Array,
                defaultActiveFirstOption: {
                    type: Boolean,
                    default: void 0
                },
                virtual: {
                    type: Boolean,
                    default: void 0
                },
                listHeight: Number,
                listItemHeight: Number,
                menuItemSelectedIcon: PropTypes.any,
                mode: String,
                labelInValue: {
                    type: Boolean,
                    default: void 0
                },
                value: PropTypes.any,
                defaultValue: PropTypes.any,
                onChange: Function,
                children: Array
            });
        }
        function isRawValue(value) {
            return !value || "object" != typeof value;
        }
        const Select$1 = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "VcSelect",
            inheritAttrs: !1,
            props: initDefaultProps(selectProps$1(), {
                prefixCls: "vc-select",
                autoClearSearchValue: !0,
                listHeight: 200,
                listItemHeight: 20,
                dropdownMatchSelectWidth: !0
            }),
            setup(props2, _ref) {
                let {expose: expose, attrs: attrs, slots: slots} = _ref;
                const mergedId = useId(toRef(props2, "id")), multiple = computed((() => isMultiple(props2.mode))), childrenAsData = computed((() => !(props2.options || !props2.children))), mergedFilterOption = computed((() => (void 0 !== props2.filterOption || "combobox" !== props2.mode) && props2.filterOption)), mergedFieldNames = computed((() => fillFieldNames(props2.fieldNames, childrenAsData.value))), [mergedSearchValue, setSearchValue] = useMergedState("", {
                    value: computed((() => void 0 !== props2.searchValue ? props2.searchValue : props2.inputValue)),
                    postState: search => search || ""
                }), parsedOptions = useOptions(toRef(props2, "options"), toRef(props2, "children"), mergedFieldNames), {valueOptions: valueOptions, labelOptions: labelOptions, options: mergedOptions} = parsedOptions, convert2LabelValues = draftValues => toArray$2(draftValues).map((val => {
                    var _a, _b;
                    let rawValue, rawLabel, rawKey, rawDisabled;
                    isRawValue(val) ? rawValue = val : (rawKey = val.key, rawLabel = val.label, rawValue = null !== (_a = val.value) && void 0 !== _a ? _a : rawKey);
                    const option = valueOptions.value.get(rawValue);
                    return option && (void 0 === rawLabel && (rawLabel = null == option ? void 0 : option[props2.optionLabelProp || mergedFieldNames.value.label]), 
                    void 0 === rawKey && (rawKey = null !== (_b = null == option ? void 0 : option.key) && void 0 !== _b ? _b : rawValue), 
                    rawDisabled = null == option ? void 0 : option.disabled), {
                        label: rawLabel,
                        value: rawValue,
                        key: rawKey,
                        disabled: rawDisabled,
                        option: option
                    };
                })), [internalValue, setInternalValue] = useMergedState(props2.defaultValue, {
                    value: toRef(props2, "value")
                }), rawLabeledValues = computed((() => {
                    var _a;
                    const values = convert2LabelValues(internalValue.value);
                    return "combobox" !== props2.mode || (null === (_a = values[0]) || void 0 === _a ? void 0 : _a.value) ? values : [];
                })), [mergedValues, getMixedOption] = useCache(rawLabeledValues, valueOptions), displayValues = computed((() => {
                    if (!props2.mode && 1 === mergedValues.value.length) {
                        const firstValue = mergedValues.value[0];
                        if (null === firstValue.value && (null === firstValue.label || void 0 === firstValue.label)) return [];
                    }
                    return mergedValues.value.map((item => {
                        var _a;
                        return _extends$1(_extends$1({}, item), {
                            label: null !== (_a = "function" == typeof item.label ? item.label() : item.label) && void 0 !== _a ? _a : item.value
                        });
                    }));
                })), rawValues = computed((() => new Set(mergedValues.value.map((val => val.value)))));
                watchEffect((() => {
                    var _a;
                    if ("combobox" === props2.mode) {
                        const strValue = null === (_a = mergedValues.value[0]) || void 0 === _a ? void 0 : _a.value;
                        null != strValue && setSearchValue(String(strValue));
                    }
                }), {
                    flush: "post"
                });
                const createTagOption = (val, label) => {
                    const mergedLabel = null != label ? label : val;
                    return {
                        [mergedFieldNames.value.value]: val,
                        [mergedFieldNames.value.label]: mergedLabel
                    };
                }, filledTagOptions = shallowRef();
                watchEffect((() => {
                    if ("tags" !== props2.mode) return void (filledTagOptions.value = mergedOptions.value);
                    const cloneOptions = mergedOptions.value.slice(), existOptions = val => valueOptions.value.has(val);
                    [ ...mergedValues.value ].sort(((a2, b2) => a2.value < b2.value ? -1 : 1)).forEach((item => {
                        const val = item.value;
                        existOptions(val) || cloneOptions.push(createTagOption(val, item.label));
                    })), filledTagOptions.value = cloneOptions;
                }));
                const filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, toRef(props2, "optionFilterProp")), filledSearchOptions = computed((() => "tags" !== props2.mode || !mergedSearchValue.value || filteredOptions.value.some((item => item[props2.optionFilterProp || "value"] === mergedSearchValue.value)) ? filteredOptions.value : [ createTagOption(mergedSearchValue.value), ...filteredOptions.value ])), orderedFilteredOptions = computed((() => props2.filterSort ? [ ...filledSearchOptions.value ].sort(((a2, b2) => props2.filterSort(a2, b2))) : filledSearchOptions.value)), displayOptions = computed((() => flattenOptions(orderedFilteredOptions.value, {
                    fieldNames: mergedFieldNames.value,
                    childrenAsData: childrenAsData.value
                }))), triggerChange = values => {
                    const labeledValues = convert2LabelValues(values);
                    if (setInternalValue(labeledValues), props2.onChange && (labeledValues.length !== mergedValues.value.length || labeledValues.some(((newVal, index2) => {
                        var _a;
                        return (null === (_a = mergedValues.value[index2]) || void 0 === _a ? void 0 : _a.value) !== (null == newVal ? void 0 : newVal.value);
                    })))) {
                        const returnValues = props2.labelInValue ? labeledValues.map((v2 => _extends$1(_extends$1({}, v2), {
                            originLabel: v2.label,
                            label: "function" == typeof v2.label ? v2.label() : v2.label
                        }))) : labeledValues.map((v2 => v2.value)), returnOptions = labeledValues.map((v2 => injectPropsWithOption(getMixedOption(v2.value))));
                        props2.onChange(multiple.value ? returnValues : returnValues[0], multiple.value ? returnOptions : returnOptions[0]);
                    }
                }, [activeValue, setActiveValue] = useState(null), [accessibilityIndex, setAccessibilityIndex] = useState(0), mergedDefaultActiveFirstOption = computed((() => void 0 !== props2.defaultActiveFirstOption ? props2.defaultActiveFirstOption : "combobox" !== props2.mode)), onActiveValue = function(active, index2) {
                    let {source: source = "keyboard"} = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    setAccessibilityIndex(index2), props2.backfill && "combobox" === props2.mode && null !== active && "keyboard" === source && setActiveValue(String(active));
                }, triggerSelect = (val, selected) => {
                    const getSelectEnt = () => {
                        var _a;
                        const option = getMixedOption(val), originLabel = null == option ? void 0 : option[mergedFieldNames.value.label];
                        return [ props2.labelInValue ? {
                            label: "function" == typeof originLabel ? originLabel() : originLabel,
                            originLabel: originLabel,
                            value: val,
                            key: null !== (_a = null == option ? void 0 : option.key) && void 0 !== _a ? _a : val
                        } : val, injectPropsWithOption(option) ];
                    };
                    if (selected && props2.onSelect) {
                        const [wrappedValue, option] = getSelectEnt();
                        props2.onSelect(wrappedValue, option);
                    } else if (!selected && props2.onDeselect) {
                        const [wrappedValue, option] = getSelectEnt();
                        props2.onDeselect(wrappedValue, option);
                    }
                }, onInternalSelect = (val, info) => {
                    let cloneValues;
                    const mergedSelect = !multiple.value || info.selected;
                    cloneValues = mergedSelect ? multiple.value ? [ ...mergedValues.value, val ] : [ val ] : mergedValues.value.filter((v2 => v2.value !== val)), 
                    triggerChange(cloneValues), triggerSelect(val, mergedSelect), "combobox" === props2.mode ? setActiveValue("") : multiple.value && !props2.autoClearSearchValue || (setSearchValue(""), 
                    setActiveValue(""));
                }, onDisplayValuesChange = (nextValues, info) => {
                    triggerChange(nextValues), "remove" !== info.type && "clear" !== info.type || info.values.forEach((item => {
                        triggerSelect(item.value, !1);
                    }));
                }, onInternalSearch = (searchText, info) => {
                    var _a;
                    if (setSearchValue(searchText), setActiveValue(null), "submit" !== info.source) "blur" !== info.source && ("combobox" === props2.mode && triggerChange(searchText), 
                    null === (_a = props2.onSearch) || void 0 === _a || _a.call(props2, searchText)); else {
                        const formatted = (searchText || "").trim();
                        if (formatted) {
                            const newRawValues = Array.from(new Set([ ...rawValues.value, formatted ]));
                            triggerChange(newRawValues), triggerSelect(formatted, !0), setSearchValue("");
                        }
                    }
                }, onInternalSearchSplit = words => {
                    let patchValues = words;
                    "tags" !== props2.mode && (patchValues = words.map((word => {
                        const opt = labelOptions.value.get(word);
                        return null == opt ? void 0 : opt.value;
                    })).filter((val => void 0 !== val)));
                    const newRawValues = Array.from(new Set([ ...rawValues.value, ...patchValues ]));
                    triggerChange(newRawValues), newRawValues.forEach((newRawValue => {
                        triggerSelect(newRawValue, !0);
                    }));
                }, realVirtual = computed((() => !1 !== props2.virtual && !1 !== props2.dropdownMatchSelectWidth));
                useProvideSelectProps(toReactive(_extends$1(_extends$1({}, parsedOptions), {
                    flattenOptions: displayOptions,
                    onActiveValue: onActiveValue,
                    defaultActiveFirstOption: mergedDefaultActiveFirstOption,
                    onSelect: onInternalSelect,
                    menuItemSelectedIcon: toRef(props2, "menuItemSelectedIcon"),
                    rawValues: rawValues,
                    fieldNames: mergedFieldNames,
                    virtual: realVirtual,
                    listHeight: toRef(props2, "listHeight"),
                    listItemHeight: toRef(props2, "listItemHeight"),
                    childrenAsData: childrenAsData
                })));
                const selectRef = ref();
                expose({
                    focus() {
                        var _a;
                        null === (_a = selectRef.value) || void 0 === _a || _a.focus();
                    },
                    blur() {
                        var _a;
                        null === (_a = selectRef.value) || void 0 === _a || _a.blur();
                    },
                    scrollTo(arg) {
                        var _a;
                        null === (_a = selectRef.value) || void 0 === _a || _a.scrollTo(arg);
                    }
                });
                const pickProps = computed((() => omit(props2, [ "id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange" ])));
                return () => createVNode(BaseSelect, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, pickProps.value), attrs), {}, {
                    id: mergedId,
                    prefixCls: props2.prefixCls,
                    ref: selectRef,
                    omitDomProps: OMIT_DOM_PROPS,
                    mode: props2.mode,
                    displayValues: displayValues.value,
                    onDisplayValuesChange: onDisplayValuesChange,
                    searchValue: mergedSearchValue.value,
                    onSearch: onInternalSearch,
                    onSearchSplit: onInternalSearchSplit,
                    dropdownMatchSelectWidth: props2.dropdownMatchSelectWidth,
                    OptionList: OptionList,
                    emptyOptions: !displayOptions.value.length,
                    activeValue: activeValue.value,
                    activeDescendantId: `${mergedId}_list_${accessibilityIndex.value}`
                }), slots);
            }
        }), Option = () => null;
        Option.isSelectOption = !0, Option.displayName = "ASelectOption";
        const OptGroup = () => null;
        OptGroup.isSelectOptGroup = !0, OptGroup.displayName = "ASelectOptGroup";
        var DownOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"
                    }
                } ]
            },
            name: "down",
            theme: "outlined"
        }, contextKey = Symbol("iconContext"), useInjectIconContext = function useInjectIconContext2() {
            return inject(contextKey, {
                prefixCls: ref("anticon"),
                rootClassName: ref(""),
                csp: ref()
            });
        };
        function canUseDom() {
            return !("undefined" == typeof window || !window.document || !window.document.createElement);
        }
        function contains(root2, n2) {
            return !!root2 && (!!root2.contains && root2.contains(n2));
        }
        var APPEND_ORDER = "data-vc-order", MARK_KEY = "vc-icon-key", containerCache = new Map;
        function getMark() {
            var mark = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).mark;
            return mark ? mark.startsWith("data-") ? mark : "data-".concat(mark) : MARK_KEY;
        }
        function getContainer$1(option) {
            return option.attachTo ? option.attachTo : document.querySelector("head") || document.body;
        }
        function getOrder(prepend) {
            return "queue" === prepend ? "prependQueue" : prepend ? "prepend" : "append";
        }
        function findStyles(container) {
            return Array.from((containerCache.get(container) || container).children).filter((function(node2) {
                return "STYLE" === node2.tagName;
            }));
        }
        function injectCSS(css2) {
            var option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (!canUseDom()) return null;
            var csp = option.csp, prepend = option.prepend, styleNode = document.createElement("style");
            styleNode.setAttribute(APPEND_ORDER, getOrder(prepend)), csp && csp.nonce && (styleNode.nonce = csp.nonce), 
            styleNode.innerHTML = css2;
            var container = getContainer$1(option), firstChild = container.firstChild;
            if (prepend) {
                if ("queue" === prepend) {
                    var existStyle = findStyles(container).filter((function(node2) {
                        return [ "prepend", "prependQueue" ].includes(node2.getAttribute(APPEND_ORDER));
                    }));
                    if (existStyle.length) return container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling), 
                    styleNode;
                }
                container.insertBefore(styleNode, firstChild);
            } else container.appendChild(styleNode);
            return styleNode;
        }
        function findExistNode(key2) {
            var option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return findStyles(getContainer$1(option)).find((function(node2) {
                return node2.getAttribute(getMark(option)) === key2;
            }));
        }
        function syncRealContainer(container, option) {
            var cachedRealContainer = containerCache.get(container);
            if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
                var placeholderStyle = injectCSS("", option), parentNode = placeholderStyle.parentNode;
                containerCache.set(container, parentNode), container.removeChild(placeholderStyle);
            }
        }
        function updateCSS(css2, key2) {
            var option = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            syncRealContainer(getContainer$1(option), option);
            var existNode = findExistNode(key2, option);
            if (existNode) return option.csp && option.csp.nonce && existNode.nonce !== option.csp.nonce && (existNode.nonce = option.csp.nonce), 
            existNode.innerHTML !== css2 && (existNode.innerHTML = css2), existNode;
            var newNode = injectCSS(css2, option);
            return newNode.setAttribute(getMark(option), key2), newNode;
        }
        function _objectSpread$j(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$j(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$j(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        function warning$1(valid, message) {}
        function isIconDefinition(target) {
            return "object" == typeof target && "string" == typeof target.name && "string" == typeof target.theme && ("object" == typeof target.icon || "function" == typeof target.icon);
        }
        function generate(node2, key2, rootProps) {
            return h$1(node2.tag, rootProps ? _objectSpread$j({
                key: key2
            }, rootProps, node2.attrs) : _objectSpread$j({
                key: key2
            }, node2.attrs), (node2.children || []).map((function(child, index2) {
                return generate(child, "".concat(key2, "-").concat(node2.tag, "-").concat(index2));
            })));
        }
        function getSecondaryColor(primaryColor) {
            return generate$1(primaryColor)[0];
        }
        function normalizeTwoToneColors(twoToneColor) {
            return twoToneColor ? Array.isArray(twoToneColor) ? twoToneColor : [ twoToneColor ] : [];
        }
        var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
        function getRoot(ele) {
            return ele && ele.getRootNode && ele.getRootNode();
        }
        function inShadow(ele) {
            return !!canUseDom() && getRoot(ele) instanceof ShadowRoot;
        }
        function getShadowRoot(ele) {
            return inShadow(ele) ? getRoot(ele) : null;
        }
        var useInsertStyles = function useInsertStyles2() {
            var _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, csp = _useInjectIconContext.csp, instance = getCurrentInstance(), mergedStyleStr = iconStyles;
            prefixCls && (mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls.value)), 
            nextTick((function() {
                if (canUseDom()) {
                    var shadowRoot = getShadowRoot(instance.vnode.el);
                    updateCSS(mergedStyleStr, "@ant-design-vue-icons", {
                        prepend: !0,
                        csp: csp.value,
                        attachTo: shadowRoot
                    });
                }
            }));
        }, _excluded$1 = [ "icon", "primaryColor", "secondaryColor" ];
        function _objectWithoutProperties$1(source, excluded) {
            if (null == source) return {};
            var key2, i2, target = _objectWithoutPropertiesLoose$1(source, excluded);
            if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) key2 = sourceSymbolKeys[i2], excluded.indexOf(key2) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key2) && (target[key2] = source[key2]);
            }
            return target;
        }
        function _objectWithoutPropertiesLoose$1(source, excluded) {
            if (null == source) return {};
            var key2, i2, target = {}, sourceKeys = Object.keys(source);
            for (i2 = 0; i2 < sourceKeys.length; i2++) key2 = sourceKeys[i2], excluded.indexOf(key2) >= 0 || (target[key2] = source[key2]);
            return target;
        }
        function _objectSpread$i(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$i(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$i(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var twoToneColorPalette = reactive({
            primaryColor: "#333",
            secondaryColor: "#E6E6E6",
            calculated: !1
        });
        function setTwoToneColors(_ref) {
            var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
            twoToneColorPalette.primaryColor = primaryColor, twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor), 
            twoToneColorPalette.calculated = !!secondaryColor;
        }
        function getTwoToneColors() {
            return _objectSpread$i({}, twoToneColorPalette);
        }
        var IconBase = function IconBase2(props2, context) {
            var _props$context$attrs = _objectSpread$i({}, props2, context.attrs), icon = _props$context$attrs.icon, primaryColor = _props$context$attrs.primaryColor, secondaryColor = _props$context$attrs.secondaryColor, restProps = _objectWithoutProperties$1(_props$context$attrs, _excluded$1), colors = twoToneColorPalette;
            if (primaryColor && (colors = {
                primaryColor: primaryColor,
                secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
            }), warning$1(isIconDefinition(icon)), !isIconDefinition(icon)) return null;
            var target = icon;
            return target && "function" == typeof target.icon && (target = _objectSpread$i({}, target, {
                icon: target.icon(colors.primaryColor, colors.secondaryColor)
            })), generate(target.icon, "svg-".concat(target.name), _objectSpread$i({}, restProps, {
                "data-icon": target.name,
                width: "1em",
                height: "1em",
                fill: "currentColor",
                "aria-hidden": "true"
            }));
        };
        function _slicedToArray$1(arr, i2) {
            return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
        }
        function _nonIterableRest$1() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray$1(o2, minLen) {
            if (o2) {
                if ("string" == typeof o2) return _arrayLikeToArray$1(o2, minLen);
                var n2 = Object.prototype.toString.call(o2).slice(8, -1);
                return "Object" === n2 && o2.constructor && (n2 = o2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(o2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? _arrayLikeToArray$1(o2, minLen) : void 0;
            }
        }
        function _arrayLikeToArray$1(arr, len) {
            (null == len || len > arr.length) && (len = arr.length);
            for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
            return arr2;
        }
        function _iterableToArrayLimit$1(arr, i2) {
            var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
            if (null != _i) {
                var _s, _e, _arr = [], _n = !0, _d = !1;
                try {
                    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i2 || _arr.length !== i2); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        _n || null == _i.return || _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
        }
        function _arrayWithHoles$1(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function setTwoToneColor(twoToneColor) {
            var _normalizeTwoToneColo2 = _slicedToArray$1(normalizeTwoToneColors(twoToneColor), 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
            return IconBase.setTwoToneColors({
                primaryColor: primaryColor,
                secondaryColor: secondaryColor
            });
        }
        function getTwoToneColor() {
            var colors = IconBase.getTwoToneColors();
            return colors.calculated ? [ colors.primaryColor, colors.secondaryColor ] : colors.primaryColor;
        }
        IconBase.props = {
            icon: Object,
            primaryColor: String,
            secondaryColor: String,
            focusable: String
        }, IconBase.inheritAttrs = !1, IconBase.displayName = "IconBase", IconBase.getTwoToneColors = getTwoToneColors, 
        IconBase.setTwoToneColors = setTwoToneColors;
        var InsertStyles = defineComponent({
            name: "InsertStyles",
            setup: function setup() {
                return useInsertStyles(), function() {
                    return null;
                };
            }
        }), _excluded = [ "class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick" ];
        function _slicedToArray(arr, i2) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o2, minLen) {
            if (o2) {
                if ("string" == typeof o2) return _arrayLikeToArray(o2, minLen);
                var n2 = Object.prototype.toString.call(o2).slice(8, -1);
                return "Object" === n2 && o2.constructor && (n2 = o2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(o2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? _arrayLikeToArray(o2, minLen) : void 0;
            }
        }
        function _arrayLikeToArray(arr, len) {
            (null == len || len > arr.length) && (len = arr.length);
            for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
            return arr2;
        }
        function _iterableToArrayLimit(arr, i2) {
            var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
            if (null != _i) {
                var _s, _e, _arr = [], _n = !0, _d = !1;
                try {
                    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i2 || _arr.length !== i2); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        _n || null == _i.return || _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        function _objectSpread$h(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$h(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$h(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        function _objectWithoutProperties(source, excluded) {
            if (null == source) return {};
            var key2, i2, target = _objectWithoutPropertiesLoose(source, excluded);
            if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) key2 = sourceSymbolKeys[i2], excluded.indexOf(key2) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key2) && (target[key2] = source[key2]);
            }
            return target;
        }
        function _objectWithoutPropertiesLoose(source, excluded) {
            if (null == source) return {};
            var key2, i2, target = {}, sourceKeys = Object.keys(source);
            for (i2 = 0; i2 < sourceKeys.length; i2++) key2 = sourceKeys[i2], excluded.indexOf(key2) >= 0 || (target[key2] = source[key2]);
            return target;
        }
        setTwoToneColor(blue.primary);
        var Icon = function Icon2(props2, context) {
            var _classObj, _props$context$attrs = _objectSpread$h({}, props2, context.attrs), cls = _props$context$attrs.class, icon = _props$context$attrs.icon, spin = _props$context$attrs.spin, rotate = _props$context$attrs.rotate, tabindex = _props$context$attrs.tabindex, twoToneColor = _props$context$attrs.twoToneColor, onClick = _props$context$attrs.onClick, restProps = _objectWithoutProperties(_props$context$attrs, _excluded), _useInjectIconContext = useInjectIconContext(), prefixCls = _useInjectIconContext.prefixCls, rootClassName = _useInjectIconContext.rootClassName, classObj = (_defineProperty$h(_classObj = {}, rootClassName.value, !!rootClassName.value), 
            _defineProperty$h(_classObj, prefixCls.value, !0), _defineProperty$h(_classObj, "".concat(prefixCls.value, "-").concat(icon.name), Boolean(icon.name)), 
            _defineProperty$h(_classObj, "".concat(prefixCls.value, "-spin"), !!spin || "loading" === icon.name), 
            _classObj), iconTabIndex = tabindex;
            void 0 === iconTabIndex && onClick && (iconTabIndex = -1);
            var svgStyle = rotate ? {
                msTransform: "rotate(".concat(rotate, "deg)"),
                transform: "rotate(".concat(rotate, "deg)")
            } : void 0, _normalizeTwoToneColo2 = _slicedToArray(normalizeTwoToneColors(twoToneColor), 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
            return createVNode("span", _objectSpread$h({
                role: "img",
                "aria-label": icon.name
            }, restProps, {
                onClick: onClick,
                class: [ classObj, cls ],
                tabindex: iconTabIndex
            }), [ createVNode(IconBase, {
                icon: icon,
                primaryColor: primaryColor,
                secondaryColor: secondaryColor,
                style: svgStyle
            }, null), createVNode(InsertStyles, null, null) ]);
        };
        function _objectSpread$g(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$g(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$g(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        Icon.props = {
            spin: Boolean,
            rotate: Number,
            icon: Object,
            twoToneColor: [ String, Array ]
        }, Icon.displayName = "AntdIcon", Icon.inheritAttrs = !1, Icon.getTwoToneColor = getTwoToneColor, 
        Icon.setTwoToneColor = setTwoToneColor;
        var DownOutlined = function DownOutlined2(props2, context) {
            var p2 = _objectSpread$g({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$g({}, p2, {
                icon: DownOutlined$1
            }), null);
        };
        DownOutlined.displayName = "DownOutlined", DownOutlined.inheritAttrs = !1;
        var LoadingOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "0 0 1024 1024",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
                    }
                } ]
            },
            name: "loading",
            theme: "outlined"
        };
        function _objectSpread$f(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$f(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$f(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var LoadingOutlined = function LoadingOutlined2(props2, context) {
            var p2 = _objectSpread$f({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$f({}, p2, {
                icon: LoadingOutlined$1
            }), null);
        };
        LoadingOutlined.displayName = "LoadingOutlined", LoadingOutlined.inheritAttrs = !1;
        var CheckOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z"
                    }
                } ]
            },
            name: "check",
            theme: "outlined"
        };
        function _objectSpread$e(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$e(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$e(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var CheckOutlined = function CheckOutlined2(props2, context) {
            var p2 = _objectSpread$e({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$e({}, p2, {
                icon: CheckOutlined$1
            }), null);
        };
        CheckOutlined.displayName = "CheckOutlined", CheckOutlined.inheritAttrs = !1;
        var CloseOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    "fill-rule": "evenodd",
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z"
                    }
                } ]
            },
            name: "close",
            theme: "outlined"
        };
        function _objectSpread$d(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$d(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$d(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var CloseOutlined = function CloseOutlined2(props2, context) {
            var p2 = _objectSpread$d({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$d({}, p2, {
                icon: CloseOutlined$1
            }), null);
        };
        CloseOutlined.displayName = "CloseOutlined", CloseOutlined.inheritAttrs = !1;
        var CloseCircleFilled$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    "fill-rule": "evenodd",
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z"
                    }
                } ]
            },
            name: "close-circle",
            theme: "filled"
        };
        function _objectSpread$c(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$c(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$c(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var CloseCircleFilled = function CloseCircleFilled2(props2, context) {
            var p2 = _objectSpread$c({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$c({}, p2, {
                icon: CloseCircleFilled$1
            }), null);
        };
        CloseCircleFilled.displayName = "CloseCircleFilled", CloseCircleFilled.inheritAttrs = !1;
        var SearchOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"
                    }
                } ]
            },
            name: "search",
            theme: "outlined"
        };
        function _objectSpread$b(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$b(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$b(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var SearchOutlined = function SearchOutlined2(props2, context) {
            var p2 = _objectSpread$b({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$b({}, p2, {
                icon: SearchOutlined$1
            }), null);
        };
        function getIcons(props2) {
            let slots = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const {loading: loading, multiple: multiple, prefixCls: prefixCls, hasFeedback: hasFeedback, feedbackIcon: feedbackIcon, showArrow: showArrow} = props2, suffixIcon = props2.suffixIcon || slots.suffixIcon && slots.suffixIcon(), clearIcon = props2.clearIcon || slots.clearIcon && slots.clearIcon(), menuItemSelectedIcon = props2.menuItemSelectedIcon || slots.menuItemSelectedIcon && slots.menuItemSelectedIcon(), removeIcon = props2.removeIcon || slots.removeIcon && slots.removeIcon(), mergedClearIcon = null != clearIcon ? clearIcon : createVNode(CloseCircleFilled, null, null), getSuffixIconNode = arrowIcon => createVNode(Fragment, null, [ !1 !== showArrow && arrowIcon, hasFeedback && feedbackIcon ]);
            let mergedSuffixIcon = null;
            if (void 0 !== suffixIcon) mergedSuffixIcon = getSuffixIconNode(suffixIcon); else if (loading) mergedSuffixIcon = getSuffixIconNode(createVNode(LoadingOutlined, {
                spin: !0
            }, null)); else {
                const iconCls = `${prefixCls}-suffix`;
                mergedSuffixIcon = _ref => {
                    let {open: open2, showSearch: showSearch} = _ref;
                    return getSuffixIconNode(createVNode(open2 && showSearch ? SearchOutlined : DownOutlined, {
                        class: iconCls
                    }, null));
                };
            }
            let mergedItemIcon = null;
            mergedItemIcon = void 0 !== menuItemSelectedIcon ? menuItemSelectedIcon : multiple ? createVNode(CheckOutlined, null, null) : null;
            let mergedRemoveIcon = null;
            return mergedRemoveIcon = void 0 !== removeIcon ? removeIcon : createVNode(CloseOutlined, null, null), 
            {
                clearIcon: mergedClearIcon,
                suffixIcon: mergedSuffixIcon,
                itemIcon: mergedItemIcon,
                removeIcon: mergedRemoveIcon
            };
        }
        function createContext(defaultValue) {
            const contextKey2 = Symbol("contextKey");
            return {
                useProvide: (props2, newProps) => {
                    const mergedProps = reactive({});
                    return provide(contextKey2, mergedProps), watchEffect((() => {
                        _extends$1(mergedProps, props2, newProps || {});
                    })), mergedProps;
                },
                useInject: () => inject(contextKey2, defaultValue) || {}
            };
        }
        SearchOutlined.displayName = "SearchOutlined", SearchOutlined.inheritAttrs = !1;
        const ContextKey = Symbol("ContextProps"), InternalContextKey = Symbol("InternalContextProps"), useProvideFormItemContext = function(props2) {
            let useValidation = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : computed((() => !0));
            const formItemFields = ref(new Map), addFormItemField = (key2, type) => {
                formItemFields.value.set(key2, type), formItemFields.value = new Map(formItemFields.value);
            }, removeFormItemField = key2 => {
                formItemFields.value.delete(key2), formItemFields.value = new Map(formItemFields.value);
            };
            watch([ useValidation, formItemFields ], (() => {})), provide(ContextKey, props2), 
            provide(InternalContextKey, {
                addFormItemField: addFormItemField,
                removeFormItemField: removeFormItemField
            });
        }, defaultContext = {
            id: computed((() => {})),
            onFieldBlur: () => {},
            onFieldChange: () => {},
            clearValidate: () => {}
        }, defaultInternalContext = {
            addFormItemField: () => {},
            removeFormItemField: () => {}
        }, useInjectFormItemContext = () => {
            const internalContext = inject(InternalContextKey, defaultInternalContext), formItemFieldKey = Symbol("FormItemFieldKey"), instance = getCurrentInstance();
            return internalContext.addFormItemField(formItemFieldKey, instance.type), onBeforeUnmount((() => {
                internalContext.removeFormItemField(formItemFieldKey);
            })), provide(InternalContextKey, defaultInternalContext), provide(ContextKey, defaultContext), 
            inject(ContextKey, defaultContext);
        }, FormItemRest = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "AFormItemRest",
            setup(_2, _ref) {
                let {slots: slots} = _ref;
                return provide(InternalContextKey, defaultInternalContext), provide(ContextKey, defaultContext), 
                () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        }), FormItemInputContext = createContext({});
        function getStatusClassNames(prefixCls, status, hasFeedback) {
            return classNames({
                [`${prefixCls}-status-success`]: "success" === status,
                [`${prefixCls}-status-warning`]: "warning" === status,
                [`${prefixCls}-status-error`]: "error" === status,
                [`${prefixCls}-status-validating`]: "validating" === status,
                [`${prefixCls}-has-feedback`]: hasFeedback
            });
        }
        const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus, genSpaceCompactStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [componentCls]: {
                    display: "inline-flex",
                    "&-block": {
                        display: "flex",
                        width: "100%"
                    },
                    "&-vertical": {
                        flexDirection: "column"
                    }
                }
            };
        }, genSpaceStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [componentCls]: {
                    display: "inline-flex",
                    "&-rtl": {
                        direction: "rtl"
                    },
                    "&-vertical": {
                        flexDirection: "column"
                    },
                    "&-align": {
                        flexDirection: "column",
                        "&-center": {
                            alignItems: "center"
                        },
                        "&-start": {
                            alignItems: "flex-start"
                        },
                        "&-end": {
                            alignItems: "flex-end"
                        },
                        "&-baseline": {
                            alignItems: "baseline"
                        }
                    },
                    [`${componentCls}-item`]: {
                        "&:empty": {
                            display: "none"
                        }
                    }
                }
            };
        }, useStyle$a = genComponentStyleHook("Space", (token2 => [ genSpaceStyle(token2), genSpaceCompactStyle(token2) ])), spaceCompactItemProps = () => ({
            compactSize: String,
            compactDirection: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
            isFirstItem: booleanType(),
            isLastItem: booleanType()
        }), SpaceCompactItemContext = createContext(null), useCompactItemContext = (prefixCls, direction) => {
            const compactItemContext = SpaceCompactItemContext.useInject(), compactItemClassnames = computed((() => {
                if (!compactItemContext || isEmpty(compactItemContext)) return "";
                const {compactDirection: compactDirection, isFirstItem: isFirstItem, isLastItem: isLastItem} = compactItemContext, separator = "vertical" === compactDirection ? "-vertical-" : "-";
                return classNames({
                    [`${prefixCls.value}-compact${separator}item`]: !0,
                    [`${prefixCls.value}-compact${separator}first-item`]: isFirstItem,
                    [`${prefixCls.value}-compact${separator}last-item`]: isLastItem,
                    [`${prefixCls.value}-compact${separator}item-rtl`]: "rtl" === direction.value
                });
            }));
            return {
                compactSize: computed((() => null == compactItemContext ? void 0 : compactItemContext.compactSize)),
                compactDirection: computed((() => null == compactItemContext ? void 0 : compactItemContext.compactDirection)),
                compactItemClassnames: compactItemClassnames
            };
        }, NoCompactStyle = defineComponent({
            name: "NoCompactStyle",
            setup(_2, _ref) {
                let {slots: slots} = _ref;
                return SpaceCompactItemContext.useProvide(null), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        }), spaceCompactProps = () => ({
            prefixCls: String,
            size: {
                type: String
            },
            direction: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
            align: PropTypes.oneOf(tuple("start", "end", "center", "baseline")),
            block: {
                type: Boolean,
                default: void 0
            }
        }), CompactItem = defineComponent({
            name: "CompactItem",
            props: spaceCompactItemProps(),
            setup(props2, _ref2) {
                let {slots: slots} = _ref2;
                return SpaceCompactItemContext.useProvide(props2), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        }), Compact = defineComponent({
            name: "ASpaceCompact",
            inheritAttrs: !1,
            props: spaceCompactProps(),
            setup(props2, _ref3) {
                let {attrs: attrs, slots: slots} = _ref3;
                const {prefixCls: prefixCls, direction: directionConfig} = useConfigInject("space-compact", props2), compactItemContext = SpaceCompactItemContext.useInject(), [wrapSSR, hashId] = useStyle$a(prefixCls), clx = computed((() => classNames(prefixCls.value, hashId.value, {
                    [`${prefixCls.value}-rtl`]: "rtl" === directionConfig.value,
                    [`${prefixCls.value}-block`]: props2.block,
                    [`${prefixCls.value}-vertical`]: "vertical" === props2.direction
                })));
                return () => {
                    var _a;
                    const childNodes = flattenChildren((null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots)) || []);
                    return 0 === childNodes.length ? null : wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: [ clx.value, attrs.class ]
                    }), [ childNodes.map(((child, i2) => {
                        var _a2;
                        const key2 = child && child.key || `${prefixCls.value}-item-${i2}`, noCompactItemContext = !compactItemContext || isEmpty(compactItemContext);
                        return createVNode(CompactItem, {
                            key: key2,
                            compactSize: null !== (_a2 = props2.size) && void 0 !== _a2 ? _a2 : "middle",
                            compactDirection: props2.direction,
                            isFirstItem: 0 === i2 && (noCompactItemContext || (null == compactItemContext ? void 0 : compactItemContext.isFirstItem)),
                            isLastItem: i2 === childNodes.length - 1 && (noCompactItemContext || (null == compactItemContext ? void 0 : compactItemContext.isLastItem))
                        }, {
                            default: () => [ child ]
                        });
                    })) ]));
                };
            }
        }), initMotionCommon = duration => ({
            animationDuration: duration,
            animationFillMode: "both"
        }), initMotionCommonLeave = duration => ({
            animationDuration: duration,
            animationFillMode: "both"
        }), initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
            const sameLevelPrefix = arguments.length > 4 && void 0 !== arguments[4] && arguments[4] ? "&" : "";
            return {
                [`\n      ${sameLevelPrefix}${motionCls}-enter,\n      ${sameLevelPrefix}${motionCls}-appear\n    `]: _extends$1(_extends$1({}, initMotionCommon(duration)), {
                    animationPlayState: "paused"
                }),
                [`${sameLevelPrefix}${motionCls}-leave`]: _extends$1(_extends$1({}, initMotionCommonLeave(duration)), {
                    animationPlayState: "paused"
                }),
                [`\n      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,\n      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active\n    `]: {
                    animationName: inKeyframes,
                    animationPlayState: "running"
                },
                [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
                    animationName: outKeyframes,
                    animationPlayState: "running",
                    pointerEvents: "none"
                }
            };
        }, moveDownIn = new Keyframe("antMoveDownIn", {
            "0%": {
                transform: "translate3d(0, 100%, 0)",
                transformOrigin: "0 0",
                opacity: 0
            },
            "100%": {
                transform: "translate3d(0, 0, 0)",
                transformOrigin: "0 0",
                opacity: 1
            }
        }), moveDownOut = new Keyframe("antMoveDownOut", {
            "0%": {
                transform: "translate3d(0, 0, 0)",
                transformOrigin: "0 0",
                opacity: 1
            },
            "100%": {
                transform: "translate3d(0, 100%, 0)",
                transformOrigin: "0 0",
                opacity: 0
            }
        }), moveLeftIn = new Keyframe("antMoveLeftIn", {
            "0%": {
                transform: "translate3d(-100%, 0, 0)",
                transformOrigin: "0 0",
                opacity: 0
            },
            "100%": {
                transform: "translate3d(0, 0, 0)",
                transformOrigin: "0 0",
                opacity: 1
            }
        }), moveLeftOut = new Keyframe("antMoveLeftOut", {
            "0%": {
                transform: "translate3d(0, 0, 0)",
                transformOrigin: "0 0",
                opacity: 1
            },
            "100%": {
                transform: "translate3d(-100%, 0, 0)",
                transformOrigin: "0 0",
                opacity: 0
            }
        }), moveRightIn = new Keyframe("antMoveRightIn", {
            "0%": {
                transform: "translate3d(100%, 0, 0)",
                transformOrigin: "0 0",
                opacity: 0
            },
            "100%": {
                transform: "translate3d(0, 0, 0)",
                transformOrigin: "0 0",
                opacity: 1
            }
        }), moveRightOut = new Keyframe("antMoveRightOut", {
            "0%": {
                transform: "translate3d(0, 0, 0)",
                transformOrigin: "0 0",
                opacity: 1
            },
            "100%": {
                transform: "translate3d(100%, 0, 0)",
                transformOrigin: "0 0",
                opacity: 0
            }
        }), moveMotion = {
            "move-up": {
                inKeyframes: new Keyframe("antMoveUpIn", {
                    "0%": {
                        transform: "translate3d(0, -100%, 0)",
                        transformOrigin: "0 0",
                        opacity: 0
                    },
                    "100%": {
                        transform: "translate3d(0, 0, 0)",
                        transformOrigin: "0 0",
                        opacity: 1
                    }
                }),
                outKeyframes: new Keyframe("antMoveUpOut", {
                    "0%": {
                        transform: "translate3d(0, 0, 0)",
                        transformOrigin: "0 0",
                        opacity: 1
                    },
                    "100%": {
                        transform: "translate3d(0, -100%, 0)",
                        transformOrigin: "0 0",
                        opacity: 0
                    }
                })
            },
            "move-down": {
                inKeyframes: moveDownIn,
                outKeyframes: moveDownOut
            },
            "move-left": {
                inKeyframes: moveLeftIn,
                outKeyframes: moveLeftOut
            },
            "move-right": {
                inKeyframes: moveRightIn,
                outKeyframes: moveRightOut
            }
        }, initMoveMotion = (token2, motionName) => {
            const {antCls: antCls} = token2, motionCls = `${antCls}-${motionName}`, {inKeyframes: inKeyframes, outKeyframes: outKeyframes} = moveMotion[motionName];
            return [ initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
                [`\n        ${motionCls}-enter,\n        ${motionCls}-appear\n      `]: {
                    opacity: 0,
                    animationTimingFunction: token2.motionEaseOutCirc
                },
                [`${motionCls}-leave`]: {
                    animationTimingFunction: token2.motionEaseInOutCirc
                }
            } ];
        }, slideUpIn = new Keyframe("antSlideUpIn", {
            "0%": {
                transform: "scaleY(0.8)",
                transformOrigin: "0% 0%",
                opacity: 0
            },
            "100%": {
                transform: "scaleY(1)",
                transformOrigin: "0% 0%",
                opacity: 1
            }
        }), slideUpOut = new Keyframe("antSlideUpOut", {
            "0%": {
                transform: "scaleY(1)",
                transformOrigin: "0% 0%",
                opacity: 1
            },
            "100%": {
                transform: "scaleY(0.8)",
                transformOrigin: "0% 0%",
                opacity: 0
            }
        }), slideDownIn = new Keyframe("antSlideDownIn", {
            "0%": {
                transform: "scaleY(0.8)",
                transformOrigin: "100% 100%",
                opacity: 0
            },
            "100%": {
                transform: "scaleY(1)",
                transformOrigin: "100% 100%",
                opacity: 1
            }
        }), slideDownOut = new Keyframe("antSlideDownOut", {
            "0%": {
                transform: "scaleY(1)",
                transformOrigin: "100% 100%",
                opacity: 1
            },
            "100%": {
                transform: "scaleY(0.8)",
                transformOrigin: "100% 100%",
                opacity: 0
            }
        }), slideLeftIn = new Keyframe("antSlideLeftIn", {
            "0%": {
                transform: "scaleX(0.8)",
                transformOrigin: "0% 0%",
                opacity: 0
            },
            "100%": {
                transform: "scaleX(1)",
                transformOrigin: "0% 0%",
                opacity: 1
            }
        }), slideLeftOut = new Keyframe("antSlideLeftOut", {
            "0%": {
                transform: "scaleX(1)",
                transformOrigin: "0% 0%",
                opacity: 1
            },
            "100%": {
                transform: "scaleX(0.8)",
                transformOrigin: "0% 0%",
                opacity: 0
            }
        }), slideRightIn = new Keyframe("antSlideRightIn", {
            "0%": {
                transform: "scaleX(0.8)",
                transformOrigin: "100% 0%",
                opacity: 0
            },
            "100%": {
                transform: "scaleX(1)",
                transformOrigin: "100% 0%",
                opacity: 1
            }
        }), slideRightOut = new Keyframe("antSlideRightOut", {
            "0%": {
                transform: "scaleX(1)",
                transformOrigin: "100% 0%",
                opacity: 1
            },
            "100%": {
                transform: "scaleX(0.8)",
                transformOrigin: "100% 0%",
                opacity: 0
            }
        }), slideMotion = {
            "slide-up": {
                inKeyframes: slideUpIn,
                outKeyframes: slideUpOut
            },
            "slide-down": {
                inKeyframes: slideDownIn,
                outKeyframes: slideDownOut
            },
            "slide-left": {
                inKeyframes: slideLeftIn,
                outKeyframes: slideLeftOut
            },
            "slide-right": {
                inKeyframes: slideRightIn,
                outKeyframes: slideRightOut
            }
        }, initSlideMotion = (token2, motionName) => {
            const {antCls: antCls} = token2, motionCls = `${antCls}-${motionName}`, {inKeyframes: inKeyframes, outKeyframes: outKeyframes} = slideMotion[motionName];
            return [ initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
                [`\n      ${motionCls}-enter,\n      ${motionCls}-appear\n    `]: {
                    transform: "scale(0)",
                    transformOrigin: "0% 0%",
                    opacity: 0,
                    animationTimingFunction: token2.motionEaseOutQuint
                },
                [`${motionCls}-leave`]: {
                    animationTimingFunction: token2.motionEaseInQuint
                }
            } ];
        }, zoomIn = new Keyframe("antZoomIn", {
            "0%": {
                transform: "scale(0.2)",
                opacity: 0
            },
            "100%": {
                transform: "scale(1)",
                opacity: 1
            }
        }), zoomOut = new Keyframe("antZoomOut", {
            "0%": {
                transform: "scale(1)"
            },
            "100%": {
                transform: "scale(0.2)",
                opacity: 0
            }
        }), zoomBigIn = new Keyframe("antZoomBigIn", {
            "0%": {
                transform: "scale(0.8)",
                opacity: 0
            },
            "100%": {
                transform: "scale(1)",
                opacity: 1
            }
        }), zoomBigOut = new Keyframe("antZoomBigOut", {
            "0%": {
                transform: "scale(1)"
            },
            "100%": {
                transform: "scale(0.8)",
                opacity: 0
            }
        }), zoomUpIn = new Keyframe("antZoomUpIn", {
            "0%": {
                transform: "scale(0.8)",
                transformOrigin: "50% 0%",
                opacity: 0
            },
            "100%": {
                transform: "scale(1)",
                transformOrigin: "50% 0%"
            }
        }), zoomUpOut = new Keyframe("antZoomUpOut", {
            "0%": {
                transform: "scale(1)",
                transformOrigin: "50% 0%"
            },
            "100%": {
                transform: "scale(0.8)",
                transformOrigin: "50% 0%",
                opacity: 0
            }
        }), zoomLeftIn = new Keyframe("antZoomLeftIn", {
            "0%": {
                transform: "scale(0.8)",
                transformOrigin: "0% 50%",
                opacity: 0
            },
            "100%": {
                transform: "scale(1)",
                transformOrigin: "0% 50%"
            }
        }), zoomLeftOut = new Keyframe("antZoomLeftOut", {
            "0%": {
                transform: "scale(1)",
                transformOrigin: "0% 50%"
            },
            "100%": {
                transform: "scale(0.8)",
                transformOrigin: "0% 50%",
                opacity: 0
            }
        }), zoomRightIn = new Keyframe("antZoomRightIn", {
            "0%": {
                transform: "scale(0.8)",
                transformOrigin: "100% 50%",
                opacity: 0
            },
            "100%": {
                transform: "scale(1)",
                transformOrigin: "100% 50%"
            }
        }), zoomRightOut = new Keyframe("antZoomRightOut", {
            "0%": {
                transform: "scale(1)",
                transformOrigin: "100% 50%"
            },
            "100%": {
                transform: "scale(0.8)",
                transformOrigin: "100% 50%",
                opacity: 0
            }
        }), zoomDownIn = new Keyframe("antZoomDownIn", {
            "0%": {
                transform: "scale(0.8)",
                transformOrigin: "50% 100%",
                opacity: 0
            },
            "100%": {
                transform: "scale(1)",
                transformOrigin: "50% 100%"
            }
        }), zoomDownOut = new Keyframe("antZoomDownOut", {
            "0%": {
                transform: "scale(1)",
                transformOrigin: "50% 100%"
            },
            "100%": {
                transform: "scale(0.8)",
                transformOrigin: "50% 100%",
                opacity: 0
            }
        }), zoomMotion = {
            zoom: {
                inKeyframes: zoomIn,
                outKeyframes: zoomOut
            },
            "zoom-big": {
                inKeyframes: zoomBigIn,
                outKeyframes: zoomBigOut
            },
            "zoom-big-fast": {
                inKeyframes: zoomBigIn,
                outKeyframes: zoomBigOut
            },
            "zoom-left": {
                inKeyframes: zoomLeftIn,
                outKeyframes: zoomLeftOut
            },
            "zoom-right": {
                inKeyframes: zoomRightIn,
                outKeyframes: zoomRightOut
            },
            "zoom-up": {
                inKeyframes: zoomUpIn,
                outKeyframes: zoomUpOut
            },
            "zoom-down": {
                inKeyframes: zoomDownIn,
                outKeyframes: zoomDownOut
            }
        }, initZoomMotion = (token2, motionName) => {
            const {antCls: antCls} = token2, motionCls = `${antCls}-${motionName}`, {inKeyframes: inKeyframes, outKeyframes: outKeyframes} = zoomMotion[motionName];
            return [ initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationFast), {
                [`\n        ${motionCls}-enter,\n        ${motionCls}-appear\n      `]: {
                    transform: "scale(0)",
                    opacity: 0,
                    animationTimingFunction: token2.motionEaseOutCirc,
                    "&-prepare": {
                        transform: "none"
                    }
                },
                [`${motionCls}-leave`]: {
                    animationTimingFunction: token2.motionEaseInOutCirc
                }
            } ];
        }, genCollapseMotion = token2 => ({
            [token2.componentCls]: {
                [`${token2.antCls}-motion-collapse-legacy`]: {
                    overflow: "hidden",
                    "&-active": {
                        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},\n        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
                    }
                },
                [`${token2.antCls}-motion-collapse`]: {
                    overflow: "hidden",
                    transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},\n        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
                }
            }
        }), genItemStyle = token2 => {
            const {controlPaddingHorizontal: controlPaddingHorizontal} = token2;
            return {
                position: "relative",
                display: "block",
                minHeight: token2.controlHeight,
                padding: `${(token2.controlHeight - token2.fontSize * token2.lineHeight) / 2}px ${controlPaddingHorizontal}px`,
                color: token2.colorText,
                fontWeight: "normal",
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight,
                boxSizing: "border-box"
            };
        }, genSingleStyle$1 = token2 => {
            const {antCls: antCls, componentCls: componentCls} = token2, selectItemCls = `${componentCls}-item`;
            return [ {
                [`${componentCls}-dropdown`]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    position: "absolute",
                    top: -9999,
                    zIndex: token2.zIndexPopup,
                    boxSizing: "border-box",
                    padding: token2.paddingXXS,
                    overflow: "hidden",
                    fontSize: token2.fontSize,
                    fontVariant: "initial",
                    backgroundColor: token2.colorBgElevated,
                    borderRadius: token2.borderRadiusLG,
                    outline: "none",
                    boxShadow: token2.boxShadowSecondary,
                    [`\n            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,\n            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft\n          `]: {
                        animationName: slideUpIn
                    },
                    [`\n            &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,\n            &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft\n          `]: {
                        animationName: slideDownIn
                    },
                    [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft`]: {
                        animationName: slideUpOut
                    },
                    [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft`]: {
                        animationName: slideDownOut
                    },
                    "&-hidden": {
                        display: "none"
                    },
                    "&-empty": {
                        color: token2.colorTextDisabled
                    },
                    [`${selectItemCls}-empty`]: _extends$1(_extends$1({}, genItemStyle(token2)), {
                        color: token2.colorTextDisabled
                    }),
                    [`${selectItemCls}`]: _extends$1(_extends$1({}, genItemStyle(token2)), {
                        cursor: "pointer",
                        transition: `background ${token2.motionDurationSlow} ease`,
                        borderRadius: token2.borderRadiusSM,
                        "&-group": {
                            color: token2.colorTextDescription,
                            fontSize: token2.fontSizeSM,
                            cursor: "default"
                        },
                        "&-option": {
                            display: "flex",
                            "&-content": _extends$1({
                                flex: "auto"
                            }, textEllipsis),
                            "&-state": {
                                flex: "none"
                            },
                            [`&-active:not(${selectItemCls}-option-disabled)`]: {
                                backgroundColor: token2.controlItemBgHover
                            },
                            [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                                color: token2.colorText,
                                fontWeight: token2.fontWeightStrong,
                                backgroundColor: token2.controlItemBgActive,
                                [`${selectItemCls}-option-state`]: {
                                    color: token2.colorPrimary
                                }
                            },
                            "&-disabled": {
                                [`&${selectItemCls}-option-selected`]: {
                                    backgroundColor: token2.colorBgContainerDisabled
                                },
                                color: token2.colorTextDisabled,
                                cursor: "not-allowed"
                            },
                            "&-grouped": {
                                paddingInlineStart: 2 * token2.controlPaddingHorizontal
                            }
                        }
                    }),
                    "&-rtl": {
                        direction: "rtl"
                    }
                })
            }, initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down") ];
        }, FIXED_ITEM_MARGIN = 2;
        function getSelectItemStyle(_ref) {
            let {controlHeightSM: controlHeightSM, controlHeight: controlHeight, lineWidth: borderWidth} = _ref;
            const selectItemDist = (controlHeight - controlHeightSM) / 2 - borderWidth;
            return [ selectItemDist, Math.ceil(selectItemDist / 2) ];
        }
        function genSizeStyle$1(token2, suffix) {
            const {componentCls: componentCls, iconCls: iconCls} = token2, selectOverflowPrefixCls = `${componentCls}-selection-overflow`, selectItemHeight = token2.controlHeightSM, [selectItemDist] = getSelectItemStyle(token2), suffixCls = suffix ? `${componentCls}-${suffix}` : "";
            return {
                [`${componentCls}-multiple${suffixCls}`]: {
                    fontSize: token2.fontSize,
                    [selectOverflowPrefixCls]: {
                        position: "relative",
                        display: "flex",
                        flex: "auto",
                        flexWrap: "wrap",
                        maxWidth: "100%",
                        "&-item": {
                            flex: "none",
                            alignSelf: "center",
                            maxWidth: "100%",
                            display: "inline-flex"
                        }
                    },
                    [`${componentCls}-selector`]: {
                        display: "flex",
                        flexWrap: "wrap",
                        alignItems: "center",
                        padding: `${selectItemDist - FIXED_ITEM_MARGIN}px ${2 * FIXED_ITEM_MARGIN}px`,
                        borderRadius: token2.borderRadius,
                        [`${componentCls}-show-search&`]: {
                            cursor: "text"
                        },
                        [`${componentCls}-disabled&`]: {
                            background: token2.colorBgContainerDisabled,
                            cursor: "not-allowed"
                        },
                        "&:after": {
                            display: "inline-block",
                            width: 0,
                            margin: `${FIXED_ITEM_MARGIN}px 0`,
                            lineHeight: `${selectItemHeight}px`,
                            content: '"\\a0"'
                        }
                    },
                    [`\n        &${componentCls}-show-arrow ${componentCls}-selector,\n        &${componentCls}-allow-clear ${componentCls}-selector\n      `]: {
                        paddingInlineEnd: token2.fontSizeIcon + token2.controlPaddingHorizontal
                    },
                    [`${componentCls}-selection-item`]: {
                        position: "relative",
                        display: "flex",
                        flex: "none",
                        boxSizing: "border-box",
                        maxWidth: "100%",
                        height: selectItemHeight,
                        marginTop: FIXED_ITEM_MARGIN,
                        marginBottom: FIXED_ITEM_MARGIN,
                        lineHeight: selectItemHeight - 2 * token2.lineWidth + "px",
                        background: token2.colorFillSecondary,
                        border: `${token2.lineWidth}px solid ${token2.colorSplit}`,
                        borderRadius: token2.borderRadiusSM,
                        cursor: "default",
                        transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
                        userSelect: "none",
                        marginInlineEnd: 2 * FIXED_ITEM_MARGIN,
                        paddingInlineStart: token2.paddingXS,
                        paddingInlineEnd: token2.paddingXS / 2,
                        [`${componentCls}-disabled&`]: {
                            color: token2.colorTextDisabled,
                            borderColor: token2.colorBorder,
                            cursor: "not-allowed"
                        },
                        "&-content": {
                            display: "inline-block",
                            marginInlineEnd: token2.paddingXS / 2,
                            overflow: "hidden",
                            whiteSpace: "pre",
                            textOverflow: "ellipsis"
                        },
                        "&-remove": _extends$1(_extends$1({}, resetIcon()), {
                            display: "inline-block",
                            color: token2.colorIcon,
                            fontWeight: "bold",
                            fontSize: 10,
                            lineHeight: "inherit",
                            cursor: "pointer",
                            [`> ${iconCls}`]: {
                                verticalAlign: "-0.2em"
                            },
                            "&:hover": {
                                color: token2.colorIconHover
                            }
                        })
                    },
                    [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
                        [`${componentCls}-selection-search`]: {
                            marginInlineStart: 0
                        }
                    },
                    [`${componentCls}-selection-search`]: {
                        display: "inline-flex",
                        position: "relative",
                        maxWidth: "100%",
                        marginInlineStart: token2.inputPaddingHorizontalBase - selectItemDist,
                        "\n          &-input,\n          &-mirror\n        ": {
                            height: selectItemHeight,
                            fontFamily: token2.fontFamily,
                            lineHeight: `${selectItemHeight}px`,
                            transition: `all ${token2.motionDurationSlow}`
                        },
                        "&-input": {
                            width: "100%",
                            minWidth: 4.1
                        },
                        "&-mirror": {
                            position: "absolute",
                            top: 0,
                            insetInlineStart: 0,
                            insetInlineEnd: "auto",
                            zIndex: 999,
                            whiteSpace: "pre",
                            visibility: "hidden"
                        }
                    },
                    [`${componentCls}-selection-placeholder `]: {
                        position: "absolute",
                        top: "50%",
                        insetInlineStart: token2.inputPaddingHorizontalBase,
                        insetInlineEnd: token2.inputPaddingHorizontalBase,
                        transform: "translateY(-50%)",
                        transition: `all ${token2.motionDurationSlow}`
                    }
                }
            };
        }
        function genMultipleStyle(token2) {
            const {componentCls: componentCls} = token2, smallToken = merge(token2, {
                controlHeight: token2.controlHeightSM,
                controlHeightSM: token2.controlHeightXS,
                borderRadius: token2.borderRadiusSM,
                borderRadiusSM: token2.borderRadiusXS
            }), [, smSelectItemMargin] = getSelectItemStyle(token2);
            return [ genSizeStyle$1(token2), genSizeStyle$1(smallToken, "sm"), {
                [`${componentCls}-multiple${componentCls}-sm`]: {
                    [`${componentCls}-selection-placeholder`]: {
                        insetInlineStart: token2.controlPaddingHorizontalSM - token2.lineWidth,
                        insetInlineEnd: "auto"
                    },
                    [`${componentCls}-selection-search`]: {
                        marginInlineStart: smSelectItemMargin
                    }
                }
            }, genSizeStyle$1(merge(token2, {
                fontSize: token2.fontSizeLG,
                controlHeight: token2.controlHeightLG,
                controlHeightSM: token2.controlHeight,
                borderRadius: token2.borderRadiusLG,
                borderRadiusSM: token2.borderRadius
            }), "lg") ];
        }
        function genSizeStyle(token2, suffix) {
            const {componentCls: componentCls, inputPaddingHorizontalBase: inputPaddingHorizontalBase, borderRadius: borderRadius} = token2, selectHeightWithoutBorder = token2.controlHeight - 2 * token2.lineWidth, selectionItemPadding = Math.ceil(1.25 * token2.fontSize), suffixCls = suffix ? `${componentCls}-${suffix}` : "";
            return {
                [`${componentCls}-single${suffixCls}`]: {
                    fontSize: token2.fontSize,
                    [`${componentCls}-selector`]: _extends$1(_extends$1({}, resetComponent(token2)), {
                        display: "flex",
                        borderRadius: borderRadius,
                        [`${componentCls}-selection-search`]: {
                            position: "absolute",
                            top: 0,
                            insetInlineStart: inputPaddingHorizontalBase,
                            insetInlineEnd: inputPaddingHorizontalBase,
                            bottom: 0,
                            "&-input": {
                                width: "100%"
                            }
                        },
                        [`\n          ${componentCls}-selection-item,\n          ${componentCls}-selection-placeholder\n        `]: {
                            padding: 0,
                            lineHeight: `${selectHeightWithoutBorder}px`,
                            transition: `all ${token2.motionDurationSlow}`,
                            "@supports (-moz-appearance: meterbar)": {
                                lineHeight: `${selectHeightWithoutBorder}px`
                            }
                        },
                        [`${componentCls}-selection-item`]: {
                            position: "relative",
                            userSelect: "none"
                        },
                        [`${componentCls}-selection-placeholder`]: {
                            transition: "none",
                            pointerEvents: "none"
                        },
                        [[ "&:after", `${componentCls}-selection-item:after`, `${componentCls}-selection-placeholder:after` ].join(",")]: {
                            display: "inline-block",
                            width: 0,
                            visibility: "hidden",
                            content: '"\\a0"'
                        }
                    }),
                    [`\n        &${componentCls}-show-arrow ${componentCls}-selection-item,\n        &${componentCls}-show-arrow ${componentCls}-selection-placeholder\n      `]: {
                        paddingInlineEnd: selectionItemPadding
                    },
                    [`&${componentCls}-open ${componentCls}-selection-item`]: {
                        color: token2.colorTextPlaceholder
                    },
                    [`&:not(${componentCls}-customize-input)`]: {
                        [`${componentCls}-selector`]: {
                            width: "100%",
                            height: token2.controlHeight,
                            padding: `0 ${inputPaddingHorizontalBase}px`,
                            [`${componentCls}-selection-search-input`]: {
                                height: selectHeightWithoutBorder
                            },
                            "&:after": {
                                lineHeight: `${selectHeightWithoutBorder}px`
                            }
                        }
                    },
                    [`&${componentCls}-customize-input`]: {
                        [`${componentCls}-selector`]: {
                            "&:after": {
                                display: "none"
                            },
                            [`${componentCls}-selection-search`]: {
                                position: "static",
                                width: "100%"
                            },
                            [`${componentCls}-selection-placeholder`]: {
                                position: "absolute",
                                insetInlineStart: 0,
                                insetInlineEnd: 0,
                                padding: `0 ${inputPaddingHorizontalBase}px`,
                                "&:after": {
                                    display: "none"
                                }
                            }
                        }
                    }
                }
            };
        }
        function genSingleStyle(token2) {
            const {componentCls: componentCls} = token2, inputPaddingHorizontalSM = token2.controlPaddingHorizontalSM - token2.lineWidth;
            return [ genSizeStyle(token2), genSizeStyle(merge(token2, {
                controlHeight: token2.controlHeightSM,
                borderRadius: token2.borderRadiusSM
            }), "sm"), {
                [`${componentCls}-single${componentCls}-sm`]: {
                    [`&:not(${componentCls}-customize-input)`]: {
                        [`${componentCls}-selection-search`]: {
                            insetInlineStart: inputPaddingHorizontalSM,
                            insetInlineEnd: inputPaddingHorizontalSM
                        },
                        [`${componentCls}-selector`]: {
                            padding: `0 ${inputPaddingHorizontalSM}px`
                        },
                        [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
                            insetInlineEnd: inputPaddingHorizontalSM + 1.5 * token2.fontSize
                        },
                        [`\n            &${componentCls}-show-arrow ${componentCls}-selection-item,\n            &${componentCls}-show-arrow ${componentCls}-selection-placeholder\n          `]: {
                            paddingInlineEnd: 1.5 * token2.fontSize
                        }
                    }
                }
            }, genSizeStyle(merge(token2, {
                controlHeight: token2.controlHeightLG,
                fontSize: token2.fontSizeLG,
                borderRadius: token2.borderRadiusLG
            }), "lg") ];
        }
        function compactItemBorder(token2, parentCls, options) {
            const {focusElCls: focusElCls, focus: focus, borderElCls: borderElCls} = options, childCombinator = borderElCls ? "> *" : "", hoverEffects = [ "hover", focus ? "focus" : null, "active" ].filter(Boolean).map((n2 => `&:${n2} ${childCombinator}`)).join(",");
            return {
                [`&-item:not(${parentCls}-last-item)`]: {
                    marginInlineEnd: -token2.lineWidth
                },
                "&-item": _extends$1(_extends$1({
                    [hoverEffects]: {
                        zIndex: 2
                    }
                }, focusElCls ? {
                    [`&${focusElCls}`]: {
                        zIndex: 2
                    }
                } : {}), {
                    [`&[disabled] ${childCombinator}`]: {
                        zIndex: 0
                    }
                })
            };
        }
        function compactItemBorderRadius(prefixCls, parentCls, options) {
            const {borderElCls: borderElCls} = options, childCombinator = borderElCls ? `> ${borderElCls}` : "";
            return {
                [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
                    borderRadius: 0
                },
                [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
                    [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
                        borderStartEndRadius: 0,
                        borderEndEndRadius: 0
                    }
                },
                [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
                    [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
                        borderStartStartRadius: 0,
                        borderEndStartRadius: 0
                    }
                }
            };
        }
        function genCompactItemStyle(token2) {
            let options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                focus: !0
            };
            const {componentCls: componentCls} = token2, compactCls = `${componentCls}-compact`;
            return {
                [compactCls]: _extends$1(_extends$1({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
            };
        }
        const genSelectorStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                position: "relative",
                backgroundColor: token2.colorBgContainer,
                border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
                transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
                input: {
                    cursor: "pointer"
                },
                [`${componentCls}-show-search&`]: {
                    cursor: "text",
                    input: {
                        cursor: "auto",
                        color: "inherit"
                    }
                },
                [`${componentCls}-disabled&`]: {
                    color: token2.colorTextDisabled,
                    background: token2.colorBgContainerDisabled,
                    cursor: "not-allowed",
                    [`${componentCls}-multiple&`]: {
                        background: token2.colorBgContainerDisabled
                    },
                    input: {
                        cursor: "not-allowed"
                    }
                }
            };
        }, genStatusStyle = function(rootSelectCls, token2) {
            let overwriteDefaultBorder = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            const {componentCls: componentCls, borderHoverColor: borderHoverColor, outlineColor: outlineColor, antCls: antCls} = token2, overwriteStyle = overwriteDefaultBorder ? {
                [`${componentCls}-selector`]: {
                    borderColor: borderHoverColor
                }
            } : {};
            return {
                [rootSelectCls]: {
                    [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: _extends$1(_extends$1({}, overwriteStyle), {
                        [`${componentCls}-focused& ${componentCls}-selector`]: {
                            borderColor: borderHoverColor,
                            boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${outlineColor}`,
                            borderInlineEndWidth: `${token2.controlLineWidth}px !important`,
                            outline: 0
                        },
                        [`&:hover ${componentCls}-selector`]: {
                            borderColor: borderHoverColor,
                            borderInlineEndWidth: `${token2.controlLineWidth}px !important`
                        }
                    })
                }
            };
        }, getSearchInputWithoutBorderStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [`${componentCls}-selection-search-input`]: {
                    margin: 0,
                    padding: 0,
                    background: "transparent",
                    border: "none",
                    outline: "none",
                    appearance: "none",
                    "&::-webkit-search-cancel-button": {
                        display: "none",
                        "-webkit-appearance": "none"
                    }
                }
            };
        }, genBaseStyle$1 = token2 => {
            const {componentCls: componentCls, inputPaddingHorizontalBase: inputPaddingHorizontalBase, iconCls: iconCls} = token2;
            return {
                [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    position: "relative",
                    display: "inline-block",
                    cursor: "pointer",
                    [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: _extends$1(_extends$1({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
                    [`${componentCls}-selection-item`]: _extends$1({
                        flex: 1,
                        fontWeight: "normal"
                    }, textEllipsis),
                    [`${componentCls}-selection-placeholder`]: _extends$1(_extends$1({}, textEllipsis), {
                        flex: 1,
                        color: token2.colorTextPlaceholder,
                        pointerEvents: "none"
                    }),
                    [`${componentCls}-arrow`]: _extends$1(_extends$1({}, resetIcon()), {
                        position: "absolute",
                        top: "50%",
                        insetInlineStart: "auto",
                        insetInlineEnd: inputPaddingHorizontalBase,
                        height: token2.fontSizeIcon,
                        marginTop: -token2.fontSizeIcon / 2,
                        color: token2.colorTextQuaternary,
                        fontSize: token2.fontSizeIcon,
                        lineHeight: 1,
                        textAlign: "center",
                        pointerEvents: "none",
                        display: "flex",
                        alignItems: "center",
                        [iconCls]: {
                            verticalAlign: "top",
                            transition: `transform ${token2.motionDurationSlow}`,
                            "> svg": {
                                verticalAlign: "top"
                            },
                            [`&:not(${componentCls}-suffix)`]: {
                                pointerEvents: "auto"
                            }
                        },
                        [`${componentCls}-disabled &`]: {
                            cursor: "not-allowed"
                        },
                        "> *:not(:last-child)": {
                            marginInlineEnd: 8
                        }
                    }),
                    [`${componentCls}-clear`]: {
                        position: "absolute",
                        top: "50%",
                        insetInlineStart: "auto",
                        insetInlineEnd: inputPaddingHorizontalBase,
                        zIndex: 1,
                        display: "inline-block",
                        width: token2.fontSizeIcon,
                        height: token2.fontSizeIcon,
                        marginTop: -token2.fontSizeIcon / 2,
                        color: token2.colorTextQuaternary,
                        fontSize: token2.fontSizeIcon,
                        fontStyle: "normal",
                        lineHeight: 1,
                        textAlign: "center",
                        textTransform: "none",
                        background: token2.colorBgContainer,
                        cursor: "pointer",
                        opacity: 0,
                        transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
                        textRendering: "auto",
                        "&:before": {
                            display: "block"
                        },
                        "&:hover": {
                            color: token2.colorTextTertiary
                        }
                    },
                    "&:hover": {
                        [`${componentCls}-clear`]: {
                            opacity: 1
                        }
                    }
                }),
                [`${componentCls}-has-feedback`]: {
                    [`${componentCls}-clear`]: {
                        insetInlineEnd: inputPaddingHorizontalBase + token2.fontSize + token2.paddingXXS
                    }
                }
            };
        }, genSelectStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return [ {
                [componentCls]: {
                    [`&-borderless ${componentCls}-selector`]: {
                        backgroundColor: "transparent !important",
                        borderColor: "transparent !important",
                        boxShadow: "none !important"
                    },
                    [`&${componentCls}-in-form-item`]: {
                        width: "100%"
                    }
                }
            }, genBaseStyle$1(token2), genSingleStyle(token2), genMultipleStyle(token2), genSingleStyle$1(token2), {
                [`${componentCls}-rtl`]: {
                    direction: "rtl"
                }
            }, genStatusStyle(componentCls, merge(token2, {
                borderHoverColor: token2.colorPrimaryHover,
                outlineColor: token2.controlOutline
            })), genStatusStyle(`${componentCls}-status-error`, merge(token2, {
                borderHoverColor: token2.colorErrorHover,
                outlineColor: token2.colorErrorOutline
            }), !0), genStatusStyle(`${componentCls}-status-warning`, merge(token2, {
                borderHoverColor: token2.colorWarningHover,
                outlineColor: token2.colorWarningOutline
            }), !0), genCompactItemStyle(token2, {
                borderElCls: `${componentCls}-selector`,
                focusElCls: `${componentCls}-focused`
            }) ];
        }, useSelectStyle = genComponentStyleHook("Select", ((token2, _ref) => {
            let {rootPrefixCls: rootPrefixCls} = _ref;
            const selectToken = merge(token2, {
                rootPrefixCls: rootPrefixCls,
                inputPaddingHorizontalBase: token2.paddingSM - 1
            });
            return [ genSelectStyle(selectToken) ];
        }), (token2 => ({
            zIndexPopup: token2.zIndexPopupBase + 50
        }))), SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE", Select = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ASelect",
            Option: Option,
            OptGroup: OptGroup,
            inheritAttrs: !1,
            props: initDefaultProps((() => _extends$1(_extends$1({}, omit(selectProps$1(), [ "inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill" ])), {
                value: someType([ Array, Object, String, Number ]),
                defaultValue: someType([ Array, Object, String, Number ]),
                notFoundContent: PropTypes.any,
                suffixIcon: PropTypes.any,
                itemIcon: PropTypes.any,
                size: stringType(),
                mode: stringType(),
                bordered: booleanType(!0),
                transitionName: String,
                choiceTransitionName: stringType(""),
                popupClassName: String,
                dropdownClassName: String,
                placement: stringType(),
                status: stringType(),
                "onUpdate:value": functionType()
            }))(), {
                listHeight: 256,
                listItemHeight: 24
            }),
            SECRET_COMBOBOX_MODE_DO_NOT_USE: SECRET_COMBOBOX_MODE_DO_NOT_USE,
            slots: Object,
            setup(props2, _ref) {
                let {attrs: attrs, emit: emit2, slots: slots, expose: expose} = _ref;
                const selectRef = ref(), formItemContext = useInjectFormItemContext(), formItemInputContext = FormItemInputContext.useInject(), mergedStatus = computed((() => getMergedStatus(formItemInputContext.status, props2.status))), focus = () => {
                    var _a;
                    null === (_a = selectRef.value) || void 0 === _a || _a.focus();
                }, blur = () => {
                    var _a;
                    null === (_a = selectRef.value) || void 0 === _a || _a.blur();
                }, scrollTo = arg => {
                    var _a;
                    null === (_a = selectRef.value) || void 0 === _a || _a.scrollTo(arg);
                }, mode = computed((() => {
                    const {mode: mode2} = props2;
                    if ("combobox" !== mode2) return mode2 === SECRET_COMBOBOX_MODE_DO_NOT_USE ? "combobox" : mode2;
                })), {prefixCls: prefixCls, direction: direction, configProvider: configProvider, renderEmpty: renderEmpty2, size: contextSize, getPrefixCls: getPrefixCls, getPopupContainer: getPopupContainer, disabled: disabled, select: select} = useConfigInject("select", props2), {compactSize: compactSize, compactItemClassnames: compactItemClassnames} = useCompactItemContext(prefixCls, direction), mergedSize = computed((() => compactSize.value || contextSize.value)), contextDisabled = useInjectDisabled(), mergedDisabled = computed((() => {
                    var _a;
                    return null !== (_a = disabled.value) && void 0 !== _a ? _a : contextDisabled.value;
                })), [wrapSSR, hashId] = useSelectStyle(prefixCls), rootPrefixCls = computed((() => getPrefixCls())), placement = computed((() => void 0 !== props2.placement ? props2.placement : "rtl" === direction.value ? "bottomRight" : "bottomLeft")), transitionName2 = computed((() => getTransitionName(rootPrefixCls.value, getTransitionDirection(placement.value), props2.transitionName))), mergedClassName = computed((() => classNames({
                    [`${prefixCls.value}-lg`]: "large" === mergedSize.value,
                    [`${prefixCls.value}-sm`]: "small" === mergedSize.value,
                    [`${prefixCls.value}-rtl`]: "rtl" === direction.value,
                    [`${prefixCls.value}-borderless`]: !props2.bordered,
                    [`${prefixCls.value}-in-form-item`]: formItemInputContext.isFormItemInput
                }, getStatusClassNames(prefixCls.value, mergedStatus.value, formItemInputContext.hasFeedback), compactItemClassnames.value, hashId.value))), triggerChange = function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    emit2("update:value", args[0]), emit2("change", ...args), formItemContext.onFieldChange();
                }, handleBlur = e2 => {
                    emit2("blur", e2), formItemContext.onFieldBlur();
                };
                expose({
                    blur: blur,
                    focus: focus,
                    scrollTo: scrollTo
                });
                const isMultiple2 = computed((() => "multiple" === mode.value || "tags" === mode.value)), mergedShowArrow = computed((() => void 0 !== props2.showArrow ? props2.showArrow : props2.loading || !(isMultiple2.value || "combobox" === mode.value)));
                return () => {
                    var _a, _b, _c, _d;
                    const {notFoundContent: notFoundContent, listHeight: listHeight = 256, listItemHeight: listItemHeight = 24, popupClassName: popupClassName, dropdownClassName: dropdownClassName, virtual: virtual, dropdownMatchSelectWidth: dropdownMatchSelectWidth, id: id = formItemContext.id.value, placeholder: placeholder = (null === (_a = slots.placeholder) || void 0 === _a ? void 0 : _a.call(slots)), showArrow: showArrow} = props2, {hasFeedback: hasFeedback, feedbackIcon: feedbackIcon} = formItemInputContext;
                    let mergedNotFound;
                    mergedNotFound = void 0 !== notFoundContent ? notFoundContent : slots.notFoundContent ? slots.notFoundContent() : "combobox" === mode.value ? null : (null == renderEmpty2 ? void 0 : renderEmpty2("Select")) || createVNode(DefaultRenderEmpty, {
                        componentName: "Select"
                    }, null);
                    const {suffixIcon: suffixIcon, itemIcon: itemIcon, removeIcon: removeIcon, clearIcon: clearIcon} = getIcons(_extends$1(_extends$1({}, props2), {
                        multiple: isMultiple2.value,
                        prefixCls: prefixCls.value,
                        hasFeedback: hasFeedback,
                        feedbackIcon: feedbackIcon,
                        showArrow: mergedShowArrow.value
                    }), slots), selectProps2 = omit(props2, [ "prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status" ]), rcSelectRtlDropdownClassName = classNames(popupClassName || dropdownClassName, {
                        [`${prefixCls.value}-dropdown-${direction.value}`]: "rtl" === direction.value
                    }, hashId.value);
                    return wrapSSR(createVNode(Select$1, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                        ref: selectRef,
                        virtual: virtual,
                        dropdownMatchSelectWidth: dropdownMatchSelectWidth
                    }, selectProps2), attrs), {}, {
                        showSearch: null !== (_b = props2.showSearch) && void 0 !== _b ? _b : null === (_c = null == select ? void 0 : select.value) || void 0 === _c ? void 0 : _c.showSearch,
                        placeholder: placeholder,
                        listHeight: listHeight,
                        listItemHeight: listItemHeight,
                        mode: mode.value,
                        prefixCls: prefixCls.value,
                        direction: direction.value,
                        inputIcon: suffixIcon,
                        menuItemSelectedIcon: itemIcon,
                        removeIcon: removeIcon,
                        clearIcon: clearIcon,
                        notFoundContent: mergedNotFound,
                        class: [ mergedClassName.value, attrs.class ],
                        getPopupContainer: null == getPopupContainer ? void 0 : getPopupContainer.value,
                        dropdownClassName: rcSelectRtlDropdownClassName,
                        onChange: triggerChange,
                        onBlur: handleBlur,
                        id: id,
                        dropdownRender: selectProps2.dropdownRender || slots.dropdownRender,
                        transitionName: transitionName2.value,
                        children: null === (_d = slots.default) || void 0 === _d ? void 0 : _d.call(slots),
                        tagRender: props2.tagRender || slots.tagRender,
                        optionLabelRender: slots.optionLabel,
                        maxTagPlaceholder: props2.maxTagPlaceholder || slots.maxTagPlaceholder,
                        showArrow: hasFeedback || showArrow,
                        disabled: mergedDisabled.value
                    }), {
                        option: slots.option
                    }));
                };
            }
        });
        Select.install = function(app) {
            return app.component(Select.name, Select), app.component(Select.Option.displayName, Select.Option), 
            app.component(Select.OptGroup.displayName, Select.OptGroup), app;
        }, Select.Option, Select.OptGroup;
        var CheckCircleOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z"
                    }
                }, {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                    }
                } ]
            },
            name: "check-circle",
            theme: "outlined"
        };
        function _objectSpread$a(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$a(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$a(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var CheckCircleOutlined = function CheckCircleOutlined2(props2, context) {
            var p2 = _objectSpread$a({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$a({}, p2, {
                icon: CheckCircleOutlined$1
            }), null);
        };
        CheckCircleOutlined.displayName = "CheckCircleOutlined", CheckCircleOutlined.inheritAttrs = !1;
        var ExclamationCircleOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                    }
                }, {
                    tag: "path",
                    attrs: {
                        d: "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z"
                    }
                } ]
            },
            name: "exclamation-circle",
            theme: "outlined"
        };
        function _objectSpread$9(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$9(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$9(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props2, context) {
            var p2 = _objectSpread$9({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$9({}, p2, {
                icon: ExclamationCircleOutlined$1
            }), null);
        };
        ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined", ExclamationCircleOutlined.inheritAttrs = !1;
        var InfoCircleOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                    }
                }, {
                    tag: "path",
                    attrs: {
                        d: "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z"
                    }
                } ]
            },
            name: "info-circle",
            theme: "outlined"
        };
        function _objectSpread$8(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$8(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$8(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var InfoCircleOutlined = function InfoCircleOutlined2(props2, context) {
            var p2 = _objectSpread$8({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$8({}, p2, {
                icon: InfoCircleOutlined$1
            }), null);
        };
        InfoCircleOutlined.displayName = "InfoCircleOutlined", InfoCircleOutlined.inheritAttrs = !1;
        var CloseCircleOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    "fill-rule": "evenodd",
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z"
                    }
                } ]
            },
            name: "close-circle",
            theme: "outlined"
        };
        function _objectSpread$7(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$7(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$7(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var CloseCircleOutlined = function CloseCircleOutlined2(props2, context) {
            var p2 = _objectSpread$7({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$7({}, p2, {
                icon: CloseCircleOutlined$1
            }), null);
        };
        CloseCircleOutlined.displayName = "CloseCircleOutlined", CloseCircleOutlined.inheritAttrs = !1;
        var CheckCircleFilled$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z"
                    }
                } ]
            },
            name: "check-circle",
            theme: "filled"
        };
        function _objectSpread$6(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$6(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$6(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var CheckCircleFilled = function CheckCircleFilled2(props2, context) {
            var p2 = _objectSpread$6({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$6({}, p2, {
                icon: CheckCircleFilled$1
            }), null);
        };
        CheckCircleFilled.displayName = "CheckCircleFilled", CheckCircleFilled.inheritAttrs = !1;
        var ExclamationCircleFilled$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
                    }
                } ]
            },
            name: "exclamation-circle",
            theme: "filled"
        };
        function _objectSpread$5(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$5(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$5(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var ExclamationCircleFilled = function ExclamationCircleFilled2(props2, context) {
            var p2 = _objectSpread$5({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$5({}, p2, {
                icon: ExclamationCircleFilled$1
            }), null);
        };
        ExclamationCircleFilled.displayName = "ExclamationCircleFilled", ExclamationCircleFilled.inheritAttrs = !1;
        var InfoCircleFilled$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z"
                    }
                } ]
            },
            name: "info-circle",
            theme: "filled"
        };
        function _objectSpread$4(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$4(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$4(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var InfoCircleFilled = function InfoCircleFilled2(props2, context) {
            var p2 = _objectSpread$4({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$4({}, p2, {
                icon: InfoCircleFilled$1
            }), null);
        };
        InfoCircleFilled.displayName = "InfoCircleFilled", InfoCircleFilled.inheritAttrs = !1;
        const responsiveArray = [ "xxxl", "xxl", "xl", "lg", "md", "sm", "xs" ], getResponsiveMap = token2 => ({
            xs: `(max-width: ${token2.screenXSMax}px)`,
            sm: `(min-width: ${token2.screenSM}px)`,
            md: `(min-width: ${token2.screenMD}px)`,
            lg: `(min-width: ${token2.screenLG}px)`,
            xl: `(min-width: ${token2.screenXL}px)`,
            xxl: `(min-width: ${token2.screenXXL}px)`,
            xxxl: `{min-width: ${token2.screenXXXL}px}`
        });
        function useResponsiveObserver() {
            const [, token2] = useToken();
            return computed((() => {
                const responsiveMap = getResponsiveMap(token2.value), subscribers = new Map;
                let subUid = -1, screens = {};
                return {
                    matchHandlers: {},
                    dispatch: pointMap => (screens = pointMap, subscribers.forEach((func => func(screens))), 
                    subscribers.size >= 1),
                    subscribe(func) {
                        return subscribers.size || this.register(), subUid += 1, subscribers.set(subUid, func), 
                        func(screens), subUid;
                    },
                    unsubscribe(paramToken) {
                        subscribers.delete(paramToken), subscribers.size || this.unregister();
                    },
                    unregister() {
                        Object.keys(responsiveMap).forEach((screen => {
                            const matchMediaQuery = responsiveMap[screen], handler = this.matchHandlers[matchMediaQuery];
                            null == handler || handler.mql.removeListener(null == handler ? void 0 : handler.listener);
                        })), subscribers.clear();
                    },
                    register() {
                        Object.keys(responsiveMap).forEach((screen => {
                            const matchMediaQuery = responsiveMap[screen], listener = _ref => {
                                let {matches: matches} = _ref;
                                this.dispatch(_extends$1(_extends$1({}, screens), {
                                    [screen]: matches
                                }));
                            }, mql = window.matchMedia(matchMediaQuery);
                            mql.addListener(listener), this.matchHandlers[matchMediaQuery] = {
                                mql: mql,
                                listener: listener
                            }, listener(mql);
                        }));
                    },
                    responsiveMap: responsiveMap
                };
            }));
        }
        const autoAdjustOverflow = {
            adjustX: 1,
            adjustY: 1
        }, targetOffset$1 = [ 0, 0 ], placements = {
            left: {
                points: [ "cr", "cl" ],
                overflow: autoAdjustOverflow,
                offset: [ -4, 0 ],
                targetOffset: targetOffset$1
            },
            right: {
                points: [ "cl", "cr" ],
                overflow: autoAdjustOverflow,
                offset: [ 4, 0 ],
                targetOffset: targetOffset$1
            },
            top: {
                points: [ "bc", "tc" ],
                overflow: autoAdjustOverflow,
                offset: [ 0, -4 ],
                targetOffset: targetOffset$1
            },
            bottom: {
                points: [ "tc", "bc" ],
                overflow: autoAdjustOverflow,
                offset: [ 0, 4 ],
                targetOffset: targetOffset$1
            },
            topLeft: {
                points: [ "bl", "tl" ],
                overflow: autoAdjustOverflow,
                offset: [ 0, -4 ],
                targetOffset: targetOffset$1
            },
            leftTop: {
                points: [ "tr", "tl" ],
                overflow: autoAdjustOverflow,
                offset: [ -4, 0 ],
                targetOffset: targetOffset$1
            },
            topRight: {
                points: [ "br", "tr" ],
                overflow: autoAdjustOverflow,
                offset: [ 0, -4 ],
                targetOffset: targetOffset$1
            },
            rightTop: {
                points: [ "tl", "tr" ],
                overflow: autoAdjustOverflow,
                offset: [ 4, 0 ],
                targetOffset: targetOffset$1
            },
            bottomRight: {
                points: [ "tr", "br" ],
                overflow: autoAdjustOverflow,
                offset: [ 0, 4 ],
                targetOffset: targetOffset$1
            },
            rightBottom: {
                points: [ "bl", "br" ],
                overflow: autoAdjustOverflow,
                offset: [ 4, 0 ],
                targetOffset: targetOffset$1
            },
            bottomLeft: {
                points: [ "tl", "bl" ],
                overflow: autoAdjustOverflow,
                offset: [ 0, 4 ],
                targetOffset: targetOffset$1
            },
            leftBottom: {
                points: [ "br", "bl" ],
                overflow: autoAdjustOverflow,
                offset: [ -4, 0 ],
                targetOffset: targetOffset$1
            }
        }, Content = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "TooltipContent",
            props: {
                prefixCls: String,
                id: String,
                overlayInnerStyle: PropTypes.any
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                return () => {
                    var _a;
                    return createVNode("div", {
                        class: `${props2.prefixCls}-inner`,
                        id: props2.id,
                        role: "tooltip",
                        style: props2.overlayInnerStyle
                    }, [ null === (_a = slots.overlay) || void 0 === _a ? void 0 : _a.call(slots) ]);
                };
            }
        });
        var __rest$a = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        function noop() {}
        const Tooltip$1 = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Tooltip",
            inheritAttrs: !1,
            props: {
                trigger: PropTypes.any.def([ "hover" ]),
                defaultVisible: {
                    type: Boolean,
                    default: void 0
                },
                visible: {
                    type: Boolean,
                    default: void 0
                },
                placement: PropTypes.string.def("right"),
                transitionName: String,
                animation: PropTypes.any,
                afterVisibleChange: PropTypes.func.def((() => {})),
                overlayStyle: {
                    type: Object,
                    default: void 0
                },
                overlayClassName: String,
                prefixCls: PropTypes.string.def("rc-tooltip"),
                mouseEnterDelay: PropTypes.number.def(.1),
                mouseLeaveDelay: PropTypes.number.def(.1),
                getPopupContainer: Function,
                destroyTooltipOnHide: {
                    type: Boolean,
                    default: !1
                },
                align: PropTypes.object.def((() => ({}))),
                arrowContent: PropTypes.any.def(null),
                tipId: String,
                builtinPlacements: PropTypes.object,
                overlayInnerStyle: {
                    type: Object,
                    default: void 0
                },
                popupVisible: {
                    type: Boolean,
                    default: void 0
                },
                onVisibleChange: Function,
                onPopupAlign: Function,
                arrow: {
                    type: Boolean,
                    default: !0
                }
            },
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs, expose: expose} = _ref;
                const triggerDOM = shallowRef(), getPopupElement = () => {
                    const {prefixCls: prefixCls, tipId: tipId, overlayInnerStyle: overlayInnerStyle} = props2;
                    return [ props2.arrow ? createVNode("div", {
                        class: `${prefixCls}-arrow`,
                        key: "arrow"
                    }, [ getPropsSlot(slots, props2, "arrowContent") ]) : null, createVNode(Content, {
                        key: "content",
                        prefixCls: prefixCls,
                        id: tipId,
                        overlayInnerStyle: overlayInnerStyle
                    }, {
                        overlay: slots.overlay
                    }) ];
                };
                expose({
                    getPopupDomNode: () => triggerDOM.value.getPopupDomNode(),
                    triggerDOM: triggerDOM,
                    forcePopupAlign: () => {
                        var _a;
                        return null === (_a = triggerDOM.value) || void 0 === _a ? void 0 : _a.forcePopupAlign();
                    }
                });
                const destroyTooltip = shallowRef(!1), autoDestroy = shallowRef(!1);
                return watchEffect((() => {
                    const {destroyTooltipOnHide: destroyTooltipOnHide} = props2;
                    if ("boolean" == typeof destroyTooltipOnHide) destroyTooltip.value = destroyTooltipOnHide; else if (destroyTooltipOnHide && "object" == typeof destroyTooltipOnHide) {
                        const {keepParent: keepParent} = destroyTooltipOnHide;
                        destroyTooltip.value = !0 === keepParent, autoDestroy.value = !1 === keepParent;
                    }
                })), () => {
                    const {overlayClassName: overlayClassName, trigger: trigger2, mouseEnterDelay: mouseEnterDelay, mouseLeaveDelay: mouseLeaveDelay, overlayStyle: overlayStyle, prefixCls: prefixCls, afterVisibleChange: afterVisibleChange, transitionName: transitionName2, animation: animation, placement: placement, align: align, destroyTooltipOnHide: destroyTooltipOnHide, defaultVisible: defaultVisible} = props2, extraProps = _extends$1({}, __rest$a(props2, [ "overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible" ]));
                    void 0 !== props2.visible && (extraProps.popupVisible = props2.visible);
                    const triggerProps2 = _extends$1(_extends$1(_extends$1({
                        popupClassName: overlayClassName,
                        prefixCls: prefixCls,
                        action: trigger2,
                        builtinPlacements: placements,
                        popupPlacement: placement,
                        popupAlign: align,
                        afterPopupVisibleChange: afterVisibleChange,
                        popupTransitionName: transitionName2,
                        popupAnimation: animation,
                        defaultPopupVisible: defaultVisible,
                        destroyPopupOnHide: destroyTooltip.value,
                        autoDestroy: autoDestroy.value,
                        mouseLeaveDelay: mouseLeaveDelay,
                        popupStyle: overlayStyle,
                        mouseEnterDelay: mouseEnterDelay
                    }, extraProps), attrs), {
                        onPopupVisibleChange: props2.onVisibleChange || noop,
                        onPopupAlign: props2.onPopupAlign || noop,
                        ref: triggerDOM,
                        arrow: !!props2.arrow,
                        popup: getPopupElement()
                    });
                    return createVNode(Trigger, triggerProps2, {
                        default: slots.default
                    });
                };
            }
        }), abstractTooltipProps = () => ({
            trigger: [ String, Array ],
            open: {
                type: Boolean,
                default: void 0
            },
            visible: {
                type: Boolean,
                default: void 0
            },
            placement: String,
            color: String,
            transitionName: String,
            overlayStyle: objectType(),
            overlayInnerStyle: objectType(),
            overlayClassName: String,
            openClassName: String,
            prefixCls: String,
            mouseEnterDelay: Number,
            mouseLeaveDelay: Number,
            getPopupContainer: Function,
            arrowPointAtCenter: {
                type: Boolean,
                default: void 0
            },
            arrow: {
                type: [ Boolean, Object ],
                default: !0
            },
            autoAdjustOverflow: {
                type: [ Boolean, Object ],
                default: void 0
            },
            destroyTooltipOnHide: {
                type: Boolean,
                default: void 0
            },
            align: objectType(),
            builtinPlacements: objectType(),
            children: Array,
            onVisibleChange: Function,
            "onUpdate:visible": Function,
            onOpenChange: Function,
            "onUpdate:open": Function
        }), autoAdjustOverflowEnabled = {
            adjustX: 1,
            adjustY: 1
        }, autoAdjustOverflowDisabled = {
            adjustX: 0,
            adjustY: 0
        }, targetOffset = [ 0, 0 ];
        function getOverflowOptions(autoAdjustOverflow2) {
            return "boolean" == typeof autoAdjustOverflow2 ? autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled : _extends$1(_extends$1({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
        }
        function getPlacements(config) {
            const {arrowWidth: arrowWidth = 4, horizontalArrowShift: horizontalArrowShift = 16, verticalArrowShift: verticalArrowShift = 8, autoAdjustOverflow: autoAdjustOverflow2, arrowPointAtCenter: arrowPointAtCenter} = config, placementMap = {
                left: {
                    points: [ "cr", "cl" ],
                    offset: [ -4, 0 ]
                },
                right: {
                    points: [ "cl", "cr" ],
                    offset: [ 4, 0 ]
                },
                top: {
                    points: [ "bc", "tc" ],
                    offset: [ 0, -4 ]
                },
                bottom: {
                    points: [ "tc", "bc" ],
                    offset: [ 0, 4 ]
                },
                topLeft: {
                    points: [ "bl", "tc" ],
                    offset: [ -(horizontalArrowShift + arrowWidth), -4 ]
                },
                leftTop: {
                    points: [ "tr", "cl" ],
                    offset: [ -4, -(verticalArrowShift + arrowWidth) ]
                },
                topRight: {
                    points: [ "br", "tc" ],
                    offset: [ horizontalArrowShift + arrowWidth, -4 ]
                },
                rightTop: {
                    points: [ "tl", "cr" ],
                    offset: [ 4, -(verticalArrowShift + arrowWidth) ]
                },
                bottomRight: {
                    points: [ "tr", "bc" ],
                    offset: [ horizontalArrowShift + arrowWidth, 4 ]
                },
                rightBottom: {
                    points: [ "bl", "cr" ],
                    offset: [ 4, verticalArrowShift + arrowWidth ]
                },
                bottomLeft: {
                    points: [ "tl", "bc" ],
                    offset: [ -(horizontalArrowShift + arrowWidth), 4 ]
                },
                leftBottom: {
                    points: [ "br", "cl" ],
                    offset: [ -4, verticalArrowShift + arrowWidth ]
                }
            };
            return Object.keys(placementMap).forEach((key2 => {
                placementMap[key2] = arrowPointAtCenter ? _extends$1(_extends$1({}, placementMap[key2]), {
                    overflow: getOverflowOptions(autoAdjustOverflow2),
                    targetOffset: targetOffset
                }) : _extends$1(_extends$1({}, placements[key2]), {
                    overflow: getOverflowOptions(autoAdjustOverflow2)
                }), placementMap[key2].ignoreShake = !0;
            })), placementMap;
        }
        function firstNotUndefined() {
            let arr = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
            for (let i2 = 0, len = arr.length; i2 < len; i2++) if (void 0 !== arr[i2]) return arr[i2];
        }
        const inverseColors = PresetColors.map((color => `${color}-inverse`)), PresetStatusColorTypes = [ "success", "processing", "error", "default", "warning" ];
        function isPresetColor(color) {
            return !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? [ ...inverseColors, ...PresetColors ].includes(color) : PresetColors.includes(color);
        }
        function isPresetStatusColor(color) {
            return PresetStatusColorTypes.includes(color);
        }
        function parseColor(prefixCls, color) {
            const isInternalColor = isPresetColor(color), className = classNames({
                [`${prefixCls}-${color}`]: color && isInternalColor
            }), overlayStyle = {}, arrowStyle = {};
            return color && !isInternalColor && (overlayStyle.background = color, arrowStyle["--antd-arrow-background-color"] = color), 
            {
                className: className,
                overlayStyle: overlayStyle,
                arrowStyle: arrowStyle
            };
        }
        function connectArrowCls(classList) {
            let showArrowCls = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            return classList.map((cls => `${showArrowCls}${cls}`)).join(",");
        }
        const MAX_VERTICAL_CONTENT_RADIUS = 8;
        function getArrowOffset(options) {
            const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS, {sizePopupArrow: sizePopupArrow, contentRadius: contentRadius, borderRadiusOuter: borderRadiusOuter, limitVerticalRadius: limitVerticalRadius} = options, arrowInnerOffset = sizePopupArrow / 2 - Math.ceil(borderRadiusOuter * (Math.sqrt(2) - 1)), dropdownArrowOffset = (contentRadius > 12 ? contentRadius + 2 : 12) - arrowInnerOffset;
            return {
                dropdownArrowOffset: dropdownArrowOffset,
                dropdownArrowOffsetVertical: limitVerticalRadius ? maxVerticalContentRadius - arrowInnerOffset : dropdownArrowOffset
            };
        }
        function getArrowStyle(token2, options) {
            const {componentCls: componentCls, sizePopupArrow: sizePopupArrow, marginXXS: marginXXS, borderRadiusXS: borderRadiusXS, borderRadiusOuter: borderRadiusOuter, boxShadowPopoverArrow: boxShadowPopoverArrow} = token2, {colorBg: colorBg, showArrowCls: showArrowCls, contentRadius: contentRadius = token2.borderRadiusLG, limitVerticalRadius: limitVerticalRadius} = options, {dropdownArrowOffsetVertical: dropdownArrowOffsetVertical, dropdownArrowOffset: dropdownArrowOffset} = getArrowOffset({
                sizePopupArrow: sizePopupArrow,
                contentRadius: contentRadius,
                borderRadiusOuter: borderRadiusOuter,
                limitVerticalRadius: limitVerticalRadius
            }), dropdownArrowDistance = sizePopupArrow / 2 + marginXXS;
            return {
                [componentCls]: {
                    [`${componentCls}-arrow`]: [ _extends$1(_extends$1({
                        position: "absolute",
                        zIndex: 1,
                        display: "block"
                    }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
                        "&:before": {
                            background: colorBg
                        }
                    }) ],
                    [[ `&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow` ].join(",")]: {
                        bottom: 0,
                        transform: "translateY(100%) rotate(180deg)"
                    },
                    [`&-placement-top ${componentCls}-arrow`]: {
                        left: {
                            _skip_check_: !0,
                            value: "50%"
                        },
                        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
                    },
                    [`&-placement-topLeft ${componentCls}-arrow`]: {
                        left: {
                            _skip_check_: !0,
                            value: dropdownArrowOffset
                        }
                    },
                    [`&-placement-topRight ${componentCls}-arrow`]: {
                        right: {
                            _skip_check_: !0,
                            value: dropdownArrowOffset
                        }
                    },
                    [[ `&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow` ].join(",")]: {
                        top: 0,
                        transform: "translateY(-100%)"
                    },
                    [`&-placement-bottom ${componentCls}-arrow`]: {
                        left: {
                            _skip_check_: !0,
                            value: "50%"
                        },
                        transform: "translateX(-50%) translateY(-100%)"
                    },
                    [`&-placement-bottomLeft ${componentCls}-arrow`]: {
                        left: {
                            _skip_check_: !0,
                            value: dropdownArrowOffset
                        }
                    },
                    [`&-placement-bottomRight ${componentCls}-arrow`]: {
                        right: {
                            _skip_check_: !0,
                            value: dropdownArrowOffset
                        }
                    },
                    [[ `&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow` ].join(",")]: {
                        right: {
                            _skip_check_: !0,
                            value: 0
                        },
                        transform: "translateX(100%) rotate(90deg)"
                    },
                    [`&-placement-left ${componentCls}-arrow`]: {
                        top: {
                            _skip_check_: !0,
                            value: "50%"
                        },
                        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
                    },
                    [`&-placement-leftTop ${componentCls}-arrow`]: {
                        top: dropdownArrowOffsetVertical
                    },
                    [`&-placement-leftBottom ${componentCls}-arrow`]: {
                        bottom: dropdownArrowOffsetVertical
                    },
                    [[ `&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow` ].join(",")]: {
                        left: {
                            _skip_check_: !0,
                            value: 0
                        },
                        transform: "translateX(-100%) rotate(-90deg)"
                    },
                    [`&-placement-right ${componentCls}-arrow`]: {
                        top: {
                            _skip_check_: !0,
                            value: "50%"
                        },
                        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
                    },
                    [`&-placement-rightTop ${componentCls}-arrow`]: {
                        top: dropdownArrowOffsetVertical
                    },
                    [`&-placement-rightBottom ${componentCls}-arrow`]: {
                        bottom: dropdownArrowOffsetVertical
                    },
                    [connectArrowCls([ "&-placement-topLeft", "&-placement-top", "&-placement-topRight" ].map((cls => cls + ":not(&-arrow-hidden)")), showArrowCls)]: {
                        paddingBottom: dropdownArrowDistance
                    },
                    [connectArrowCls([ "&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight" ].map((cls => cls + ":not(&-arrow-hidden)")), showArrowCls)]: {
                        paddingTop: dropdownArrowDistance
                    },
                    [connectArrowCls([ "&-placement-leftTop", "&-placement-left", "&-placement-leftBottom" ].map((cls => cls + ":not(&-arrow-hidden)")), showArrowCls)]: {
                        paddingRight: {
                            _skip_check_: !0,
                            value: dropdownArrowDistance
                        }
                    },
                    [connectArrowCls([ "&-placement-rightTop", "&-placement-right", "&-placement-rightBottom" ].map((cls => cls + ":not(&-arrow-hidden)")), showArrowCls)]: {
                        paddingLeft: {
                            _skip_check_: !0,
                            value: dropdownArrowDistance
                        }
                    }
                }
            };
        }
        const genTooltipStyle = token2 => {
            const {componentCls: componentCls, tooltipMaxWidth: tooltipMaxWidth, tooltipColor: tooltipColor, tooltipBg: tooltipBg, tooltipBorderRadius: tooltipBorderRadius, zIndexPopup: zIndexPopup, controlHeight: controlHeight, boxShadowSecondary: boxShadowSecondary, paddingSM: paddingSM, paddingXS: paddingXS, tooltipRadiusOuter: tooltipRadiusOuter} = token2;
            return [ {
                [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
                    position: "absolute",
                    zIndex: zIndexPopup,
                    display: "block",
                    "&": [ {
                        width: "max-content"
                    }, {
                        width: "intrinsic"
                    } ],
                    maxWidth: tooltipMaxWidth,
                    visibility: "visible",
                    "&-hidden": {
                        display: "none"
                    },
                    "--antd-arrow-background-color": tooltipBg,
                    [`${componentCls}-inner`]: {
                        minWidth: controlHeight,
                        minHeight: controlHeight,
                        padding: `${paddingSM / 2}px ${paddingXS}px`,
                        color: tooltipColor,
                        textAlign: "start",
                        textDecoration: "none",
                        wordWrap: "break-word",
                        backgroundColor: tooltipBg,
                        borderRadius: tooltipBorderRadius,
                        boxShadow: boxShadowSecondary
                    },
                    [[ "&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom" ].join(",")]: {
                        [`${componentCls}-inner`]: {
                            borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
                        }
                    },
                    [`${componentCls}-content`]: {
                        position: "relative"
                    }
                }), genPresetColor(token2, ((colorKey, _ref) => {
                    let {darkColor: darkColor} = _ref;
                    return {
                        [`&${componentCls}-${colorKey}`]: {
                            [`${componentCls}-inner`]: {
                                backgroundColor: darkColor
                            },
                            [`${componentCls}-arrow`]: {
                                "--antd-arrow-background-color": darkColor
                            }
                        }
                    };
                }))), {
                    "&-rtl": {
                        direction: "rtl"
                    }
                })
            }, getArrowStyle(merge(token2, {
                borderRadiusOuter: tooltipRadiusOuter
            }), {
                colorBg: "var(--antd-arrow-background-color)",
                showArrowCls: "",
                contentRadius: tooltipBorderRadius,
                limitVerticalRadius: !0
            }), {
                [`${componentCls}-pure`]: {
                    position: "relative",
                    maxWidth: "none"
                }
            } ];
        }, useStyle$9 = (prefixCls, injectStyle) => genComponentStyleHook("Tooltip", (token2 => {
            if (!1 === (null == injectStyle ? void 0 : injectStyle.value)) return [];
            const {borderRadius: borderRadius, colorTextLightSolid: colorTextLightSolid, colorBgDefault: colorBgDefault, borderRadiusOuter: borderRadiusOuter} = token2, TooltipToken = merge(token2, {
                tooltipMaxWidth: 250,
                tooltipColor: colorTextLightSolid,
                tooltipBorderRadius: borderRadius,
                tooltipBg: colorBgDefault,
                tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
            });
            return [ genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast") ];
        }), (_ref2 => {
            let {zIndexPopupBase: zIndexPopupBase, colorBgSpotlight: colorBgSpotlight} = _ref2;
            return {
                zIndexPopup: zIndexPopupBase + 70,
                colorBgDefault: colorBgSpotlight
            };
        }))(prefixCls), splitObject = (obj, keys2) => {
            const picked = {}, omitted = _extends$1({}, obj);
            return keys2.forEach((key2 => {
                obj && key2 in obj && (picked[key2] = obj[key2], delete omitted[key2]);
            })), {
                picked: picked,
                omitted: omitted
            };
        }, Tooltip = withInstall(defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ATooltip",
            inheritAttrs: !1,
            props: initDefaultProps((() => _extends$1(_extends$1({}, abstractTooltipProps()), {
                title: PropTypes.any
            }))(), {
                trigger: "hover",
                align: {},
                placement: "top",
                mouseEnterDelay: .1,
                mouseLeaveDelay: .1,
                arrowPointAtCenter: !1,
                autoAdjustOverflow: !0
            }),
            slots: Object,
            setup(props2, _ref) {
                let {slots: slots, emit: emit2, attrs: attrs, expose: expose} = _ref;
                const {prefixCls: prefixCls, getPopupContainer: getPopupContainer, direction: direction, rootPrefixCls: rootPrefixCls} = useConfigInject("tooltip", props2), mergedOpen = computed((() => {
                    var _a;
                    return null !== (_a = props2.open) && void 0 !== _a ? _a : props2.visible;
                })), innerOpen = ref(firstNotUndefined([ props2.open, props2.visible ])), tooltip = ref();
                let rafId;
                watch(mergedOpen, (val => {
                    wrapperRaf.cancel(rafId), rafId = wrapperRaf((() => {
                        innerOpen.value = !!val;
                    }));
                }));
                const isNoTitle = () => {
                    var _a;
                    const title = null !== (_a = props2.title) && void 0 !== _a ? _a : slots.title;
                    return !title && 0 !== title;
                }, handleVisibleChange = val => {
                    const noTitle = isNoTitle();
                    void 0 === mergedOpen.value && (innerOpen.value = !noTitle && val), noTitle || (emit2("update:visible", val), 
                    emit2("visibleChange", val), emit2("update:open", val), emit2("openChange", val));
                };
                expose({
                    getPopupDomNode: () => tooltip.value.getPopupDomNode(),
                    open: innerOpen,
                    forcePopupAlign: () => {
                        var _a;
                        return null === (_a = tooltip.value) || void 0 === _a ? void 0 : _a.forcePopupAlign();
                    }
                });
                const tooltipPlacements = computed((() => {
                    var _a;
                    const {builtinPlacements: builtinPlacements, autoAdjustOverflow: autoAdjustOverflow2, arrow: arrow, arrowPointAtCenter: arrowPointAtCenter} = props2;
                    let mergedArrowPointAtCenter = arrowPointAtCenter;
                    return "object" == typeof arrow && (mergedArrowPointAtCenter = null !== (_a = arrow.pointAtCenter) && void 0 !== _a ? _a : arrowPointAtCenter), 
                    builtinPlacements || getPlacements({
                        arrowPointAtCenter: mergedArrowPointAtCenter,
                        autoAdjustOverflow: autoAdjustOverflow2
                    });
                })), isTrueProps = val => val || "" === val, getDisabledCompatibleChildren = ele => {
                    const elementType = ele.type;
                    if ("object" == typeof elementType && ele.props && ((!0 === elementType.__ANT_BUTTON || "button" === elementType) && isTrueProps(ele.props.disabled) || !0 === elementType.__ANT_SWITCH && (isTrueProps(ele.props.disabled) || isTrueProps(ele.props.loading)) || !0 === elementType.__ANT_RADIO && isTrueProps(ele.props.disabled))) {
                        const {picked: picked, omitted: omitted} = splitObject(getStyle$1(ele), [ "position", "left", "right", "top", "bottom", "float", "display", "zIndex" ]), spanStyle = _extends$1(_extends$1({
                            display: "inline-block"
                        }, picked), {
                            cursor: "not-allowed",
                            lineHeight: 1,
                            width: ele.props && ele.props.block ? "100%" : void 0
                        }), child = cloneElement(ele, {
                            style: _extends$1(_extends$1({}, omitted), {
                                pointerEvents: "none"
                            })
                        }, !0);
                        return createVNode("span", {
                            style: spanStyle,
                            class: `${prefixCls.value}-disabled-compatible-wrapper`
                        }, [ child ]);
                    }
                    return ele;
                }, getOverlay = () => {
                    var _a, _b;
                    return null !== (_a = props2.title) && void 0 !== _a ? _a : null === (_b = slots.title) || void 0 === _b ? void 0 : _b.call(slots);
                }, onPopupAlign = (domNode, align) => {
                    const placements2 = tooltipPlacements.value, placement = Object.keys(placements2).find((key2 => {
                        var _a, _b;
                        return placements2[key2].points[0] === (null === (_a = align.points) || void 0 === _a ? void 0 : _a[0]) && placements2[key2].points[1] === (null === (_b = align.points) || void 0 === _b ? void 0 : _b[1]);
                    }));
                    if (placement) {
                        const rect = domNode.getBoundingClientRect(), transformOrigin = {
                            top: "50%",
                            left: "50%"
                        };
                        placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0 ? transformOrigin.top = rect.height - align.offset[1] + "px" : (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) && (transformOrigin.top = -align.offset[1] + "px"), 
                        placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0 ? transformOrigin.left = rect.width - align.offset[0] + "px" : (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) && (transformOrigin.left = -align.offset[0] + "px"), 
                        domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
                    }
                }, colorInfo = computed((() => parseColor(prefixCls.value, props2.color))), injectFromPopover = computed((() => attrs["data-popover-inject"])), [wrapSSR, hashId] = useStyle$9(prefixCls, computed((() => !injectFromPopover.value)));
                return () => {
                    var _a, _b;
                    const {openClassName: openClassName, overlayClassName: overlayClassName, overlayStyle: overlayStyle, overlayInnerStyle: overlayInnerStyle} = props2;
                    let children = null !== (_b = filterEmpty(null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots))) && void 0 !== _b ? _b : null;
                    children = 1 === children.length ? children[0] : children;
                    let tempVisible = innerOpen.value;
                    if (void 0 === mergedOpen.value && isNoTitle() && (tempVisible = !1), !children) return null;
                    const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : createVNode("span", null, [ children ])), childCls = classNames({
                        [openClassName || `${prefixCls.value}-open`]: !0,
                        [child.props && child.props.class]: child.props && child.props.class
                    }), customOverlayClassName = classNames(overlayClassName, {
                        [`${prefixCls.value}-rtl`]: "rtl" === direction.value
                    }, colorInfo.value.className, hashId.value), formattedOverlayInnerStyle = _extends$1(_extends$1({}, colorInfo.value.overlayStyle), overlayInnerStyle), arrowContentStyle = colorInfo.value.arrowStyle, vcTooltipProps = _extends$1(_extends$1(_extends$1({}, attrs), props2), {
                        prefixCls: prefixCls.value,
                        arrow: !!props2.arrow,
                        getPopupContainer: null == getPopupContainer ? void 0 : getPopupContainer.value,
                        builtinPlacements: tooltipPlacements.value,
                        visible: tempVisible,
                        ref: tooltip,
                        overlayClassName: customOverlayClassName,
                        overlayStyle: _extends$1(_extends$1({}, arrowContentStyle), overlayStyle),
                        overlayInnerStyle: formattedOverlayInnerStyle,
                        onVisibleChange: handleVisibleChange,
                        onPopupAlign: onPopupAlign,
                        transitionName: getTransitionName(rootPrefixCls.value, "zoom-big-fast", props2.transitionName)
                    });
                    return wrapSSR(createVNode(Tooltip$1, vcTooltipProps, {
                        default: () => [ innerOpen.value ? cloneElement(child, {
                            class: childCls
                        }) : child ],
                        arrowContent: () => createVNode("span", {
                            class: `${prefixCls.value}-arrow-content`
                        }, null),
                        overlay: getOverlay
                    }));
                };
            }
        })), isNumeric = value => !isNaN(parseFloat(value)) && isFinite(value), genWaveStyle = token2 => {
            const {componentCls: componentCls, colorPrimary: colorPrimary} = token2;
            return {
                [componentCls]: {
                    position: "absolute",
                    background: "transparent",
                    pointerEvents: "none",
                    boxSizing: "border-box",
                    color: `var(--wave-color, ${colorPrimary})`,
                    boxShadow: "0 0 0 0 currentcolor",
                    opacity: .2,
                    "&.wave-motion-appear": {
                        transition: [ `box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}` ].join(","),
                        "&-active": {
                            boxShadow: "0 0 0 6px currentcolor",
                            opacity: 0
                        }
                    }
                }
            };
        }, useStyle$8 = genComponentStyleHook("Wave", (token2 => [ genWaveStyle(token2) ]));
        function isNotGrey(color) {
            const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
            return !(match2 && match2[1] && match2[2] && match2[3]) || !(match2[1] === match2[2] && match2[2] === match2[3]);
        }
        function isValidWaveColor(color) {
            return color && "#fff" !== color && "#ffffff" !== color && "rgb(255, 255, 255)" !== color && "rgba(255, 255, 255, 1)" !== color && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && "transparent" !== color;
        }
        function getTargetWaveColor(node2) {
            const {borderTopColor: borderTopColor, borderColor: borderColor, backgroundColor: backgroundColor} = getComputedStyle(node2);
            return isValidWaveColor(borderTopColor) ? borderTopColor : isValidWaveColor(borderColor) ? borderColor : isValidWaveColor(backgroundColor) ? backgroundColor : null;
        }
        function validateNum(value) {
            return Number.isNaN(value) ? 0 : value;
        }
        const WaveEffect = defineComponent({
            props: {
                target: objectType(),
                className: String
            },
            setup(props2) {
                const divRef = shallowRef(null), [color, setWaveColor] = useState(null), [borderRadius, setBorderRadius] = useState([]), [left, setLeft] = useState(0), [top, setTop] = useState(0), [width, setWidth] = useState(0), [height, setHeight] = useState(0), [enabled, setEnabled] = useState(!1);
                function syncPos() {
                    const {target: target} = props2, nodeStyle = getComputedStyle(target);
                    setWaveColor(getTargetWaveColor(target));
                    const isStatic = "static" === nodeStyle.position, {borderLeftWidth: borderLeftWidth, borderTopWidth: borderTopWidth} = nodeStyle;
                    setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth))), 
                    setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth))), 
                    setWidth(target.offsetWidth), setHeight(target.offsetHeight);
                    const {borderTopLeftRadius: borderTopLeftRadius, borderTopRightRadius: borderTopRightRadius, borderBottomLeftRadius: borderBottomLeftRadius, borderBottomRightRadius: borderBottomRightRadius} = nodeStyle;
                    setBorderRadius([ borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius ].map((radius => validateNum(parseFloat(radius)))));
                }
                let resizeObserver, rafId, timeoutId;
                const clear2 = () => {
                    clearTimeout(timeoutId), wrapperRaf.cancel(rafId), null == resizeObserver || resizeObserver.disconnect();
                }, removeDom = () => {
                    var _a;
                    const holder = null === (_a = divRef.value) || void 0 === _a ? void 0 : _a.parentElement;
                    holder && (render(null, holder), holder.parentElement && holder.parentElement.removeChild(holder));
                };
                onMounted((() => {
                    clear2(), timeoutId = setTimeout((() => {
                        removeDom();
                    }), 5e3);
                    const {target: target} = props2;
                    target && (rafId = wrapperRaf((() => {
                        syncPos(), setEnabled(!0);
                    })), "undefined" != typeof ResizeObserver && (resizeObserver = new ResizeObserver(syncPos), 
                    resizeObserver.observe(target)));
                })), onBeforeUnmount((() => {
                    clear2();
                }));
                const onTransitionend = e2 => {
                    "opacity" === e2.propertyName && removeDom();
                };
                return () => {
                    if (!enabled.value) return null;
                    const waveStyle = {
                        left: `${left.value}px`,
                        top: `${top.value}px`,
                        width: `${width.value}px`,
                        height: `${height.value}px`,
                        borderRadius: borderRadius.value.map((radius => `${radius}px`)).join(" ")
                    };
                    return color && (waveStyle["--wave-color"] = color.value), createVNode(Transition, {
                        appear: !0,
                        name: "wave-motion",
                        appearFromClass: "wave-motion-appear",
                        appearActiveClass: "wave-motion-appear",
                        appearToClass: "wave-motion-appear wave-motion-appear-active"
                    }, {
                        default: () => [ createVNode("div", {
                            ref: divRef,
                            class: props2.className,
                            style: waveStyle,
                            onTransitionend: onTransitionend
                        }, null) ]
                    });
                };
            }
        });
        function showWaveEffect(node2, className) {
            const holder = document.createElement("div");
            holder.style.position = "absolute", holder.style.left = "0px", holder.style.top = "0px", 
            null == node2 || node2.insertBefore(holder, null == node2 ? void 0 : node2.firstChild), 
            render(createVNode(WaveEffect, {
                target: node2,
                className: className
            }, null), holder);
        }
        function useWave(instance, className, wave) {
            function showWave() {
                var _a;
                const node2 = findDOMNode(instance);
                !(null === (_a = null == wave ? void 0 : wave.value) || void 0 === _a ? void 0 : _a.disabled) && node2 && showWaveEffect(node2, className.value);
            }
            return showWave;
        }
        const Wave = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Wave",
            props: {
                disabled: Boolean
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const instance = getCurrentInstance(), {prefixCls: prefixCls, wave: wave} = useConfigInject("wave", props2), [, hashId] = useStyle$8(prefixCls), showWave = useWave(instance, computed((() => classNames(prefixCls.value, hashId.value))), wave);
                let onClick;
                const clear2 = () => {
                    findDOMNode(instance).removeEventListener("click", onClick, !0);
                };
                return onMounted((() => {
                    watch((() => props2.disabled), (() => {
                        clear2(), nextTick((() => {
                            const node2 = findDOMNode(instance);
                            null == node2 || node2.removeEventListener("click", onClick, !0), node2 && 1 === node2.nodeType && !props2.disabled && (onClick = e2 => {
                                "INPUT" === e2.target.tagName || !isVisible(e2.target) || !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave") || showWave();
                            }, node2.addEventListener("click", onClick, !0));
                        }));
                    }), {
                        immediate: !0,
                        flush: "post"
                    });
                })), onBeforeUnmount((() => {
                    clear2();
                })), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots)[0];
                };
            }
        }), buttonProps = () => ({
            prefixCls: String,
            type: String,
            htmlType: {
                type: String,
                default: "button"
            },
            shape: {
                type: String
            },
            size: {
                type: String
            },
            loading: {
                type: [ Boolean, Object ],
                default: () => !1
            },
            disabled: {
                type: Boolean,
                default: void 0
            },
            ghost: {
                type: Boolean,
                default: void 0
            },
            block: {
                type: Boolean,
                default: void 0
            },
            danger: {
                type: Boolean,
                default: void 0
            },
            icon: PropTypes.any,
            href: String,
            target: String,
            title: String,
            onClick: eventType(),
            onMousedown: eventType()
        }), getCollapsedWidth = node2 => {
            node2 && (node2.style.width = "0px", node2.style.opacity = "0", node2.style.transform = "scale(0)");
        }, getRealWidth = node2 => {
            nextTick((() => {
                node2 && (node2.style.width = `${node2.scrollWidth}px`, node2.style.opacity = "1", 
                node2.style.transform = "scale(1)");
            }));
        }, resetStyle = node2 => {
            node2 && node2.style && (node2.style.width = null, node2.style.opacity = null, node2.style.transform = null);
        }, LoadingIcon = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "LoadingIcon",
            props: {
                prefixCls: String,
                loading: [ Boolean, Object ],
                existIcon: Boolean
            },
            setup: props2 => () => {
                const {existIcon: existIcon, prefixCls: prefixCls, loading: loading} = props2;
                if (existIcon) return createVNode("span", {
                    class: `${prefixCls}-loading-icon`
                }, [ createVNode(LoadingOutlined, null, null) ]);
                const visible = !!loading;
                return createVNode(Transition, {
                    name: `${prefixCls}-loading-icon-motion`,
                    onBeforeEnter: getCollapsedWidth,
                    onEnter: getRealWidth,
                    onAfterEnter: resetStyle,
                    onBeforeLeave: getRealWidth,
                    onLeave: node2 => {
                        setTimeout((() => {
                            getCollapsedWidth(node2);
                        }));
                    },
                    onAfterLeave: resetStyle
                }, {
                    default: () => [ visible ? createVNode("span", {
                        class: `${prefixCls}-loading-icon`
                    }, [ createVNode(LoadingOutlined, null, null) ]) : null ]
                });
            }
        }), genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
            [`> span, > ${buttonTypeCls}`]: {
                "&:not(:last-child)": {
                    [`&, & > ${buttonTypeCls}`]: {
                        "&:not(:disabled)": {
                            borderInlineEndColor: borderColor
                        }
                    }
                },
                "&:not(:first-child)": {
                    [`&, & > ${buttonTypeCls}`]: {
                        "&:not(:disabled)": {
                            borderInlineStartColor: borderColor
                        }
                    }
                }
            }
        }), genGroupStyle = token2 => {
            const {componentCls: componentCls, fontSize: fontSize, lineWidth: lineWidth, colorPrimaryHover: colorPrimaryHover, colorErrorHover: colorErrorHover} = token2;
            return {
                [`${componentCls}-group`]: [ {
                    position: "relative",
                    display: "inline-flex",
                    [`> span, > ${componentCls}`]: {
                        "&:not(:last-child)": {
                            [`&, & > ${componentCls}`]: {
                                borderStartEndRadius: 0,
                                borderEndEndRadius: 0
                            }
                        },
                        "&:not(:first-child)": {
                            marginInlineStart: -lineWidth,
                            [`&, & > ${componentCls}`]: {
                                borderStartStartRadius: 0,
                                borderEndStartRadius: 0
                            }
                        }
                    },
                    [componentCls]: {
                        position: "relative",
                        zIndex: 1,
                        "&:hover,\n          &:focus,\n          &:active": {
                            zIndex: 2
                        },
                        "&[disabled]": {
                            zIndex: 0
                        }
                    },
                    [`${componentCls}-icon-only`]: {
                        fontSize: fontSize
                    }
                }, genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover), genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover) ]
            };
        };
        function compactItemVerticalBorder(token2, parentCls) {
            return {
                [`&-item:not(${parentCls}-last-item)`]: {
                    marginBottom: -token2.lineWidth
                },
                "&-item": {
                    "&:hover,&:focus,&:active": {
                        zIndex: 2
                    },
                    "&[disabled]": {
                        zIndex: 0
                    }
                }
            };
        }
        function compactItemBorderVerticalRadius(prefixCls, parentCls) {
            return {
                [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
                    borderRadius: 0
                },
                [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
                    [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
                        borderEndEndRadius: 0,
                        borderEndStartRadius: 0
                    }
                },
                [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
                    [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
                        borderStartStartRadius: 0,
                        borderStartEndRadius: 0
                    }
                }
            };
        }
        function genCompactItemVerticalStyle(token2) {
            const compactCls = `${token2.componentCls}-compact-vertical`;
            return {
                [compactCls]: _extends$1(_extends$1({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
            };
        }
        const genSharedButtonStyle = token2 => {
            const {componentCls: componentCls, iconCls: iconCls} = token2;
            return {
                [componentCls]: {
                    outline: "none",
                    position: "relative",
                    display: "inline-block",
                    fontWeight: 400,
                    whiteSpace: "nowrap",
                    textAlign: "center",
                    backgroundImage: "none",
                    backgroundColor: "transparent",
                    border: `${token2.lineWidth}px ${token2.lineType} transparent`,
                    cursor: "pointer",
                    transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
                    userSelect: "none",
                    touchAction: "manipulation",
                    lineHeight: token2.lineHeight,
                    color: token2.colorText,
                    "> span": {
                        display: "inline-block"
                    },
                    [`> ${iconCls} + span, > span + ${iconCls}`]: {
                        marginInlineStart: token2.marginXS
                    },
                    "> a": {
                        color: "currentColor"
                    },
                    "&:not(:disabled)": _extends$1({}, genFocusStyle(token2)),
                    [`&-icon-only${componentCls}-compact-item`]: {
                        flex: "none"
                    },
                    [`&-compact-item${componentCls}-primary`]: {
                        [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
                            position: "relative",
                            "&:before": {
                                position: "absolute",
                                top: -token2.lineWidth,
                                insetInlineStart: -token2.lineWidth,
                                display: "inline-block",
                                width: token2.lineWidth,
                                height: `calc(100% + ${2 * token2.lineWidth}px)`,
                                backgroundColor: token2.colorPrimaryHover,
                                content: '""'
                            }
                        }
                    },
                    "&-compact-vertical-item": {
                        [`&${componentCls}-primary`]: {
                            [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
                                position: "relative",
                                "&:before": {
                                    position: "absolute",
                                    top: -token2.lineWidth,
                                    insetInlineStart: -token2.lineWidth,
                                    display: "inline-block",
                                    width: `calc(100% + ${2 * token2.lineWidth}px)`,
                                    height: token2.lineWidth,
                                    backgroundColor: token2.colorPrimaryHover,
                                    content: '""'
                                }
                            }
                        }
                    }
                }
            };
        }, genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
            "&:not(:disabled)": {
                "&:hover": hoverStyle,
                "&:active": activeStyle
            }
        }), genCircleButtonStyle = token2 => ({
            minWidth: token2.controlHeight,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            borderRadius: "50%"
        }), genRoundButtonStyle = token2 => ({
            borderRadius: token2.controlHeight,
            paddingInlineStart: token2.controlHeight / 2,
            paddingInlineEnd: token2.controlHeight / 2
        }), genDisabledStyle = token2 => ({
            cursor: "not-allowed",
            borderColor: token2.colorBorder,
            color: token2.colorTextDisabled,
            backgroundColor: token2.colorBgContainerDisabled,
            boxShadow: "none"
        }), genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
            [`&${btnCls}-background-ghost`]: _extends$1(_extends$1({
                color: textColor || void 0,
                backgroundColor: "transparent",
                borderColor: borderColor || void 0,
                boxShadow: "none"
            }, genHoverActiveButtonStyle(_extends$1({
                backgroundColor: "transparent"
            }, hoverStyle), _extends$1({
                backgroundColor: "transparent"
            }, activeStyle))), {
                "&:disabled": {
                    cursor: "not-allowed",
                    color: textColorDisabled || void 0,
                    borderColor: borderColorDisabled || void 0
                }
            })
        }), genSolidDisabledButtonStyle = token2 => ({
            "&:disabled": _extends$1({}, genDisabledStyle(token2))
        }), genSolidButtonStyle = token2 => _extends$1({}, genSolidDisabledButtonStyle(token2)), genPureDisabledButtonStyle = token2 => ({
            "&:disabled": {
                cursor: "not-allowed",
                color: token2.colorTextDisabled
            }
        }), genDefaultButtonStyle = token2 => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
            backgroundColor: token2.colorBgContainer,
            borderColor: token2.colorBorder,
            boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
        }), genHoverActiveButtonStyle({
            color: token2.colorPrimaryHover,
            borderColor: token2.colorPrimaryHover
        }, {
            color: token2.colorPrimaryActive,
            borderColor: token2.colorPrimaryActive
        })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
            [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
                color: token2.colorError,
                borderColor: token2.colorError
            }, genHoverActiveButtonStyle({
                color: token2.colorErrorHover,
                borderColor: token2.colorErrorBorderHover
            }, {
                color: token2.colorErrorActive,
                borderColor: token2.colorErrorActive
            })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
        }), genPrimaryButtonStyle = token2 => _extends$1(_extends$1(_extends$1(_extends$1(_extends$1({}, genSolidButtonStyle(token2)), {
            color: token2.colorTextLightSolid,
            backgroundColor: token2.colorPrimary,
            boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
        }), genHoverActiveButtonStyle({
            color: token2.colorTextLightSolid,
            backgroundColor: token2.colorPrimaryHover
        }, {
            color: token2.colorTextLightSolid,
            backgroundColor: token2.colorPrimaryActive
        })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
            color: token2.colorPrimaryHover,
            borderColor: token2.colorPrimaryHover
        }, {
            color: token2.colorPrimaryActive,
            borderColor: token2.colorPrimaryActive
        })), {
            [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1(_extends$1({
                backgroundColor: token2.colorError,
                boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
            }, genHoverActiveButtonStyle({
                backgroundColor: token2.colorErrorHover
            }, {
                backgroundColor: token2.colorErrorActive
            })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
                color: token2.colorErrorHover,
                borderColor: token2.colorErrorHover
            }, {
                color: token2.colorErrorActive,
                borderColor: token2.colorErrorActive
            })), genSolidDisabledButtonStyle(token2))
        }), genDashedButtonStyle = token2 => _extends$1(_extends$1({}, genDefaultButtonStyle(token2)), {
            borderStyle: "dashed"
        }), genLinkButtonStyle = token2 => _extends$1(_extends$1(_extends$1({
            color: token2.colorLink
        }, genHoverActiveButtonStyle({
            color: token2.colorLinkHover
        }, {
            color: token2.colorLinkActive
        })), genPureDisabledButtonStyle(token2)), {
            [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
                color: token2.colorError
            }, genHoverActiveButtonStyle({
                color: token2.colorErrorHover
            }, {
                color: token2.colorErrorActive
            })), genPureDisabledButtonStyle(token2))
        }), genTextButtonStyle = token2 => _extends$1(_extends$1(_extends$1({}, genHoverActiveButtonStyle({
            color: token2.colorText,
            backgroundColor: token2.colorBgTextHover
        }, {
            color: token2.colorText,
            backgroundColor: token2.colorBgTextActive
        })), genPureDisabledButtonStyle(token2)), {
            [`&${token2.componentCls}-dangerous`]: _extends$1(_extends$1({
                color: token2.colorError
            }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
                color: token2.colorErrorHover,
                backgroundColor: token2.colorErrorBg
            }, {
                color: token2.colorErrorHover,
                backgroundColor: token2.colorErrorBg
            }))
        }), genDisabledButtonStyle = token2 => _extends$1(_extends$1({}, genDisabledStyle(token2)), {
            [`&${token2.componentCls}:hover`]: _extends$1({}, genDisabledStyle(token2))
        }), genTypeButtonStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [`${componentCls}-default`]: genDefaultButtonStyle(token2),
                [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
                [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
                [`${componentCls}-link`]: genLinkButtonStyle(token2),
                [`${componentCls}-text`]: genTextButtonStyle(token2),
                [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
            };
        }, genSizeButtonStyle = function(token2) {
            let sizePrefixCls = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            const {componentCls: componentCls, iconCls: iconCls, controlHeight: controlHeight, fontSize: fontSize, lineHeight: lineHeight, lineWidth: lineWidth, borderRadius: borderRadius, buttonPaddingHorizontal: buttonPaddingHorizontal} = token2, paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth), paddingHorizontal = buttonPaddingHorizontal - lineWidth, iconOnlyCls = `${componentCls}-icon-only`;
            return [ {
                [`${componentCls}${sizePrefixCls}`]: {
                    fontSize: fontSize,
                    height: controlHeight,
                    padding: `${paddingVertical}px ${paddingHorizontal}px`,
                    borderRadius: borderRadius,
                    [`&${iconOnlyCls}`]: {
                        width: controlHeight,
                        paddingInlineStart: 0,
                        paddingInlineEnd: 0,
                        [`&${componentCls}-round`]: {
                            width: "auto"
                        },
                        "> span": {
                            transform: "scale(1.143)"
                        }
                    },
                    [`&${componentCls}-loading`]: {
                        opacity: token2.opacityLoading,
                        cursor: "default"
                    },
                    [`${componentCls}-loading-icon`]: {
                        transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
                    },
                    [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
                        marginInlineEnd: token2.marginXS
                    }
                }
            }, {
                [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
            }, {
                [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
            } ];
        }, genSizeBaseButtonStyle = token2 => genSizeButtonStyle(token2), genSizeSmallButtonStyle = token2 => {
            const smallToken = merge(token2, {
                controlHeight: token2.controlHeightSM,
                padding: token2.paddingXS,
                buttonPaddingHorizontal: 8,
                borderRadius: token2.borderRadiusSM
            });
            return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
        }, genSizeLargeButtonStyle = token2 => {
            const largeToken = merge(token2, {
                controlHeight: token2.controlHeightLG,
                fontSize: token2.fontSizeLG,
                borderRadius: token2.borderRadiusLG
            });
            return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
        }, genBlockButtonStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [componentCls]: {
                    [`&${componentCls}-block`]: {
                        width: "100%"
                    }
                }
            };
        }, useStyle$7 = genComponentStyleHook("Button", (token2 => {
            const {controlTmpOutline: controlTmpOutline, paddingContentHorizontal: paddingContentHorizontal} = token2, buttonToken = merge(token2, {
                colorOutlineDefault: controlTmpOutline,
                buttonPaddingHorizontal: paddingContentHorizontal
            });
            return [ genSharedButtonStyle(buttonToken), genSizeSmallButtonStyle(buttonToken), genSizeBaseButtonStyle(buttonToken), genSizeLargeButtonStyle(buttonToken), genBlockButtonStyle(buttonToken), genTypeButtonStyle(buttonToken), genGroupStyle(buttonToken), genCompactItemStyle(token2, {
                focus: !1
            }), genCompactItemVerticalStyle(token2) ];
        })), buttonGroupProps = () => ({
            prefixCls: String,
            size: {
                type: String
            }
        }), GroupSizeContext = createContext(), ButtonGroup = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "AButtonGroup",
            props: buttonGroupProps(),
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const {prefixCls: prefixCls, direction: direction} = useConfigInject("btn-group", props2), [, , hashId] = useToken();
                GroupSizeContext.useProvide(reactive({
                    size: computed((() => props2.size))
                }));
                const classes = computed((() => {
                    const {size: size2} = props2;
                    let sizeCls = "";
                    switch (size2) {
                      case "large":
                        sizeCls = "lg";
                        break;

                      case "small":
                        sizeCls = "sm";
                        break;

                      case "middle":
                      case void 0:
                        break;

                      default:
                        devWarning(!size2, "Button.Group", "Invalid prop `size`.");
                    }
                    return {
                        [`${prefixCls.value}`]: !0,
                        [`${prefixCls.value}-${sizeCls}`]: sizeCls,
                        [`${prefixCls.value}-rtl`]: "rtl" === direction.value,
                        [hashId.value]: !0
                    };
                }));
                return () => {
                    var _a;
                    return createVNode("div", {
                        class: classes.value
                    }, [ flattenChildren(null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots)) ]);
                };
            }
        }), rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/, isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
        function isUnBorderedButtonType(type) {
            return "text" === type || "link" === type;
        }
        const Button = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "AButton",
            inheritAttrs: !1,
            __ANT_BUTTON: !0,
            props: initDefaultProps(buttonProps(), {
                type: "default"
            }),
            slots: Object,
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs, emit: emit2, expose: expose} = _ref;
                const {prefixCls: prefixCls, autoInsertSpaceInButton: autoInsertSpaceInButton, direction: direction, size: size2} = useConfigInject("btn", props2), [wrapSSR, hashId] = useStyle$7(prefixCls), groupSizeContext = GroupSizeContext.useInject(), disabledContext = useInjectDisabled(), mergedDisabled = computed((() => {
                    var _a;
                    return null !== (_a = props2.disabled) && void 0 !== _a ? _a : disabledContext.value;
                })), buttonNodeRef = shallowRef(null), delayTimeoutRef = shallowRef(void 0);
                let isNeedInserted = !1;
                const innerLoading = shallowRef(!1), hasTwoCNChar = shallowRef(!1), autoInsertSpace = computed((() => !1 !== autoInsertSpaceInButton.value)), {compactSize: compactSize, compactItemClassnames: compactItemClassnames} = useCompactItemContext(prefixCls, direction), loadingOrDelay = computed((() => "object" == typeof props2.loading && props2.loading.delay ? props2.loading.delay || !0 : !!props2.loading));
                watch(loadingOrDelay, (val => {
                    clearTimeout(delayTimeoutRef.value), "number" == typeof loadingOrDelay.value ? delayTimeoutRef.value = setTimeout((() => {
                        innerLoading.value = val;
                    }), loadingOrDelay.value) : innerLoading.value = val;
                }), {
                    immediate: !0
                });
                const classes = computed((() => {
                    const {type: type, shape: shape = "default", ghost: ghost, block: block, danger: danger} = props2, pre = prefixCls.value, sizeClassNameMap = {
                        large: "lg",
                        small: "sm",
                        middle: void 0
                    }, sizeFullname = compactSize.value || (null == groupSizeContext ? void 0 : groupSizeContext.size) || size2.value, sizeCls = sizeFullname && sizeClassNameMap[sizeFullname] || "";
                    return [ compactItemClassnames.value, {
                        [hashId.value]: !0,
                        [`${pre}`]: !0,
                        [`${pre}-${shape}`]: "default" !== shape && shape,
                        [`${pre}-${type}`]: type,
                        [`${pre}-${sizeCls}`]: sizeCls,
                        [`${pre}-loading`]: innerLoading.value,
                        [`${pre}-background-ghost`]: ghost && !isUnBorderedButtonType(type),
                        [`${pre}-two-chinese-chars`]: hasTwoCNChar.value && autoInsertSpace.value,
                        [`${pre}-block`]: block,
                        [`${pre}-dangerous`]: !!danger,
                        [`${pre}-rtl`]: "rtl" === direction.value
                    } ];
                })), fixTwoCNChar = () => {
                    const node2 = buttonNodeRef.value;
                    if (!node2 || !1 === autoInsertSpaceInButton.value) return;
                    const buttonText = node2.textContent;
                    isNeedInserted && isTwoCNChar(buttonText) ? hasTwoCNChar.value || (hasTwoCNChar.value = !0) : hasTwoCNChar.value && (hasTwoCNChar.value = !1);
                }, handleClick = event => {
                    innerLoading.value || mergedDisabled.value ? event.preventDefault() : emit2("click", event);
                }, handleMousedown = event => {
                    emit2("mousedown", event);
                }, insertSpace = (child, needInserted) => {
                    const SPACE = needInserted ? " " : "";
                    if (child.type === Text) {
                        let text = child.children.trim();
                        return isTwoCNChar(text) && (text = text.split("").join(SPACE)), createVNode("span", null, [ text ]);
                    }
                    return child;
                };
                watchEffect((() => {
                    devWarning(!(props2.ghost && isUnBorderedButtonType(props2.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
                })), onMounted(fixTwoCNChar), onUpdated(fixTwoCNChar), onBeforeUnmount((() => {
                    delayTimeoutRef.value && clearTimeout(delayTimeoutRef.value);
                }));
                return expose({
                    focus: () => {
                        var _a;
                        null === (_a = buttonNodeRef.value) || void 0 === _a || _a.focus();
                    },
                    blur: () => {
                        var _a;
                        null === (_a = buttonNodeRef.value) || void 0 === _a || _a.blur();
                    }
                }), () => {
                    var _a, _b;
                    const {icon: icon = (null === (_a = slots.icon) || void 0 === _a ? void 0 : _a.call(slots))} = props2, children = flattenChildren(null === (_b = slots.default) || void 0 === _b ? void 0 : _b.call(slots));
                    isNeedInserted = 1 === children.length && !icon && !isUnBorderedButtonType(props2.type);
                    const {type: type, htmlType: htmlType, href: href, title: title, target: target} = props2, iconType = innerLoading.value ? "loading" : icon, buttonProps2 = _extends$1(_extends$1({}, attrs), {
                        title: title,
                        disabled: mergedDisabled.value,
                        class: [ classes.value, attrs.class, {
                            [`${prefixCls.value}-icon-only`]: 0 === children.length && !!iconType
                        } ],
                        onClick: handleClick,
                        onMousedown: handleMousedown
                    });
                    mergedDisabled.value || delete buttonProps2.disabled;
                    const iconNode = icon && !innerLoading.value ? icon : createVNode(LoadingIcon, {
                        existIcon: !!icon,
                        prefixCls: prefixCls.value,
                        loading: !!innerLoading.value
                    }, null), kids = children.map((child => insertSpace(child, isNeedInserted && autoInsertSpace.value)));
                    if (void 0 !== href) return wrapSSR(createVNode("a", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
                        href: href,
                        target: target,
                        ref: buttonNodeRef
                    }), [ iconNode, kids ]));
                    let buttonNode = createVNode("button", _objectSpread2$1(_objectSpread2$1({}, buttonProps2), {}, {
                        ref: buttonNodeRef,
                        type: htmlType
                    }), [ iconNode, kids ]);
                    if (!isUnBorderedButtonType(type)) {
                        const _buttonNode = function() {
                            return buttonNode;
                        }();
                        buttonNode = createVNode(Wave, {
                            ref: "wave",
                            disabled: !!innerLoading.value
                        }, {
                            default: () => [ _buttonNode ]
                        });
                    }
                    return wrapSSR(buttonNode);
                };
            }
        });
        function hasClass(node2, className) {
            if (node2.classList) return node2.classList.contains(className);
            return ` ${node2.className} `.indexOf(` ${className} `) > -1;
        }
        function addClass(node2, className) {
            node2.classList ? node2.classList.add(className) : hasClass(node2, className) || (node2.className = `${node2.className} ${className}`);
        }
        function removeClass(node2, className) {
            if (node2.classList) node2.classList.remove(className); else if (hasClass(node2, className)) {
                const originClass = node2.className;
                node2.className = ` ${originClass} `.replace(` ${className} `, " ");
            }
        }
        Button.Group = ButtonGroup, Button.install = function(app) {
            return app.component(Button.name, Button), app.component(ButtonGroup.name, ButtonGroup), 
            app;
        };
        const collapseMotion = function() {
            let name = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "ant-motion-collapse";
            return {
                name: name,
                appear: !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                css: !0,
                onBeforeEnter: node2 => {
                    node2.style.height = "0px", node2.style.opacity = "0", addClass(node2, name);
                },
                onEnter: node2 => {
                    nextTick((() => {
                        node2.style.height = `${node2.scrollHeight}px`, node2.style.opacity = "1";
                    }));
                },
                onAfterEnter: node2 => {
                    node2 && (removeClass(node2, name), node2.style.height = null, node2.style.opacity = null);
                },
                onBeforeLeave: node2 => {
                    addClass(node2, name), node2.style.height = `${node2.offsetHeight}px`, node2.style.opacity = null;
                },
                onLeave: node2 => {
                    setTimeout((() => {
                        node2.style.height = "0px", node2.style.opacity = "0";
                    }));
                },
                onAfterLeave: node2 => {
                    node2 && (removeClass(node2, name), node2.style && (node2.style.height = null, node2.style.opacity = null));
                }
            };
        };
        var __rest$9 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const VcCheckbox = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "Checkbox",
            inheritAttrs: !1,
            props: initDefaultProps({
                prefixCls: String,
                name: String,
                id: String,
                type: String,
                defaultChecked: {
                    type: [ Boolean, Number ],
                    default: void 0
                },
                checked: {
                    type: [ Boolean, Number ],
                    default: void 0
                },
                disabled: Boolean,
                tabindex: {
                    type: [ Number, String ]
                },
                readonly: Boolean,
                autofocus: Boolean,
                value: PropTypes.any,
                required: Boolean
            }, {
                prefixCls: "rc-checkbox",
                type: "checkbox",
                defaultChecked: !1
            }),
            emits: [ "click", "change" ],
            setup(props2, _ref) {
                let {attrs: attrs, emit: emit2, expose: expose} = _ref;
                const checked = ref(void 0 === props2.checked ? props2.defaultChecked : props2.checked), inputRef = ref();
                watch((() => props2.checked), (() => {
                    checked.value = props2.checked;
                })), expose({
                    focus() {
                        var _a;
                        null === (_a = inputRef.value) || void 0 === _a || _a.focus();
                    },
                    blur() {
                        var _a;
                        null === (_a = inputRef.value) || void 0 === _a || _a.blur();
                    }
                });
                const eventShiftKey = ref(), handleChange = e2 => {
                    if (props2.disabled) return;
                    void 0 === props2.checked && (checked.value = e2.target.checked), e2.shiftKey = eventShiftKey.value;
                    const eventObj = {
                        target: _extends$1(_extends$1({}, props2), {
                            checked: e2.target.checked
                        }),
                        stopPropagation() {
                            e2.stopPropagation();
                        },
                        preventDefault() {
                            e2.preventDefault();
                        },
                        nativeEvent: e2
                    };
                    void 0 !== props2.checked && (inputRef.value.checked = !!props2.checked), emit2("change", eventObj), 
                    eventShiftKey.value = !1;
                }, onClick = e2 => {
                    emit2("click", e2), eventShiftKey.value = e2.shiftKey;
                };
                return () => {
                    const {prefixCls: prefixCls, name: name, id: id, type: type, disabled: disabled, readonly: readonly2, tabindex: tabindex, autofocus: autofocus, value: value, required: required} = props2, others = __rest$9(props2, [ "prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required" ]), {class: className, onFocus: onFocus, onBlur: onBlur, onKeydown: onKeydown, onKeypress: onKeypress, onKeyup: onKeyup} = attrs, othersAndAttrs = _extends$1(_extends$1({}, others), attrs), globalProps = Object.keys(othersAndAttrs).reduce(((prev2, key2) => ((key2.startsWith("data-") || key2.startsWith("aria-") || "role" === key2) && (prev2[key2] = othersAndAttrs[key2]), 
                    prev2)), {}), classString = classNames(prefixCls, className, {
                        [`${prefixCls}-checked`]: checked.value,
                        [`${prefixCls}-disabled`]: disabled
                    }), inputProps2 = _extends$1(_extends$1({
                        name: name,
                        id: id,
                        type: type,
                        readonly: readonly2,
                        disabled: disabled,
                        tabindex: tabindex,
                        class: `${prefixCls}-input`,
                        checked: !!checked.value,
                        autofocus: autofocus,
                        value: value
                    }, globalProps), {
                        onChange: handleChange,
                        onClick: onClick,
                        onFocus: onFocus,
                        onBlur: onBlur,
                        onKeydown: onKeydown,
                        onKeypress: onKeypress,
                        onKeyup: onKeyup,
                        required: required
                    });
                    return createVNode("span", {
                        class: classString
                    }, [ createVNode("input", _objectSpread2$1({
                        ref: inputRef
                    }, inputProps2), null), createVNode("span", {
                        class: `${prefixCls}-inner`
                    }, null) ]);
                };
            }
        }), radioGroupContextKey = Symbol("radioGroupContextKey"), useProvideRadioGroupContext = props2 => {
            provide(radioGroupContextKey, props2);
        }, useInjectRadioGroupContext = () => inject(radioGroupContextKey, void 0), radioOptionTypeContextKey = Symbol("radioOptionTypeContextKey"), useProvideRadioOptionTypeContext = props2 => {
            provide(radioOptionTypeContextKey, props2);
        }, useInjectRadioOptionTypeContext = () => inject(radioOptionTypeContextKey, void 0), antRadioEffect = new Keyframe("antRadioEffect", {
            "0%": {
                transform: "scale(1)",
                opacity: .5
            },
            "100%": {
                transform: "scale(1.6)",
                opacity: 0
            }
        }), getGroupRadioStyle = token2 => {
            const {componentCls: componentCls, antCls: antCls} = token2, groupPrefixCls = `${componentCls}-group`;
            return {
                [groupPrefixCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    display: "inline-block",
                    fontSize: 0,
                    [`&${groupPrefixCls}-rtl`]: {
                        direction: "rtl"
                    },
                    [`${antCls}-badge ${antCls}-badge-count`]: {
                        zIndex: 1
                    },
                    [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
                        borderInlineStart: "none"
                    }
                })
            };
        }, getRadioBasicStyle = token2 => {
            const {componentCls: componentCls, radioWrapperMarginRight: radioWrapperMarginRight, radioCheckedColor: radioCheckedColor, radioSize: radioSize, motionDurationSlow: motionDurationSlow, motionDurationMid: motionDurationMid, motionEaseInOut: motionEaseInOut, motionEaseInOutCirc: motionEaseInOutCirc, radioButtonBg: radioButtonBg, colorBorder: colorBorder, lineWidth: lineWidth, radioDotSize: radioDotSize, colorBgContainerDisabled: colorBgContainerDisabled, colorTextDisabled: colorTextDisabled, paddingXS: paddingXS, radioDotDisabledColor: radioDotDisabledColor, lineType: lineType, radioDotDisabledSize: radioDotDisabledSize, wireframe: wireframe, colorWhite: colorWhite} = token2, radioInnerPrefixCls = `${componentCls}-inner`;
            return {
                [`${componentCls}-wrapper`]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    position: "relative",
                    display: "inline-flex",
                    alignItems: "baseline",
                    marginInlineStart: 0,
                    marginInlineEnd: radioWrapperMarginRight,
                    cursor: "pointer",
                    [`&${componentCls}-wrapper-rtl`]: {
                        direction: "rtl"
                    },
                    "&-disabled": {
                        cursor: "not-allowed",
                        color: token2.colorTextDisabled
                    },
                    "&::after": {
                        display: "inline-block",
                        width: 0,
                        overflow: "hidden",
                        content: '"\\a0"'
                    },
                    [`${componentCls}-checked::after`]: {
                        position: "absolute",
                        insetBlockStart: 0,
                        insetInlineStart: 0,
                        width: "100%",
                        height: "100%",
                        border: `${lineWidth}px ${lineType} ${radioCheckedColor}`,
                        borderRadius: "50%",
                        visibility: "hidden",
                        animationName: antRadioEffect,
                        animationDuration: motionDurationSlow,
                        animationTimingFunction: motionEaseInOut,
                        animationFillMode: "both",
                        content: '""'
                    },
                    [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
                        position: "relative",
                        display: "inline-block",
                        outline: "none",
                        cursor: "pointer",
                        alignSelf: "center"
                    }),
                    [`${componentCls}-wrapper:hover &,\n        &:hover ${radioInnerPrefixCls}`]: {
                        borderColor: radioCheckedColor
                    },
                    [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: _extends$1({}, genFocusOutline(token2)),
                    [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
                        visibility: "visible"
                    },
                    [`${componentCls}-inner`]: {
                        "&::after": {
                            boxSizing: "border-box",
                            position: "absolute",
                            insetBlockStart: "50%",
                            insetInlineStart: "50%",
                            display: "block",
                            width: radioSize,
                            height: radioSize,
                            marginBlockStart: radioSize / -2,
                            marginInlineStart: radioSize / -2,
                            backgroundColor: wireframe ? radioCheckedColor : colorWhite,
                            borderBlockStart: 0,
                            borderInlineStart: 0,
                            borderRadius: radioSize,
                            transform: "scale(0)",
                            opacity: 0,
                            transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
                            content: '""'
                        },
                        boxSizing: "border-box",
                        position: "relative",
                        insetBlockStart: 0,
                        insetInlineStart: 0,
                        display: "block",
                        width: radioSize,
                        height: radioSize,
                        backgroundColor: radioButtonBg,
                        borderColor: colorBorder,
                        borderStyle: "solid",
                        borderWidth: lineWidth,
                        borderRadius: "50%",
                        transition: `all ${motionDurationMid}`
                    },
                    [`${componentCls}-input`]: {
                        position: "absolute",
                        insetBlockStart: 0,
                        insetInlineEnd: 0,
                        insetBlockEnd: 0,
                        insetInlineStart: 0,
                        zIndex: 1,
                        cursor: "pointer",
                        opacity: 0
                    },
                    [`${componentCls}-checked`]: {
                        [radioInnerPrefixCls]: {
                            borderColor: radioCheckedColor,
                            backgroundColor: wireframe ? radioButtonBg : radioCheckedColor,
                            "&::after": {
                                transform: `scale(${radioDotSize / radioSize})`,
                                opacity: 1,
                                transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
                            }
                        }
                    },
                    [`${componentCls}-disabled`]: {
                        cursor: "not-allowed",
                        [radioInnerPrefixCls]: {
                            backgroundColor: colorBgContainerDisabled,
                            borderColor: colorBorder,
                            cursor: "not-allowed",
                            "&::after": {
                                backgroundColor: radioDotDisabledColor
                            }
                        },
                        [`${componentCls}-input`]: {
                            cursor: "not-allowed"
                        },
                        [`${componentCls}-disabled + span`]: {
                            color: colorTextDisabled,
                            cursor: "not-allowed"
                        },
                        [`&${componentCls}-checked`]: {
                            [radioInnerPrefixCls]: {
                                "&::after": {
                                    transform: `scale(${radioDotDisabledSize / radioSize})`
                                }
                            }
                        }
                    },
                    [`span${componentCls} + *`]: {
                        paddingInlineStart: paddingXS,
                        paddingInlineEnd: paddingXS
                    }
                })
            };
        }, getRadioButtonStyle = token2 => {
            const {radioButtonColor: radioButtonColor, controlHeight: controlHeight, componentCls: componentCls, lineWidth: lineWidth, lineType: lineType, colorBorder: colorBorder, motionDurationSlow: motionDurationSlow, motionDurationMid: motionDurationMid, radioButtonPaddingHorizontal: radioButtonPaddingHorizontal, fontSize: fontSize, radioButtonBg: radioButtonBg, fontSizeLG: fontSizeLG, controlHeightLG: controlHeightLG, controlHeightSM: controlHeightSM, paddingXS: paddingXS, borderRadius: borderRadius, borderRadiusSM: borderRadiusSM, borderRadiusLG: borderRadiusLG, radioCheckedColor: radioCheckedColor, radioButtonCheckedBg: radioButtonCheckedBg, radioButtonHoverColor: radioButtonHoverColor, radioButtonActiveColor: radioButtonActiveColor, radioSolidCheckedColor: radioSolidCheckedColor, colorTextDisabled: colorTextDisabled, colorBgContainerDisabled: colorBgContainerDisabled, radioDisabledButtonCheckedColor: radioDisabledButtonCheckedColor, radioDisabledButtonCheckedBg: radioDisabledButtonCheckedBg} = token2;
            return {
                [`${componentCls}-button-wrapper`]: {
                    position: "relative",
                    display: "inline-block",
                    height: controlHeight,
                    margin: 0,
                    paddingInline: radioButtonPaddingHorizontal,
                    paddingBlock: 0,
                    color: radioButtonColor,
                    fontSize: fontSize,
                    lineHeight: controlHeight - 2 * lineWidth + "px",
                    background: radioButtonBg,
                    border: `${lineWidth}px ${lineType} ${colorBorder}`,
                    borderBlockStartWidth: lineWidth + .02,
                    borderInlineStartWidth: 0,
                    borderInlineEndWidth: lineWidth,
                    cursor: "pointer",
                    transition: [ `color ${motionDurationMid}`, `background ${motionDurationMid}`, `border-color ${motionDurationMid}`, `box-shadow ${motionDurationMid}` ].join(","),
                    a: {
                        color: radioButtonColor
                    },
                    [`> ${componentCls}-button`]: {
                        position: "absolute",
                        insetBlockStart: 0,
                        insetInlineStart: 0,
                        zIndex: -1,
                        width: "100%",
                        height: "100%"
                    },
                    "&:not(:first-child)": {
                        "&::before": {
                            position: "absolute",
                            insetBlockStart: -lineWidth,
                            insetInlineStart: -lineWidth,
                            display: "block",
                            boxSizing: "content-box",
                            width: 1,
                            height: "100%",
                            paddingBlock: lineWidth,
                            paddingInline: 0,
                            backgroundColor: colorBorder,
                            transition: `background-color ${motionDurationSlow}`,
                            content: '""'
                        }
                    },
                    "&:first-child": {
                        borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
                        borderStartStartRadius: borderRadius,
                        borderEndStartRadius: borderRadius
                    },
                    "&:last-child": {
                        borderStartEndRadius: borderRadius,
                        borderEndEndRadius: borderRadius
                    },
                    "&:first-child:last-child": {
                        borderRadius: borderRadius
                    },
                    [`${componentCls}-group-large &`]: {
                        height: controlHeightLG,
                        fontSize: fontSizeLG,
                        lineHeight: controlHeightLG - 2 * lineWidth + "px",
                        "&:first-child": {
                            borderStartStartRadius: borderRadiusLG,
                            borderEndStartRadius: borderRadiusLG
                        },
                        "&:last-child": {
                            borderStartEndRadius: borderRadiusLG,
                            borderEndEndRadius: borderRadiusLG
                        }
                    },
                    [`${componentCls}-group-small &`]: {
                        height: controlHeightSM,
                        paddingInline: paddingXS - lineWidth,
                        paddingBlock: 0,
                        lineHeight: controlHeightSM - 2 * lineWidth + "px",
                        "&:first-child": {
                            borderStartStartRadius: borderRadiusSM,
                            borderEndStartRadius: borderRadiusSM
                        },
                        "&:last-child": {
                            borderStartEndRadius: borderRadiusSM,
                            borderEndEndRadius: borderRadiusSM
                        }
                    },
                    "&:hover": {
                        position: "relative",
                        color: radioCheckedColor
                    },
                    "&:has(:focus-visible)": _extends$1({}, genFocusOutline(token2)),
                    [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
                        width: 0,
                        height: 0,
                        opacity: 0,
                        pointerEvents: "none"
                    },
                    [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
                        zIndex: 1,
                        color: radioCheckedColor,
                        background: radioButtonCheckedBg,
                        borderColor: radioCheckedColor,
                        "&::before": {
                            backgroundColor: radioCheckedColor
                        },
                        "&:first-child": {
                            borderColor: radioCheckedColor
                        },
                        "&:hover": {
                            color: radioButtonHoverColor,
                            borderColor: radioButtonHoverColor,
                            "&::before": {
                                backgroundColor: radioButtonHoverColor
                            }
                        },
                        "&:active": {
                            color: radioButtonActiveColor,
                            borderColor: radioButtonActiveColor,
                            "&::before": {
                                backgroundColor: radioButtonActiveColor
                            }
                        }
                    },
                    [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
                        color: radioSolidCheckedColor,
                        background: radioCheckedColor,
                        borderColor: radioCheckedColor,
                        "&:hover": {
                            color: radioSolidCheckedColor,
                            background: radioButtonHoverColor,
                            borderColor: radioButtonHoverColor
                        },
                        "&:active": {
                            color: radioSolidCheckedColor,
                            background: radioButtonActiveColor,
                            borderColor: radioButtonActiveColor
                        }
                    },
                    "&-disabled": {
                        color: colorTextDisabled,
                        backgroundColor: colorBgContainerDisabled,
                        borderColor: colorBorder,
                        cursor: "not-allowed",
                        "&:first-child, &:hover": {
                            color: colorTextDisabled,
                            backgroundColor: colorBgContainerDisabled,
                            borderColor: colorBorder
                        }
                    },
                    [`&-disabled${componentCls}-button-wrapper-checked`]: {
                        color: radioDisabledButtonCheckedColor,
                        backgroundColor: radioDisabledButtonCheckedBg,
                        borderColor: colorBorder,
                        boxShadow: "none"
                    }
                }
            };
        }, useStyle$6 = genComponentStyleHook("Radio", (token2 => {
            const {padding: padding, lineWidth: lineWidth, controlItemBgActiveDisabled: controlItemBgActiveDisabled, colorTextDisabled: colorTextDisabled, colorBgContainer: colorBgContainer, fontSizeLG: fontSizeLG, controlOutline: controlOutline, colorPrimaryHover: colorPrimaryHover, colorPrimaryActive: colorPrimaryActive, colorText: colorText, colorPrimary: colorPrimary, marginXS: marginXS, controlOutlineWidth: controlOutlineWidth, colorTextLightSolid: colorTextLightSolid, wireframe: wireframe} = token2, radioFocusShadow = `0 0 0 ${controlOutlineWidth}px ${controlOutline}`, dotPadding = 4, radioDotDisabledSize = fontSizeLG - 2 * dotPadding, radioToken = merge(token2, {
                radioFocusShadow: radioFocusShadow,
                radioButtonFocusShadow: radioFocusShadow,
                radioSize: fontSizeLG,
                radioDotSize: wireframe ? radioDotDisabledSize : fontSizeLG - 2 * (dotPadding + lineWidth),
                radioDotDisabledSize: radioDotDisabledSize,
                radioCheckedColor: colorPrimary,
                radioDotDisabledColor: colorTextDisabled,
                radioSolidCheckedColor: colorTextLightSolid,
                radioButtonBg: colorBgContainer,
                radioButtonCheckedBg: colorBgContainer,
                radioButtonColor: colorText,
                radioButtonHoverColor: colorPrimaryHover,
                radioButtonActiveColor: colorPrimaryActive,
                radioButtonPaddingHorizontal: padding - lineWidth,
                radioDisabledButtonCheckedBg: controlItemBgActiveDisabled,
                radioDisabledButtonCheckedColor: colorTextDisabled,
                radioWrapperMarginRight: marginXS
            });
            return [ getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken) ];
        }));
        var __rest$8 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const radioProps = () => ({
            prefixCls: String,
            checked: booleanType(),
            disabled: booleanType(),
            isGroup: booleanType(),
            value: PropTypes.any,
            name: String,
            id: String,
            autofocus: booleanType(),
            onChange: functionType(),
            onFocus: functionType(),
            onBlur: functionType(),
            onClick: functionType(),
            "onUpdate:checked": functionType(),
            "onUpdate:value": functionType()
        }), Radio = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ARadio",
            inheritAttrs: !1,
            props: radioProps(),
            setup(props2, _ref) {
                let {emit: emit2, expose: expose, slots: slots, attrs: attrs} = _ref;
                const formItemContext = useInjectFormItemContext(), formItemInputContext = FormItemInputContext.useInject(), radioOptionTypeContext = useInjectRadioOptionTypeContext(), radioGroupContext = useInjectRadioGroupContext(), disabledContext = useInjectDisabled(), mergedDisabled = computed((() => {
                    var _a;
                    return null !== (_a = disabled.value) && void 0 !== _a ? _a : disabledContext.value;
                })), vcCheckbox = ref(), {prefixCls: radioPrefixCls, direction: direction, disabled: disabled} = useConfigInject("radio", props2), prefixCls = computed((() => "button" === (null == radioGroupContext ? void 0 : radioGroupContext.optionType.value) || "button" === radioOptionTypeContext ? `${radioPrefixCls.value}-button` : radioPrefixCls.value)), contextDisabled = useInjectDisabled(), [wrapSSR, hashId] = useStyle$6(radioPrefixCls);
                expose({
                    focus: () => {
                        vcCheckbox.value.focus();
                    },
                    blur: () => {
                        vcCheckbox.value.blur();
                    }
                });
                const handleChange = event => {
                    const targetChecked = event.target.checked;
                    emit2("update:checked", targetChecked), emit2("update:value", targetChecked), emit2("change", event), 
                    formItemContext.onFieldChange();
                }, onChange = e2 => {
                    emit2("change", e2), radioGroupContext && radioGroupContext.onChange && radioGroupContext.onChange(e2);
                };
                return () => {
                    var _a;
                    const radioGroup = radioGroupContext, {prefixCls: customizePrefixCls, id: id = formItemContext.id.value} = props2, restProps = __rest$8(props2, [ "prefixCls", "id" ]), rProps = _extends$1(_extends$1({
                        prefixCls: prefixCls.value,
                        id: id
                    }, omit(restProps, [ "onUpdate:checked", "onUpdate:value" ])), {
                        disabled: null !== (_a = disabled.value) && void 0 !== _a ? _a : contextDisabled.value
                    });
                    radioGroup ? (rProps.name = radioGroup.name.value, rProps.onChange = onChange, rProps.checked = props2.value === radioGroup.value.value, 
                    rProps.disabled = mergedDisabled.value || radioGroup.disabled.value) : rProps.onChange = handleChange;
                    const wrapperClassString = classNames({
                        [`${prefixCls.value}-wrapper`]: !0,
                        [`${prefixCls.value}-wrapper-checked`]: rProps.checked,
                        [`${prefixCls.value}-wrapper-disabled`]: rProps.disabled,
                        [`${prefixCls.value}-wrapper-rtl`]: "rtl" === direction.value,
                        [`${prefixCls.value}-wrapper-in-form-item`]: formItemInputContext.isFormItemInput
                    }, attrs.class, hashId.value);
                    return wrapSSR(createVNode("label", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: wrapperClassString
                    }), [ createVNode(VcCheckbox, _objectSpread2$1(_objectSpread2$1({}, rProps), {}, {
                        type: "radio",
                        ref: vcCheckbox
                    }), null), slots.default && createVNode("span", null, [ slots.default() ]) ]));
                };
            }
        }), RadioGroup = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ARadioGroup",
            inheritAttrs: !1,
            props: (() => ({
                prefixCls: String,
                value: PropTypes.any,
                size: stringType(),
                options: arrayType(),
                disabled: booleanType(),
                name: String,
                buttonStyle: stringType("outline"),
                id: String,
                optionType: stringType("default"),
                onChange: functionType(),
                "onUpdate:value": functionType()
            }))(),
            setup(props2, _ref) {
                let {slots: slots, emit: emit2, attrs: attrs} = _ref;
                const formItemContext = useInjectFormItemContext(), {prefixCls: prefixCls, direction: direction, size: size2} = useConfigInject("radio", props2), [wrapSSR, hashId] = useStyle$6(prefixCls), stateValue = ref(props2.value), updatingValue = ref(!1);
                watch((() => props2.value), (val => {
                    stateValue.value = val, updatingValue.value = !1;
                }));
                return useProvideRadioGroupContext({
                    onChange: ev => {
                        const lastValue = stateValue.value, {value: value} = ev.target;
                        "value" in props2 || (stateValue.value = value), updatingValue.value || value === lastValue || (updatingValue.value = !0, 
                        emit2("update:value", value), emit2("change", ev), formItemContext.onFieldChange()), 
                        nextTick((() => {
                            updatingValue.value = !1;
                        }));
                    },
                    value: stateValue,
                    disabled: computed((() => props2.disabled)),
                    name: computed((() => props2.name)),
                    optionType: computed((() => props2.optionType))
                }), () => {
                    var _a;
                    const {options: options, buttonStyle: buttonStyle, id: id = formItemContext.id.value} = props2, groupPrefixCls = `${prefixCls.value}-group`, classString = classNames(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
                        [`${groupPrefixCls}-${size2.value}`]: size2.value,
                        [`${groupPrefixCls}-rtl`]: "rtl" === direction.value
                    }, attrs.class, hashId.value);
                    let children = null;
                    return children = options && options.length > 0 ? options.map((option => {
                        if ("string" == typeof option || "number" == typeof option) return createVNode(Radio, {
                            key: option,
                            prefixCls: prefixCls.value,
                            disabled: props2.disabled,
                            value: option,
                            checked: stateValue.value === option
                        }, {
                            default: () => [ option ]
                        });
                        const {value: value, disabled: disabled, label: label} = option;
                        return createVNode(Radio, {
                            key: `radio-group-value-options-${value}`,
                            prefixCls: prefixCls.value,
                            disabled: disabled || props2.disabled,
                            value: value,
                            checked: stateValue.value === value
                        }, {
                            default: () => [ label ]
                        });
                    })) : null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots), 
                    wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: classString,
                        id: id
                    }), [ children ]));
                };
            }
        }), RadioButton = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ARadioButton",
            inheritAttrs: !1,
            props: radioProps(),
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs} = _ref;
                const {prefixCls: prefixCls} = useConfigInject("radio", props2);
                return useProvideRadioOptionTypeContext("button"), () => {
                    var _a;
                    return createVNode(Radio, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, attrs), props2), {}, {
                        prefixCls: prefixCls.value
                    }), {
                        default: () => [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]
                    });
                };
            }
        });
        Radio.Group = RadioGroup, Radio.Button = RadioButton, Radio.install = function(app) {
            return app.component(Radio.name, Radio), app.component(Radio.Group.name, Radio.Group), 
            app.component(Radio.Button.name, Radio.Button), app;
        };
        const canUseDocElement = () => canUseDom$1() && window.document.documentElement;
        let flexGapSupported;
        const detectFlexGapSupported = () => {
            if (!canUseDocElement()) return !1;
            if (void 0 !== flexGapSupported) return flexGapSupported;
            const flex = document.createElement("div");
            return flex.style.display = "flex", flex.style.flexDirection = "column", flex.style.rowGap = "1px", 
            flex.appendChild(document.createElement("div")), flex.appendChild(document.createElement("div")), 
            document.body.appendChild(flex), flexGapSupported = 1 === flex.scrollHeight, document.body.removeChild(flex), 
            flexGapSupported;
        }, useFlexGapSupport = () => {
            const flexible = shallowRef(!1);
            return onMounted((() => {
                flexible.value = detectFlexGapSupported();
            })), flexible;
        }, RowContextKey = Symbol("rowContextKey"), useProvideRow = state => {
            provide(RowContextKey, state);
        }, useInjectRow = () => inject(RowContextKey, {
            gutter: computed((() => {})),
            wrap: computed((() => {})),
            supportFlexGap: computed((() => {}))
        }), genGridRowStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [componentCls]: {
                    display: "flex",
                    flexFlow: "row wrap",
                    minWidth: 0,
                    "&::before, &::after": {
                        display: "flex"
                    },
                    "&-no-wrap": {
                        flexWrap: "nowrap"
                    },
                    "&-start": {
                        justifyContent: "flex-start"
                    },
                    "&-center": {
                        justifyContent: "center"
                    },
                    "&-end": {
                        justifyContent: "flex-end"
                    },
                    "&-space-between": {
                        justifyContent: "space-between"
                    },
                    "&-space-around ": {
                        justifyContent: "space-around"
                    },
                    "&-space-evenly ": {
                        justifyContent: "space-evenly"
                    },
                    "&-top": {
                        alignItems: "flex-start"
                    },
                    "&-middle": {
                        alignItems: "center"
                    },
                    "&-bottom": {
                        alignItems: "flex-end"
                    }
                }
            };
        }, genGridColStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [componentCls]: {
                    position: "relative",
                    maxWidth: "100%",
                    minHeight: 1
                }
            };
        }, genLoopGridColumnsStyle = (token2, sizeCls) => {
            const {componentCls: componentCls, gridColumns: gridColumns} = token2, gridColumnsStyle = {};
            for (let i2 = gridColumns; i2 >= 0; i2--) 0 === i2 ? (gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
                display: "none"
            }, gridColumnsStyle[`${componentCls}-push-${i2}`] = {
                insetInlineStart: "auto"
            }, gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
                insetInlineEnd: "auto"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
                insetInlineStart: "auto"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
                insetInlineEnd: "auto"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
                marginInlineEnd: 0
            }, gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
                order: 0
            }) : (gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
                display: "block",
                flex: `0 0 ${i2 / gridColumns * 100}%`,
                maxWidth: i2 / gridColumns * 100 + "%"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
                insetInlineStart: i2 / gridColumns * 100 + "%"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
                insetInlineEnd: i2 / gridColumns * 100 + "%"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
                marginInlineStart: i2 / gridColumns * 100 + "%"
            }, gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
                order: i2
            });
            return gridColumnsStyle;
        }, genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls), genGridMediaStyle = (token2, screenSize, sizeCls) => ({
            [`@media (min-width: ${screenSize}px)`]: _extends$1({}, genGridStyle(token2, sizeCls))
        }), useRowStyle = genComponentStyleHook("Grid", (token2 => [ genGridRowStyle(token2) ])), useColStyle = genComponentStyleHook("Grid", (token2 => {
            const gridToken = merge(token2, {
                gridColumns: 24
            }), gridMediaSizesMap = {
                "-sm": gridToken.screenSMMin,
                "-md": gridToken.screenMDMin,
                "-lg": gridToken.screenLGMin,
                "-xl": gridToken.screenXLMin,
                "-xxl": gridToken.screenXXLMin
            };
            return [ genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key2 => genGridMediaStyle(gridToken, gridMediaSizesMap[key2], key2))).reduce(((pre, cur) => _extends$1(_extends$1({}, pre), cur)), {}) ];
        })), ARow = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ARow",
            inheritAttrs: !1,
            props: (() => ({
                align: someType([ String, Object ]),
                justify: someType([ String, Object ]),
                prefixCls: String,
                gutter: someType([ Number, Array, Object ], 0),
                wrap: {
                    type: Boolean,
                    default: void 0
                }
            }))(),
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs} = _ref;
                const {prefixCls: prefixCls, direction: direction} = useConfigInject("row", props2), [wrapSSR, hashId] = useRowStyle(prefixCls);
                let token2;
                const responsiveObserve = useResponsiveObserver(), screens = ref({
                    xs: !0,
                    sm: !0,
                    md: !0,
                    lg: !0,
                    xl: !0,
                    xxl: !0
                }), curScreens = ref({
                    xs: !1,
                    sm: !1,
                    md: !1,
                    lg: !1,
                    xl: !1,
                    xxl: !1
                }), mergePropsByScreen = oriProp => computed((() => {
                    if ("string" == typeof props2[oriProp]) return props2[oriProp];
                    if ("object" != typeof props2[oriProp]) return "";
                    for (let i2 = 0; i2 < responsiveArray.length; i2++) {
                        const breakpoint = responsiveArray[i2];
                        if (!curScreens.value[breakpoint]) continue;
                        const curVal = props2[oriProp][breakpoint];
                        if (void 0 !== curVal) return curVal;
                    }
                    return "";
                })), mergeAlign = mergePropsByScreen("align"), mergeJustify = mergePropsByScreen("justify"), supportFlexGap = useFlexGapSupport();
                onMounted((() => {
                    token2 = responsiveObserve.value.subscribe((screen => {
                        curScreens.value = screen;
                        const currentGutter = props2.gutter || 0;
                        (!Array.isArray(currentGutter) && "object" == typeof currentGutter || Array.isArray(currentGutter) && ("object" == typeof currentGutter[0] || "object" == typeof currentGutter[1])) && (screens.value = screen);
                    }));
                })), onBeforeUnmount((() => {
                    responsiveObserve.value.unsubscribe(token2);
                }));
                const gutter = computed((() => {
                    const results = [ void 0, void 0 ], {gutter: gutter2 = 0} = props2;
                    return (Array.isArray(gutter2) ? gutter2 : [ gutter2, void 0 ]).forEach(((g2, index2) => {
                        if ("object" == typeof g2) for (let i2 = 0; i2 < responsiveArray.length; i2++) {
                            const breakpoint = responsiveArray[i2];
                            if (screens.value[breakpoint] && void 0 !== g2[breakpoint]) {
                                results[index2] = g2[breakpoint];
                                break;
                            }
                        } else results[index2] = g2;
                    })), results;
                }));
                useProvideRow({
                    gutter: gutter,
                    supportFlexGap: supportFlexGap,
                    wrap: computed((() => props2.wrap))
                });
                const classes = computed((() => classNames(prefixCls.value, {
                    [`${prefixCls.value}-no-wrap`]: !1 === props2.wrap,
                    [`${prefixCls.value}-${mergeJustify.value}`]: mergeJustify.value,
                    [`${prefixCls.value}-${mergeAlign.value}`]: mergeAlign.value,
                    [`${prefixCls.value}-rtl`]: "rtl" === direction.value
                }, attrs.class, hashId.value))), rowStyle = computed((() => {
                    const gt = gutter.value, style = {}, horizontalGutter = null != gt[0] && gt[0] > 0 ? gt[0] / -2 + "px" : void 0, verticalGutter = null != gt[1] && gt[1] > 0 ? gt[1] / -2 + "px" : void 0;
                    return horizontalGutter && (style.marginLeft = horizontalGutter, style.marginRight = horizontalGutter), 
                    supportFlexGap.value ? style.rowGap = `${gt[1]}px` : verticalGutter && (style.marginTop = verticalGutter, 
                    style.marginBottom = verticalGutter), style;
                }));
                return () => {
                    var _a;
                    return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: classes.value,
                        style: _extends$1(_extends$1({}, rowStyle.value), attrs.style)
                    }), [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]));
                };
            }
        });
        function _extends() {
            return _extends = Object.assign ? Object.assign.bind() : function(target) {
                for (var i2 = 1; i2 < arguments.length; i2++) {
                    var source = arguments[i2];
                    for (var key2 in source) Object.prototype.hasOwnProperty.call(source, key2) && (target[key2] = source[key2]);
                }
                return target;
            }, _extends.apply(this, arguments);
        }
        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, 
            _setPrototypeOf(subClass, superClass);
        }
        function _getPrototypeOf(o2) {
            return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
                return o22.__proto__ || Object.getPrototypeOf(o22);
            })(o2);
        }
        function _setPrototypeOf(o2, p2) {
            return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
                return o22.__proto__ = p22, o22;
            })(o2, p2);
        }
        function _isNativeReflectConstruct() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                !0;
            } catch (e2) {
                return !1;
            }
        }
        function _construct(Parent, args, Class) {
            return (_construct = _isNativeReflectConstruct() ? Reflect.construct.bind() : function _construct2(Parent2, args2, Class2) {
                var a2 = [ null ];
                a2.push.apply(a2, args2);
                var instance = new (Function.bind.apply(Parent2, a2));
                return Class2 && _setPrototypeOf(instance, Class2.prototype), instance;
            }).apply(null, arguments);
        }
        function _isNativeFunction(fn) {
            return -1 !== Function.toString.call(fn).indexOf("[native code]");
        }
        function _wrapNativeSuper(Class) {
            var _cache = "function" == typeof Map ? new Map : void 0;
            return _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
                if (null === Class2 || !_isNativeFunction(Class2)) return Class2;
                if ("function" != typeof Class2) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== _cache) {
                    if (_cache.has(Class2)) return _cache.get(Class2);
                    _cache.set(Class2, Wrapper);
                }
                function Wrapper() {
                    return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
                }
                return Wrapper.prototype = Object.create(Class2.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), _setPrototypeOf(Wrapper, Class2);
            }, _wrapNativeSuper(Class);
        }
        var formatRegExp = /%[sdj%]/g, warning = function warning2() {};
        function convertFieldsError(errors) {
            if (!errors || !errors.length) return null;
            var fields = {};
            return errors.forEach((function(error) {
                var field = error.field;
                fields[field] = fields[field] || [], fields[field].push(error);
            })), fields;
        }
        function format(template) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
            var i2 = 0, len = args.length;
            return "function" == typeof template ? template.apply(null, args) : "string" == typeof template ? template.replace(formatRegExp, (function(x2) {
                if ("%%" === x2) return "%";
                if (i2 >= len) return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i2++]);

                  case "%d":
                    return Number(args[i2++]);

                  case "%j":
                    try {
                        return JSON.stringify(args[i2++]);
                    } catch (_2) {
                        return "[Circular]";
                    }
                    break;

                  default:
                    return x2;
                }
            })) : template;
        }
        function isNativeStringType(type4) {
            return "string" === type4 || "url" === type4 || "hex" === type4 || "email" === type4 || "date" === type4 || "pattern" === type4;
        }
        function isEmptyValue(value, type4) {
            return null == value || (!("array" !== type4 || !Array.isArray(value) || value.length) || !(!isNativeStringType(type4) || "string" != typeof value || value));
        }
        function asyncParallelArray(arr, func, callback) {
            var results = [], total = 0, arrLength = arr.length;
            function count(errors) {
                results.push.apply(results, errors || []), ++total === arrLength && callback(results);
            }
            arr.forEach((function(a2) {
                func(a2, count);
            }));
        }
        function asyncSerialArray(arr, func, callback) {
            var index2 = 0, arrLength = arr.length;
            function next2(errors) {
                if (errors && errors.length) callback(errors); else {
                    var original = index2;
                    index2 += 1, original < arrLength ? func(arr[original], next2) : callback([]);
                }
            }
            next2([]);
        }
        function flattenObjArr(objArr) {
            var ret = [];
            return Object.keys(objArr).forEach((function(k2) {
                ret.push.apply(ret, objArr[k2] || []);
            })), ret;
        }
        var AsyncValidationError = function(_Error) {
            function AsyncValidationError2(errors, fields) {
                var _this;
                return (_this = _Error.call(this, "Async Validation Error") || this).errors = errors, 
                _this.fields = fields, _this;
            }
            return _inheritsLoose(AsyncValidationError2, _Error), AsyncValidationError2;
        }(_wrapNativeSuper(Error));
        function asyncMap(objArr, option, func, callback, source) {
            if (option.first) {
                var _pending = new Promise((function(resolve2, reject) {
                    var next2 = function next22(errors) {
                        return callback(errors), errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve2(source);
                    };
                    asyncSerialArray(flattenObjArr(objArr), func, next2);
                }));
                return _pending.catch((function(e2) {
                    return e2;
                })), _pending;
            }
            var firstFields = !0 === option.firstFields ? Object.keys(objArr) : option.firstFields || [], objArrKeys = Object.keys(objArr), objArrLength = objArrKeys.length, total = 0, results = [], pending = new Promise((function(resolve2, reject) {
                var next2 = function next22(errors) {
                    if (results.push.apply(results, errors), ++total === objArrLength) return callback(results), 
                    results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve2(source);
                };
                objArrKeys.length || (callback(results), resolve2(source)), objArrKeys.forEach((function(key2) {
                    var arr = objArr[key2];
                    -1 !== firstFields.indexOf(key2) ? asyncSerialArray(arr, func, next2) : asyncParallelArray(arr, func, next2);
                }));
            }));
            return pending.catch((function(e2) {
                return e2;
            })), pending;
        }
        function isErrorObj(obj) {
            return !(!obj || void 0 === obj.message);
        }
        function getValue$1(value, path) {
            for (var v2 = value, i2 = 0; i2 < path.length; i2++) {
                if (null == v2) return v2;
                v2 = v2[path[i2]];
            }
            return v2;
        }
        function complementError(rule, source) {
            return function(oe) {
                var fieldValue;
                return fieldValue = rule.fullFields ? getValue$1(source, rule.fullFields) : source[oe.field || rule.fullField], 
                isErrorObj(oe) ? (oe.field = oe.field || rule.fullField, oe.fieldValue = fieldValue, 
                oe) : {
                    message: "function" == typeof oe ? oe() : oe,
                    fieldValue: fieldValue,
                    field: oe.field || rule.fullField
                };
            };
        }
        function deepMerge(target, source) {
            if (source) for (var s2 in source) if (source.hasOwnProperty(s2)) {
                var value = source[s2];
                "object" == typeof value && "object" == typeof target[s2] ? target[s2] = _extends({}, target[s2], value) : target[s2] = value;
            }
            return target;
        }
        var urlReg, required$1 = function required(rule, value, source, errors, options, type4) {
            !rule.required || source.hasOwnProperty(rule.field) && !isEmptyValue(value, type4 || rule.type) || errors.push(format(options.messages.required, rule.fullField));
        }, getUrlRegex = function() {
            if (urlReg) return urlReg;
            var word = "[a-fA-F\\d:]", b2 = function b22(options) {
                return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
            }, v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", v6seg = "[a-fA-F\\d]{1,4}", v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)"), v4exact = new RegExp("^" + v4 + "$"), v6exact = new RegExp("^" + v6 + "$"), ip = function ip2(options) {
                return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
            };
            ip.v4 = function(options) {
                return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
            }, ip.v6 = function(options) {
                return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
            };
            var protocol = "(?:(?:[a-z]+:)?//)", auth = "(?:\\S+(?::\\S*)?@)?", ipv4 = ip.v4().source, ipv6 = ip.v6().source;
            return urlReg = new RegExp("(?:^" + ("(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)" + "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" + "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" + ")" + "(?::\\d{2,5})?" + '(?:[/?#][^\\s"]*)?') + "$)", "i");
        }, pattern$2 = {
            email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
            hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
        }, types = {
            integer: function integer(value) {
                return types.number(value) && parseInt(value, 10) === value;
            },
            float: function float(value) {
                return types.number(value) && !types.integer(value);
            },
            array: function array(value) {
                return Array.isArray(value);
            },
            regexp: function regexp(value) {
                if (value instanceof RegExp) return !0;
                try {
                    return !!new RegExp(value);
                } catch (e2) {
                    return !1;
                }
            },
            date: function date(value) {
                return "function" == typeof value.getTime && "function" == typeof value.getMonth && "function" == typeof value.getYear && !isNaN(value.getTime());
            },
            number: function number(value) {
                return !isNaN(value) && "number" == typeof value;
            },
            object: function object(value) {
                return "object" == typeof value && !types.array(value);
            },
            method: function method(value) {
                return "function" == typeof value;
            },
            email: function email(value) {
                return "string" == typeof value && value.length <= 320 && !!value.match(pattern$2.email);
            },
            url: function url(value) {
                return "string" == typeof value && value.length <= 2048 && !!value.match(getUrlRegex());
            },
            hex: function hex(value) {
                return "string" == typeof value && !!value.match(pattern$2.hex);
            }
        }, type$1 = function type(rule, value, source, errors, options) {
            if (rule.required && void 0 === value) required$1(rule, value, source, errors, options); else {
                var custom = [ "integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex" ], ruleType = rule.type;
                custom.indexOf(ruleType) > -1 ? types[ruleType](value) || errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type)) : ruleType && typeof value !== rule.type && errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
            }
        }, ENUM$1 = "enum", rules = {
            required: required$1,
            whitespace: function whitespace2(rule, value, source, errors, options) {
                (/^\s+$/.test(value) || "" === value) && errors.push(format(options.messages.whitespace, rule.fullField));
            },
            type: type$1,
            range: function range2(rule, value, source, errors, options) {
                var len = "number" == typeof rule.len, min = "number" == typeof rule.min, max = "number" == typeof rule.max, spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, val = value, key2 = null, num = "number" == typeof value, str = "string" == typeof value, arr = Array.isArray(value);
                if (num ? key2 = "number" : str ? key2 = "string" : arr && (key2 = "array"), !key2) return !1;
                arr && (val = value.length), str && (val = value.replace(spRegexp, "_").length), 
                len ? val !== rule.len && errors.push(format(options.messages[key2].len, rule.fullField, rule.len)) : min && !max && val < rule.min ? errors.push(format(options.messages[key2].min, rule.fullField, rule.min)) : max && !min && val > rule.max ? errors.push(format(options.messages[key2].max, rule.fullField, rule.max)) : min && max && (val < rule.min || val > rule.max) && errors.push(format(options.messages[key2].range, rule.fullField, rule.min, rule.max));
            },
            enum: function enumerable(rule, value, source, errors, options) {
                rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [], -1 === rule[ENUM$1].indexOf(value) && errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
            },
            pattern: function pattern(rule, value, source, errors, options) {
                if (rule.pattern) if (rule.pattern instanceof RegExp) rule.pattern.lastIndex = 0, 
                rule.pattern.test(value) || errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern)); else if ("string" == typeof rule.pattern) {
                    new RegExp(rule.pattern).test(value) || errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
                }
            }
        }, ENUM = "enum", type2 = function type3(rule, value, callback, source, options) {
            var ruleType = rule.type, errors = [];
            if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                if (isEmptyValue(value, ruleType) && !rule.required) return callback();
                rules.required(rule, value, source, errors, options, ruleType), isEmptyValue(value, ruleType) || rules.type(rule, value, source, errors, options);
            }
            callback(errors);
        }, validators = {
            string: function string2(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value, "string") && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options, "string"), isEmptyValue(value, "string") || (rules.type(rule, value, source, errors, options), 
                    rules.range(rule, value, source, errors, options), rules.pattern(rule, value, source, errors, options), 
                    !0 === rule.whitespace && rules.whitespace(rule, value, source, errors, options));
                }
                callback(errors);
            },
            method: function method3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && rules.type(rule, value, source, errors, options);
                }
                callback(errors);
            },
            number: function number3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if ("" === value && (value = void 0), isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && (rules.type(rule, value, source, errors, options), 
                    rules.range(rule, value, source, errors, options));
                }
                callback(errors);
            },
            boolean: function _boolean2(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && rules.type(rule, value, source, errors, options);
                }
                callback(errors);
            },
            regexp: function regexp3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), isEmptyValue(value) || rules.type(rule, value, source, errors, options);
                }
                callback(errors);
            },
            integer: function integer3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && (rules.type(rule, value, source, errors, options), 
                    rules.range(rule, value, source, errors, options));
                }
                callback(errors);
            },
            float: function floatFn2(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && (rules.type(rule, value, source, errors, options), 
                    rules.range(rule, value, source, errors, options));
                }
                callback(errors);
            },
            array: function array3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (null == value && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options, "array"), null != value && (rules.type(rule, value, source, errors, options), 
                    rules.range(rule, value, source, errors, options));
                }
                callback(errors);
            },
            object: function object3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && rules.type(rule, value, source, errors, options);
                }
                callback(errors);
            },
            enum: function enumerable3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), void 0 !== value && rules[ENUM](rule, value, source, errors, options);
                }
                callback(errors);
            },
            pattern: function pattern3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value, "string") && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options), isEmptyValue(value, "string") || rules.pattern(rule, value, source, errors, options);
                }
                callback(errors);
            },
            date: function date3(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value, "date") && !rule.required) return callback();
                    var dateObject;
                    if (rules.required(rule, value, source, errors, options), !isEmptyValue(value, "date")) dateObject = value instanceof Date ? value : new Date(value), 
                    rules.type(rule, dateObject, source, errors, options), dateObject && rules.range(rule, dateObject.getTime(), source, errors, options);
                }
                callback(errors);
            },
            url: type2,
            hex: type2,
            email: type2,
            required: function required3(rule, value, callback, source, options) {
                var errors = [], type4 = Array.isArray(value) ? "array" : typeof value;
                rules.required(rule, value, source, errors, options, type4), callback(errors);
            },
            any: function any2(rule, value, callback, source, options) {
                var errors = [];
                if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                    if (isEmptyValue(value) && !rule.required) return callback();
                    rules.required(rule, value, source, errors, options);
                }
                callback(errors);
            }
        };
        function newMessages() {
            return {
                default: "Validation error on field %s",
                required: "%s is required",
                enum: "%s must be one of %s",
                whitespace: "%s cannot be empty",
                date: {
                    format: "%s date %s is invalid for format %s",
                    parse: "%s date could not be parsed, %s is invalid ",
                    invalid: "%s date %s is invalid"
                },
                types: {
                    string: "%s is not a %s",
                    method: "%s is not a %s (function)",
                    array: "%s is not an %s",
                    object: "%s is not an %s",
                    number: "%s is not a %s",
                    date: "%s is not a %s",
                    boolean: "%s is not a %s",
                    integer: "%s is not an %s",
                    float: "%s is not a %s",
                    regexp: "%s is not a valid %s",
                    email: "%s is not a valid %s",
                    url: "%s is not a valid %s",
                    hex: "%s is not a valid %s"
                },
                string: {
                    len: "%s must be exactly %s characters",
                    min: "%s must be at least %s characters",
                    max: "%s cannot be longer than %s characters",
                    range: "%s must be between %s and %s characters"
                },
                number: {
                    len: "%s must equal %s",
                    min: "%s cannot be less than %s",
                    max: "%s cannot be greater than %s",
                    range: "%s must be between %s and %s"
                },
                array: {
                    len: "%s must be exactly %s in length",
                    min: "%s cannot be less than %s in length",
                    max: "%s cannot be greater than %s in length",
                    range: "%s must be between %s and %s in length"
                },
                pattern: {
                    mismatch: "%s value %s does not match pattern %s"
                },
                clone: function clone() {
                    var cloned = JSON.parse(JSON.stringify(this));
                    return cloned.clone = this.clone, cloned;
                }
            };
        }
        var messages = newMessages(), Schema = function() {
            function Schema2(descriptor) {
                this.rules = null, this._messages = messages, this.define(descriptor);
            }
            var _proto = Schema2.prototype;
            return _proto.define = function define(rules2) {
                var _this = this;
                if (!rules2) throw new Error("Cannot configure a schema with no rules");
                if ("object" != typeof rules2 || Array.isArray(rules2)) throw new Error("Rules must be an object");
                this.rules = {}, Object.keys(rules2).forEach((function(name) {
                    var item = rules2[name];
                    _this.rules[name] = Array.isArray(item) ? item : [ item ];
                }));
            }, _proto.messages = function messages2(_messages) {
                return _messages && (this._messages = deepMerge(newMessages(), _messages)), this._messages;
            }, _proto.validate = function validate(source_, o2, oc) {
                var _this2 = this;
                void 0 === o2 && (o2 = {}), void 0 === oc && (oc = function oc2() {});
                var source = source_, options = o2, callback = oc;
                if ("function" == typeof options && (callback = options, options = {}), !this.rules || 0 === Object.keys(this.rules).length) return callback && callback(null, source), 
                Promise.resolve(source);
                function complete(results) {
                    var errors = [], fields = {};
                    function add2(e2) {
                        var _errors;
                        Array.isArray(e2) ? errors = (_errors = errors).concat.apply(_errors, e2) : errors.push(e2);
                    }
                    for (var i2 = 0; i2 < results.length; i2++) add2(results[i2]);
                    errors.length ? (fields = convertFieldsError(errors), callback(errors, fields)) : callback(null, source);
                }
                if (options.messages) {
                    var messages$1 = this.messages();
                    messages$1 === messages && (messages$1 = newMessages()), deepMerge(messages$1, options.messages), 
                    options.messages = messages$1;
                } else options.messages = this.messages();
                var series = {};
                (options.keys || Object.keys(this.rules)).forEach((function(z2) {
                    var arr = _this2.rules[z2], value = source[z2];
                    arr.forEach((function(r2) {
                        var rule = r2;
                        "function" == typeof rule.transform && (source === source_ && (source = _extends({}, source)), 
                        value = source[z2] = rule.transform(value)), (rule = "function" == typeof rule ? {
                            validator: rule
                        } : _extends({}, rule)).validator = _this2.getValidationMethod(rule), rule.validator && (rule.field = z2, 
                        rule.fullField = rule.fullField || z2, rule.type = _this2.getType(rule), series[z2] = series[z2] || [], 
                        series[z2].push({
                            rule: rule,
                            value: value,
                            source: source,
                            field: z2
                        }));
                    }));
                }));
                var errorFields = {};
                return asyncMap(series, options, (function(data, doIt) {
                    var res, rule = data.rule, deep = !("object" !== rule.type && "array" !== rule.type || "object" != typeof rule.fields && "object" != typeof rule.defaultField);
                    function addFullField(key2, schema) {
                        return _extends({}, schema, {
                            fullField: rule.fullField + "." + key2,
                            fullFields: rule.fullFields ? [].concat(rule.fullFields, [ key2 ]) : [ key2 ]
                        });
                    }
                    function cb(e2) {
                        void 0 === e2 && (e2 = []);
                        var errorList = Array.isArray(e2) ? e2 : [ e2 ];
                        !options.suppressWarning && errorList.length && Schema2.warning("async-validator:", errorList), 
                        errorList.length && void 0 !== rule.message && (errorList = [].concat(rule.message));
                        var filledErrors = errorList.map(complementError(rule, source));
                        if (options.first && filledErrors.length) return errorFields[rule.field] = 1, doIt(filledErrors);
                        if (deep) {
                            if (rule.required && !data.value) return void 0 !== rule.message ? filledErrors = [].concat(rule.message).map(complementError(rule, source)) : options.error && (filledErrors = [ options.error(rule, format(options.messages.required, rule.field)) ]), 
                            doIt(filledErrors);
                            var fieldsSchema = {};
                            rule.defaultField && Object.keys(data.value).map((function(key2) {
                                fieldsSchema[key2] = rule.defaultField;
                            })), fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                            var paredFieldsSchema = {};
                            Object.keys(fieldsSchema).forEach((function(field) {
                                var fieldSchema = fieldsSchema[field], fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [ fieldSchema ];
                                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                            }));
                            var schema = new Schema2(paredFieldsSchema);
                            schema.messages(options.messages), data.rule.options && (data.rule.options.messages = options.messages, 
                            data.rule.options.error = options.error), schema.validate(data.value, data.rule.options || options, (function(errs) {
                                var finalErrors = [];
                                filledErrors && filledErrors.length && finalErrors.push.apply(finalErrors, filledErrors), 
                                errs && errs.length && finalErrors.push.apply(finalErrors, errs), doIt(finalErrors.length ? finalErrors : null);
                            }));
                        } else doIt(filledErrors);
                    }
                    if (deep = deep && (rule.required || !rule.required && data.value), rule.field = data.field, 
                    rule.asyncValidator) res = rule.asyncValidator(rule, data.value, cb, data.source, options); else if (rule.validator) {
                        try {
                            res = rule.validator(rule, data.value, cb, data.source, options);
                        } catch (error) {
                            console.error, options.suppressValidatorError || setTimeout((function() {
                                throw error;
                            }), 0), cb(error.message);
                        }
                        !0 === res ? cb() : !1 === res ? cb("function" == typeof rule.message ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails") : res instanceof Array ? cb(res) : res instanceof Error && cb(res.message);
                    }
                    res && res.then && res.then((function() {
                        return cb();
                    }), (function(e2) {
                        return cb(e2);
                    }));
                }), (function(results) {
                    complete(results);
                }), source);
            }, _proto.getType = function getType(rule) {
                if (void 0 === rule.type && rule.pattern instanceof RegExp && (rule.type = "pattern"), 
                "function" != typeof rule.validator && rule.type && !validators.hasOwnProperty(rule.type)) throw new Error(format("Unknown rule type %s", rule.type));
                return rule.type || "string";
            }, _proto.getValidationMethod = function getValidationMethod(rule) {
                if ("function" == typeof rule.validator) return rule.validator;
                var keys2 = Object.keys(rule), messageIndex = keys2.indexOf("message");
                return -1 !== messageIndex && keys2.splice(messageIndex, 1), 1 === keys2.length && "required" === keys2[0] ? validators.required : validators[this.getType(rule)] || void 0;
            }, Schema2;
        }();
        function toArray$1(value) {
            return null == value ? [] : Array.isArray(value) ? value : [ value ];
        }
        function get(entity, path) {
            let current = entity;
            for (let i2 = 0; i2 < path.length; i2 += 1) {
                if (null == current) return;
                current = current[path[i2]];
            }
            return current;
        }
        function internalSet(entity, paths, value, removeIfUndefined) {
            if (!paths.length) return value;
            const [path, ...restPath] = paths;
            let clone;
            return clone = entity || "number" != typeof path ? Array.isArray(entity) ? [ ...entity ] : _extends$1({}, entity) : [], 
            removeIfUndefined && void 0 === value && 1 === restPath.length ? delete clone[path][restPath[0]] : clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined), 
            clone;
        }
        function set(entity, paths, value) {
            let removeIfUndefined = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            return paths.length && removeIfUndefined && void 0 === value && !get(entity, paths.slice(0, -1)) ? entity : internalSet(entity, paths, value, removeIfUndefined);
        }
        function getNamePath(path) {
            return toArray$1(path);
        }
        function getValue(store, namePath) {
            return get(store, namePath);
        }
        function setValue(store, namePath, value) {
            return set(store, namePath, value, arguments.length > 3 && void 0 !== arguments[3] && arguments[3]);
        }
        function containsNamePath(namePathList, namePath) {
            return namePathList && namePathList.some((path => matchNamePath(path, namePath)));
        }
        function isObject(obj) {
            return "object" == typeof obj && null !== obj && Object.getPrototypeOf(obj) === Object.prototype;
        }
        function internalSetValues(store, values) {
            const newStore = Array.isArray(store) ? [ ...store ] : _extends$1({}, store);
            return values ? (Object.keys(values).forEach((key2 => {
                const prevValue = newStore[key2], value = values[key2], recursive = isObject(prevValue) && isObject(value);
                newStore[key2] = recursive ? internalSetValues(prevValue, value || {}) : value;
            })), newStore) : newStore;
        }
        function setValues(store) {
            for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) restValues[_key - 1] = arguments[_key];
            return restValues.reduce(((current, newStore) => internalSetValues(current, newStore)), store);
        }
        function cloneByNamePathList(store, namePathList) {
            let newStore = {};
            return namePathList.forEach((namePath => {
                const value = getValue(store, namePath);
                newStore = setValue(newStore, namePath, value);
            })), newStore;
        }
        function matchNamePath(namePath, changedNamePath) {
            return !(!namePath || !changedNamePath || namePath.length !== changedNamePath.length) && namePath.every(((nameUnit, i2) => changedNamePath[i2] === nameUnit));
        }
        Schema.register = function register(type4, validator) {
            if ("function" != typeof validator) throw new Error("Cannot register a validator by type, validator is not a function");
            validators[type4] = validator;
        }, Schema.warning = warning, Schema.messages = messages, Schema.validators = validators;
        const typeTemplate = "'${name}' is not a valid ${type}", defaultValidateMessages = {
            default: "Validation error on field '${name}'",
            required: "'${name}' is required",
            enum: "'${name}' must be one of [${enum}]",
            whitespace: "'${name}' cannot be empty",
            date: {
                format: "'${name}' is invalid for format date",
                parse: "'${name}' could not be parsed as date",
                invalid: "'${name}' is invalid date"
            },
            types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
            },
            string: {
                len: "'${name}' must be exactly ${len} characters",
                min: "'${name}' must be at least ${min} characters",
                max: "'${name}' cannot be longer than ${max} characters",
                range: "'${name}' must be between ${min} and ${max} characters"
            },
            number: {
                len: "'${name}' must equal ${len}",
                min: "'${name}' cannot be less than ${min}",
                max: "'${name}' cannot be greater than ${max}",
                range: "'${name}' must be between ${min} and ${max}"
            },
            array: {
                len: "'${name}' must be exactly ${len} in length",
                min: "'${name}' cannot be less than ${min} in length",
                max: "'${name}' cannot be greater than ${max} in length",
                range: "'${name}' must be between ${min} and ${max} in length"
            },
            pattern: {
                mismatch: "'${name}' does not match pattern ${pattern}"
            }
        };
        var __awaiter = function(thisArg, _arguments, P2, generator) {
            function adopt(value) {
                return value instanceof P2 ? value : new P2((function(resolve2) {
                    resolve2(value);
                }));
            }
            return new (P2 || (P2 = Promise))((function(resolve2, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e2) {
                        reject(e2);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e2) {
                        reject(e2);
                    }
                }
                function step(result) {
                    result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            }));
        };
        const AsyncValidator = Schema;
        function replaceMessage(template, kv) {
            return template.replace(/\$\{\w+\}/g, (str => {
                const key2 = str.slice(2, -1);
                return kv[key2];
            }));
        }
        function validateRule(name, value, rule, options, messageVariables) {
            return __awaiter(this, void 0, void 0, (function*() {
                const cloneRule = _extends$1({}, rule);
                delete cloneRule.ruleIndex, delete cloneRule.trigger;
                let subRuleField = null;
                cloneRule && "array" === cloneRule.type && cloneRule.defaultField && (subRuleField = cloneRule.defaultField, 
                delete cloneRule.defaultField);
                const validator = new AsyncValidator({
                    [name]: [ cloneRule ]
                }), messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
                validator.messages(messages2);
                let result = [];
                try {
                    yield Promise.resolve(validator.validate({
                        [name]: value
                    }, _extends$1({}, options)));
                } catch (errObj) {
                    result = errObj.errors ? errObj.errors.map(((_ref, index2) => {
                        let {message: message} = _ref;
                        return isValidElement(message) ? cloneVNode(message, {
                            key: `error_${index2}`
                        }) : message;
                    })) : [ messages2.default() ];
                }
                if (!result.length && subRuleField) {
                    return (yield Promise.all(value.map(((subValue, i2) => validateRule(`${name}.${i2}`, subValue, subRuleField, options, messageVariables))))).reduce(((prev2, errors) => [ ...prev2, ...errors ]), []);
                }
                const kv = _extends$1(_extends$1(_extends$1({}, rule), {
                    name: name,
                    enum: (rule.enum || []).join(", ")
                }), messageVariables);
                return result.map((error => "string" == typeof error ? replaceMessage(error, kv) : error));
            }));
        }
        function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
            const name = namePath.join("."), filledRules = rules2.map(((currentRule, ruleIndex) => {
                const originValidatorFunc = currentRule.validator, cloneRule = _extends$1(_extends$1({}, currentRule), {
                    ruleIndex: ruleIndex
                });
                return originValidatorFunc && (cloneRule.validator = (rule, val, callback) => {
                    let hasPromise = !1;
                    const wrappedCallback = function() {
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                        Promise.resolve().then((() => {
                            hasPromise || callback(...args);
                        }));
                    }, promise = originValidatorFunc(rule, val, wrappedCallback);
                    hasPromise = promise && "function" == typeof promise.then && "function" == typeof promise.catch, 
                    hasPromise && promise.then((() => {
                        callback();
                    })).catch((err => {
                        callback(err || " ");
                    }));
                }), cloneRule;
            })).sort(((_ref2, _ref3) => {
                let {warningOnly: w1, ruleIndex: i1} = _ref2, {warningOnly: w2, ruleIndex: i2} = _ref3;
                return !!w1 == !!w2 ? i1 - i2 : w1 ? 1 : -1;
            }));
            let summaryPromise;
            if (!0 === validateFirst) summaryPromise = new Promise(((resolve2, reject) => __awaiter(this, void 0, void 0, (function*() {
                for (let i2 = 0; i2 < filledRules.length; i2 += 1) {
                    const rule = filledRules[i2], errors = yield validateRule(name, value, rule, options, messageVariables);
                    if (errors.length) return void reject([ {
                        errors: errors,
                        rule: rule
                    } ]);
                }
                resolve2([]);
            })))); else {
                const rulePromises = filledRules.map((rule => validateRule(name, value, rule, options, messageVariables).then((errors => ({
                    errors: errors,
                    rule: rule
                })))));
                summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then((errors => Promise.reject(errors)));
            }
            return summaryPromise.catch((e2 => e2)), summaryPromise;
        }
        function finishOnAllFailed(rulePromises) {
            return __awaiter(this, void 0, void 0, (function*() {
                return Promise.all(rulePromises).then((errorsList => [].concat(...errorsList)));
            }));
        }
        function finishOnFirstFailed(rulePromises) {
            return __awaiter(this, void 0, void 0, (function*() {
                let count = 0;
                return new Promise((resolve2 => {
                    rulePromises.forEach((promise => {
                        promise.then((ruleError => {
                            ruleError.errors.length && resolve2([ ruleError ]), count += 1, count === rulePromises.length && resolve2([]);
                        }));
                    }));
                }));
            }));
        }
        const FormContextKey = Symbol("formContextKey"), useProvideForm = state => {
            provide(FormContextKey, state);
        }, useInjectForm = () => inject(FormContextKey, {
            name: computed((() => {})),
            labelAlign: computed((() => "right")),
            vertical: computed((() => !1)),
            addField: (_eventKey, _field) => {},
            removeField: _eventKey => {},
            model: computed((() => {})),
            rules: computed((() => {})),
            colon: computed((() => {})),
            labelWrap: computed((() => {})),
            labelCol: computed((() => {})),
            requiredMark: computed((() => !1)),
            validateTrigger: computed((() => {})),
            onValidate: () => {},
            validateMessages: computed((() => defaultValidateMessages))
        }), FormItemPrefixContextKey = Symbol("formItemPrefixContextKey"), useProvideFormItemPrefix = state => {
            provide(FormItemPrefixContextKey, state);
        }, useInjectFormItemPrefix = () => inject(FormItemPrefixContextKey, {
            prefixCls: computed((() => ""))
        });
        function parseFlex(flex) {
            return "number" == typeof flex ? `${flex} ${flex} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(flex) ? `0 0 ${flex}` : flex;
        }
        const sizes = [ "xs", "sm", "md", "lg", "xl", "xxl" ], Col = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ACol",
            inheritAttrs: !1,
            props: (() => ({
                span: [ String, Number ],
                order: [ String, Number ],
                offset: [ String, Number ],
                push: [ String, Number ],
                pull: [ String, Number ],
                xs: {
                    type: [ String, Number, Object ],
                    default: void 0
                },
                sm: {
                    type: [ String, Number, Object ],
                    default: void 0
                },
                md: {
                    type: [ String, Number, Object ],
                    default: void 0
                },
                lg: {
                    type: [ String, Number, Object ],
                    default: void 0
                },
                xl: {
                    type: [ String, Number, Object ],
                    default: void 0
                },
                xxl: {
                    type: [ String, Number, Object ],
                    default: void 0
                },
                prefixCls: String,
                flex: [ String, Number ]
            }))(),
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs} = _ref;
                const {gutter: gutter, supportFlexGap: supportFlexGap, wrap: wrap} = useInjectRow(), {prefixCls: prefixCls, direction: direction} = useConfigInject("col", props2), [wrapSSR, hashId] = useColStyle(prefixCls), classes = computed((() => {
                    const {span: span, order: order, offset: offset, push: push, pull: pull} = props2, pre = prefixCls.value;
                    let sizeClassObj = {};
                    return sizes.forEach((size2 => {
                        let sizeProps = {};
                        const propSize = props2[size2];
                        "number" == typeof propSize ? sizeProps.span = propSize : "object" == typeof propSize && (sizeProps = propSize || {}), 
                        sizeClassObj = _extends$1(_extends$1({}, sizeClassObj), {
                            [`${pre}-${size2}-${sizeProps.span}`]: void 0 !== sizeProps.span,
                            [`${pre}-${size2}-order-${sizeProps.order}`]: sizeProps.order || 0 === sizeProps.order,
                            [`${pre}-${size2}-offset-${sizeProps.offset}`]: sizeProps.offset || 0 === sizeProps.offset,
                            [`${pre}-${size2}-push-${sizeProps.push}`]: sizeProps.push || 0 === sizeProps.push,
                            [`${pre}-${size2}-pull-${sizeProps.pull}`]: sizeProps.pull || 0 === sizeProps.pull,
                            [`${pre}-rtl`]: "rtl" === direction.value
                        });
                    })), classNames(pre, {
                        [`${pre}-${span}`]: void 0 !== span,
                        [`${pre}-order-${order}`]: order,
                        [`${pre}-offset-${offset}`]: offset,
                        [`${pre}-push-${push}`]: push,
                        [`${pre}-pull-${pull}`]: pull
                    }, sizeClassObj, attrs.class, hashId.value);
                })), mergedStyle = computed((() => {
                    const {flex: flex} = props2, gutterVal = gutter.value, style = {};
                    if (gutterVal && gutterVal[0] > 0) {
                        const horizontalGutter = gutterVal[0] / 2 + "px";
                        style.paddingLeft = horizontalGutter, style.paddingRight = horizontalGutter;
                    }
                    if (gutterVal && gutterVal[1] > 0 && !supportFlexGap.value) {
                        const verticalGutter = gutterVal[1] / 2 + "px";
                        style.paddingTop = verticalGutter, style.paddingBottom = verticalGutter;
                    }
                    return flex && (style.flex = parseFlex(flex), !1 !== wrap.value || style.minWidth || (style.minWidth = 0)), 
                    style;
                }));
                return () => {
                    var _a;
                    return wrapSSR(createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: classes.value,
                        style: [ mergedStyle.value, attrs.style ]
                    }), [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]));
                };
            }
        });
        var QuestionCircleOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                    }
                }, {
                    tag: "path",
                    attrs: {
                        d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z"
                    }
                } ]
            },
            name: "question-circle",
            theme: "outlined"
        };
        function _objectSpread$3(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$3(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$3(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var QuestionCircleOutlined = function QuestionCircleOutlined2(props2, context) {
            var p2 = _objectSpread$3({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$3({}, p2, {
                icon: QuestionCircleOutlined$1
            }), null);
        };
        QuestionCircleOutlined.displayName = "QuestionCircleOutlined", QuestionCircleOutlined.inheritAttrs = !1;
        const FormItemLabel = (props2, _ref) => {
            let {slots: slots, emit: emit2, attrs: attrs} = _ref;
            var _a, _b, _c, _d, _e;
            const {prefixCls: prefixCls, htmlFor: htmlFor, labelCol: labelCol, labelAlign: labelAlign, colon: colon, required: required, requiredMark: requiredMark} = _extends$1(_extends$1({}, props2), attrs), [formLocale] = useLocaleReceiver("Form"), label = null !== (_a = props2.label) && void 0 !== _a ? _a : null === (_b = slots.label) || void 0 === _b ? void 0 : _b.call(slots);
            if (!label) return null;
            const {vertical: vertical, labelAlign: contextLabelAlign, labelCol: contextLabelCol, labelWrap: labelWrap, colon: contextColon} = useInjectForm(), mergedLabelCol = labelCol || (null == contextLabelCol ? void 0 : contextLabelCol.value) || {}, labelClsBasic = `${prefixCls}-item-label`, labelColClassName = classNames(labelClsBasic, "left" === (labelAlign || (null == contextLabelAlign ? void 0 : contextLabelAlign.value)) && `${labelClsBasic}-left`, mergedLabelCol.class, {
                [`${labelClsBasic}-wrap`]: !!labelWrap.value
            });
            let labelChildren = label;
            const computedColon = !0 === colon || !1 !== (null == contextColon ? void 0 : contextColon.value) && !1 !== colon;
            if (computedColon && !vertical.value && "string" == typeof label && "" !== label.trim() && (labelChildren = label.replace(/[:|：]\s*$/, "")), 
            props2.tooltip || slots.tooltip) {
                const tooltipNode = createVNode("span", {
                    class: `${prefixCls}-item-tooltip`
                }, [ createVNode(Tooltip, {
                    title: props2.tooltip
                }, {
                    default: () => [ createVNode(QuestionCircleOutlined, null, null) ]
                }) ]);
                labelChildren = createVNode(Fragment, null, [ labelChildren, slots.tooltip ? null === (_c = slots.tooltip) || void 0 === _c ? void 0 : _c.call(slots, {
                    class: `${prefixCls}-item-tooltip`
                }) : tooltipNode ]);
            }
            "optional" !== requiredMark || required || (labelChildren = createVNode(Fragment, null, [ labelChildren, createVNode("span", {
                class: `${prefixCls}-item-optional`
            }, [ (null === (_d = formLocale.value) || void 0 === _d ? void 0 : _d.optional) || (null === (_e = localeValues.Form) || void 0 === _e ? void 0 : _e.optional) ]) ]));
            const labelClassName = classNames({
                [`${prefixCls}-item-required`]: required,
                [`${prefixCls}-item-required-mark-optional`]: "optional" === requiredMark,
                [`${prefixCls}-item-no-colon`]: !computedColon
            });
            return createVNode(Col, _objectSpread2$1(_objectSpread2$1({}, mergedLabelCol), {}, {
                class: labelColClassName
            }), {
                default: () => [ createVNode("label", {
                    for: htmlFor,
                    class: labelClassName,
                    title: "string" == typeof label ? label : "",
                    onClick: e2 => emit2("click", e2)
                }, [ labelChildren ]) ]
            });
        };
        FormItemLabel.displayName = "FormItemLabel", FormItemLabel.inheritAttrs = !1;
        const genFormValidateMotionStyle = token2 => {
            const {componentCls: componentCls} = token2, helpCls = `${componentCls}-show-help`, helpItemCls = `${componentCls}-show-help-item`;
            return {
                [helpCls]: {
                    transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
                    "&-appear, &-enter": {
                        opacity: 0,
                        "&-active": {
                            opacity: 1
                        }
                    },
                    "&-leave": {
                        opacity: 1,
                        "&-active": {
                            opacity: 0
                        }
                    },
                    [helpItemCls]: {
                        overflow: "hidden",
                        transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},\n                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},\n                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
                        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
                            transform: "translateY(-5px)",
                            opacity: 0,
                            "&-active": {
                                transform: "translateY(0)",
                                opacity: 1
                            }
                        },
                        [`&${helpItemCls}-leave-active`]: {
                            transform: "translateY(-5px)"
                        }
                    }
                }
            };
        }, resetForm = token2 => ({
            legend: {
                display: "block",
                width: "100%",
                marginBottom: token2.marginLG,
                padding: 0,
                color: token2.colorTextDescription,
                fontSize: token2.fontSizeLG,
                lineHeight: "inherit",
                border: 0,
                borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
            },
            label: {
                fontSize: token2.fontSize
            },
            'input[type="search"]': {
                boxSizing: "border-box"
            },
            'input[type="radio"], input[type="checkbox"]': {
                lineHeight: "normal"
            },
            'input[type="file"]': {
                display: "block"
            },
            'input[type="range"]': {
                display: "block",
                width: "100%"
            },
            "select[multiple], select[size]": {
                height: "auto"
            },
            "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
                outline: 0,
                boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
            },
            output: {
                display: "block",
                paddingTop: 15,
                color: token2.colorText,
                fontSize: token2.fontSize,
                lineHeight: token2.lineHeight
            }
        }), genFormSize = (token2, height) => {
            const {formItemCls: formItemCls} = token2;
            return {
                [formItemCls]: {
                    [`${formItemCls}-label > label`]: {
                        height: height
                    },
                    [`${formItemCls}-control-input`]: {
                        minHeight: height
                    }
                }
            };
        }, genFormStyle = token2 => {
            const {componentCls: componentCls} = token2;
            return {
                [token2.componentCls]: _extends$1(_extends$1(_extends$1({}, resetComponent(token2)), resetForm(token2)), {
                    [`${componentCls}-text`]: {
                        display: "inline-block",
                        paddingInlineEnd: token2.paddingSM
                    },
                    "&-small": _extends$1({}, genFormSize(token2, token2.controlHeightSM)),
                    "&-large": _extends$1({}, genFormSize(token2, token2.controlHeightLG))
                })
            };
        }, genFormItemStyle = token2 => {
            const {formItemCls: formItemCls, iconCls: iconCls, componentCls: componentCls, rootPrefixCls: rootPrefixCls} = token2;
            return {
                [formItemCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    marginBottom: token2.marginLG,
                    verticalAlign: "top",
                    "&-with-help": {
                        transition: "none"
                    },
                    [`&-hidden,\n        &-hidden.${rootPrefixCls}-row`]: {
                        display: "none"
                    },
                    "&-has-warning": {
                        [`${formItemCls}-split`]: {
                            color: token2.colorError
                        }
                    },
                    "&-has-error": {
                        [`${formItemCls}-split`]: {
                            color: token2.colorWarning
                        }
                    },
                    [`${formItemCls}-label`]: {
                        display: "inline-block",
                        flexGrow: 0,
                        overflow: "hidden",
                        whiteSpace: "nowrap",
                        textAlign: "end",
                        verticalAlign: "middle",
                        "&-left": {
                            textAlign: "start"
                        },
                        "&-wrap": {
                            overflow: "unset",
                            lineHeight: `${token2.lineHeight} - 0.25em`,
                            whiteSpace: "unset"
                        },
                        "> label": {
                            position: "relative",
                            display: "inline-flex",
                            alignItems: "center",
                            maxWidth: "100%",
                            height: token2.controlHeight,
                            color: token2.colorTextHeading,
                            fontSize: token2.fontSize,
                            [`> ${iconCls}`]: {
                                fontSize: token2.fontSize,
                                verticalAlign: "top"
                            },
                            [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
                                display: "inline-block",
                                marginInlineEnd: token2.marginXXS,
                                color: token2.colorError,
                                fontSize: token2.fontSize,
                                fontFamily: "SimSun, sans-serif",
                                lineHeight: 1,
                                content: '"*"',
                                [`${componentCls}-hide-required-mark &`]: {
                                    display: "none"
                                }
                            },
                            [`${formItemCls}-optional`]: {
                                display: "inline-block",
                                marginInlineStart: token2.marginXXS,
                                color: token2.colorTextDescription,
                                [`${componentCls}-hide-required-mark &`]: {
                                    display: "none"
                                }
                            },
                            [`${formItemCls}-tooltip`]: {
                                color: token2.colorTextDescription,
                                cursor: "help",
                                writingMode: "horizontal-tb",
                                marginInlineStart: token2.marginXXS
                            },
                            "&::after": {
                                content: '":"',
                                position: "relative",
                                marginBlock: 0,
                                marginInlineStart: token2.marginXXS / 2,
                                marginInlineEnd: token2.marginXS
                            },
                            [`&${formItemCls}-no-colon::after`]: {
                                content: '" "'
                            }
                        }
                    },
                    [`${formItemCls}-control`]: {
                        display: "flex",
                        flexDirection: "column",
                        flexGrow: 1,
                        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
                            width: "100%"
                        },
                        "&-input": {
                            position: "relative",
                            display: "flex",
                            alignItems: "center",
                            minHeight: token2.controlHeight,
                            "&-content": {
                                flex: "auto",
                                maxWidth: "100%"
                            }
                        }
                    },
                    [formItemCls]: {
                        "&-explain, &-extra": {
                            clear: "both",
                            color: token2.colorTextDescription,
                            fontSize: token2.fontSize,
                            lineHeight: token2.lineHeight
                        },
                        "&-explain-connected": {
                            width: "100%"
                        },
                        "&-extra": {
                            minHeight: token2.controlHeightSM,
                            transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
                        },
                        "&-explain": {
                            "&-error": {
                                color: token2.colorError
                            },
                            "&-warning": {
                                color: token2.colorWarning
                            }
                        }
                    },
                    [`&-with-help ${formItemCls}-explain`]: {
                        height: "auto",
                        opacity: 1
                    },
                    [`${formItemCls}-feedback-icon`]: {
                        fontSize: token2.fontSize,
                        textAlign: "center",
                        visibility: "visible",
                        animationName: zoomIn,
                        animationDuration: token2.motionDurationMid,
                        animationTimingFunction: token2.motionEaseOutBack,
                        pointerEvents: "none",
                        "&-success": {
                            color: token2.colorSuccess
                        },
                        "&-error": {
                            color: token2.colorError
                        },
                        "&-warning": {
                            color: token2.colorWarning
                        },
                        "&-validating": {
                            color: token2.colorPrimary
                        }
                    }
                })
            };
        }, genHorizontalStyle = token2 => {
            const {componentCls: componentCls, formItemCls: formItemCls, rootPrefixCls: rootPrefixCls} = token2;
            return {
                [`${componentCls}-horizontal`]: {
                    [`${formItemCls}-label`]: {
                        flexGrow: 0
                    },
                    [`${formItemCls}-control`]: {
                        flex: "1 1 0",
                        minWidth: 0
                    },
                    [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
                        minWidth: "unset"
                    }
                }
            };
        }, genInlineStyle = token2 => {
            const {componentCls: componentCls, formItemCls: formItemCls} = token2;
            return {
                [`${componentCls}-inline`]: {
                    display: "flex",
                    flexWrap: "wrap",
                    [formItemCls]: {
                        flex: "none",
                        flexWrap: "nowrap",
                        marginInlineEnd: token2.margin,
                        marginBottom: 0,
                        "&-with-help": {
                            marginBottom: token2.marginLG
                        },
                        [`> ${formItemCls}-label,\n        > ${formItemCls}-control`]: {
                            display: "inline-block",
                            verticalAlign: "top"
                        },
                        [`> ${formItemCls}-label`]: {
                            flex: "none"
                        },
                        [`${componentCls}-text`]: {
                            display: "inline-block"
                        },
                        [`${formItemCls}-has-feedback`]: {
                            display: "inline-block"
                        }
                    }
                }
            };
        }, makeVerticalLayoutLabel = token2 => ({
            margin: 0,
            padding: `0 0 ${token2.paddingXS}px`,
            whiteSpace: "initial",
            textAlign: "start",
            "> label": {
                margin: 0,
                "&::after": {
                    display: "none"
                }
            }
        }), makeVerticalLayout = token2 => {
            const {componentCls: componentCls, formItemCls: formItemCls} = token2;
            return {
                [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
                [componentCls]: {
                    [formItemCls]: {
                        flexWrap: "wrap",
                        [`${formItemCls}-label,\n          ${formItemCls}-control`]: {
                            flex: "0 0 100%",
                            maxWidth: "100%"
                        }
                    }
                }
            };
        }, genVerticalStyle = token2 => {
            const {componentCls: componentCls, formItemCls: formItemCls, rootPrefixCls: rootPrefixCls} = token2;
            return {
                [`${componentCls}-vertical`]: {
                    [formItemCls]: {
                        "&-row": {
                            flexDirection: "column"
                        },
                        "&-label > label": {
                            height: "auto"
                        },
                        [`${componentCls}-item-control`]: {
                            width: "100%"
                        }
                    }
                },
                [`${componentCls}-vertical ${formItemCls}-label,\n      .${rootPrefixCls}-col-24${formItemCls}-label,\n      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
                [`@media (max-width: ${token2.screenXSMax}px)`]: [ makeVerticalLayout(token2), {
                    [componentCls]: {
                        [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
                    }
                } ],
                [`@media (max-width: ${token2.screenSMMax}px)`]: {
                    [componentCls]: {
                        [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
                    }
                },
                [`@media (max-width: ${token2.screenMDMax}px)`]: {
                    [componentCls]: {
                        [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
                    }
                },
                [`@media (max-width: ${token2.screenLGMax}px)`]: {
                    [componentCls]: {
                        [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
                    }
                }
            };
        }, useStyle$5 = genComponentStyleHook("Form", ((token2, _ref) => {
            let {rootPrefixCls: rootPrefixCls} = _ref;
            const formToken = merge(token2, {
                formItemCls: `${token2.componentCls}-item`,
                rootPrefixCls: rootPrefixCls
            });
            return [ genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion(formToken), zoomIn ];
        })), ErrorList = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ErrorList",
            inheritAttrs: !1,
            props: [ "errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings" ],
            setup(props2, _ref) {
                let {attrs: attrs} = _ref;
                const {prefixCls: prefixCls, status: status} = useInjectFormItemPrefix(), baseClassName = computed((() => `${prefixCls.value}-item-explain`)), visible = computed((() => !(!props2.errors || !props2.errors.length))), innerStatus = ref(status.value), [, hashId] = useStyle$5(prefixCls);
                return watch([ visible, status ], (() => {
                    visible.value && (innerStatus.value = status.value);
                })), () => {
                    var _a, _b;
                    const colMItem = collapseMotion(`${prefixCls.value}-show-help-item`), transitionGroupProps = getTransitionGroupProps(`${prefixCls.value}-show-help-item`, colMItem);
                    return transitionGroupProps.role = "alert", transitionGroupProps.class = [ hashId.value, baseClassName.value, attrs.class, `${prefixCls.value}-show-help` ], 
                    createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, getTransitionProps(`${prefixCls.value}-show-help`)), {}, {
                        onAfterEnter: () => props2.onErrorVisibleChanged(!0),
                        onAfterLeave: () => props2.onErrorVisibleChanged(!1)
                    }), {
                        default: () => [ withDirectives(createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({}, transitionGroupProps), {}, {
                            tag: "div"
                        }), {
                            default: () => [ null === (_b = props2.errors) || void 0 === _b ? void 0 : _b.map(((error, index2) => createVNode("div", {
                                key: index2,
                                class: innerStatus.value ? `${baseClassName.value}-${innerStatus.value}` : ""
                            }, [ error ]))) ]
                        }), [ [ vShow, !!(null === (_a = props2.errors) || void 0 === _a ? void 0 : _a.length) ] ]) ]
                    });
                };
            }
        }), FormItemInput = defineComponent({
            compatConfig: {
                MODE: 3
            },
            slots: Object,
            inheritAttrs: !1,
            props: [ "prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged" ],
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const formContext = useInjectForm(), {wrapperCol: contextWrapperCol} = formContext, subFormContext = _extends$1({}, formContext);
                return delete subFormContext.labelCol, delete subFormContext.wrapperCol, useProvideForm(subFormContext), 
                useProvideFormItemPrefix({
                    prefixCls: computed((() => props2.prefixCls)),
                    status: computed((() => props2.status))
                }), () => {
                    var _a, _b, _c;
                    const {prefixCls: prefixCls, wrapperCol: wrapperCol, marginBottom: marginBottom, onErrorVisibleChanged: onErrorVisibleChanged, help: help = (null === (_a = slots.help) || void 0 === _a ? void 0 : _a.call(slots)), errors: errors = filterEmpty(null === (_b = slots.errors) || void 0 === _b ? void 0 : _b.call(slots)), extra: extra = (null === (_c = slots.extra) || void 0 === _c ? void 0 : _c.call(slots))} = props2, baseClassName = `${prefixCls}-item`, mergedWrapperCol = wrapperCol || (null == contextWrapperCol ? void 0 : contextWrapperCol.value) || {}, className = classNames(`${baseClassName}-control`, mergedWrapperCol.class);
                    return createVNode(Col, _objectSpread2$1(_objectSpread2$1({}, mergedWrapperCol), {}, {
                        class: className
                    }), {
                        default: () => {
                            var _a2;
                            return createVNode(Fragment, null, [ createVNode("div", {
                                class: `${baseClassName}-control-input`
                            }, [ createVNode("div", {
                                class: `${baseClassName}-control-input-content`
                            }, [ null === (_a2 = slots.default) || void 0 === _a2 ? void 0 : _a2.call(slots) ]) ]), null !== marginBottom || errors.length ? createVNode("div", {
                                style: {
                                    display: "flex",
                                    flexWrap: "nowrap"
                                }
                            }, [ createVNode(ErrorList, {
                                errors: errors,
                                help: help,
                                class: `${baseClassName}-explain-connected`,
                                onErrorVisibleChanged: onErrorVisibleChanged
                            }, null), !!marginBottom && createVNode("div", {
                                style: {
                                    width: 0,
                                    height: `${marginBottom}px`
                                }
                            }, null) ]) : null, extra ? createVNode("div", {
                                class: `${baseClassName}-extra`
                            }, [ extra ]) : null ]);
                        }
                    });
                };
            }
        });
        function useDebounce(value) {
            const cacheValue = shallowRef(value.value.slice());
            let timeout = null;
            return watchEffect((() => {
                clearTimeout(timeout), timeout = setTimeout((() => {
                    cacheValue.value = value.value;
                }), value.value.length ? 0 : 10);
            })), cacheValue;
        }
        tuple("success", "warning", "error", "validating", "");
        const iconMap = {
            success: CheckCircleFilled,
            warning: ExclamationCircleFilled,
            error: CloseCircleFilled,
            validating: LoadingOutlined
        };
        function getPropByPath$1(obj, namePathList, strict) {
            let tempObj = obj;
            const keyArr = namePathList;
            let i2 = 0;
            try {
                for (let len = keyArr.length; i2 < len - 1 && (tempObj || strict); ++i2) {
                    const key2 = keyArr[i2];
                    if (!(key2 in tempObj)) {
                        if (strict) throw Error("please transfer a valid name path to form item!");
                        break;
                    }
                    tempObj = tempObj[key2];
                }
                if (strict && !tempObj) throw Error("please transfer a valid name path to form item!");
            } catch (error) {}
            return {
                o: tempObj,
                k: keyArr[i2],
                v: tempObj ? tempObj[keyArr[i2]] : void 0
            };
        }
        let indexGuid = 0;
        const defaultItemNamePrefixCls = "form_item", FormItem = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "AFormItem",
            inheritAttrs: !1,
            __ANT_NEW_FORM_ITEM: !0,
            props: (() => ({
                htmlFor: String,
                prefixCls: String,
                label: PropTypes.any,
                help: PropTypes.any,
                extra: PropTypes.any,
                labelCol: {
                    type: Object
                },
                wrapperCol: {
                    type: Object
                },
                hasFeedback: {
                    type: Boolean,
                    default: !1
                },
                colon: {
                    type: Boolean,
                    default: void 0
                },
                labelAlign: String,
                prop: {
                    type: [ String, Number, Array ]
                },
                name: {
                    type: [ String, Number, Array ]
                },
                rules: [ Array, Object ],
                autoLink: {
                    type: Boolean,
                    default: !0
                },
                required: {
                    type: Boolean,
                    default: void 0
                },
                validateFirst: {
                    type: Boolean,
                    default: void 0
                },
                validateStatus: PropTypes.oneOf(tuple("", "success", "warning", "error", "validating")),
                validateTrigger: {
                    type: [ String, Array ]
                },
                messageVariables: {
                    type: Object
                },
                hidden: Boolean,
                noStyle: Boolean,
                tooltip: String
            }))(),
            slots: Object,
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs, expose: expose} = _ref;
                warning$3(void 0 === props2.prop);
                const eventKey = "form-item-" + ++indexGuid, {prefixCls: prefixCls} = useConfigInject("form", props2), [wrapSSR, hashId] = useStyle$5(prefixCls), itemRef = shallowRef(), formContext = useInjectForm(), fieldName = computed((() => props2.name || props2.prop)), errors = shallowRef([]), validateDisabled = shallowRef(!1), inputRef = shallowRef(), namePath = computed((() => getNamePath(fieldName.value))), fieldId = computed((() => {
                    if (namePath.value.length) {
                        const formName = formContext.name.value, mergedId = namePath.value.join("_");
                        return formName ? `${formName}_${mergedId}` : `${defaultItemNamePrefixCls}_${mergedId}`;
                    }
                })), getNewFieldValue = () => {
                    const model = formContext.model.value;
                    return model && fieldName.value ? getPropByPath$1(model, namePath.value, !0).v : void 0;
                }, fieldValue = computed((() => getNewFieldValue())), initialValue = shallowRef(cloneDeep(fieldValue.value)), mergedValidateTrigger = computed((() => {
                    let validateTrigger = void 0 !== props2.validateTrigger ? props2.validateTrigger : formContext.validateTrigger.value;
                    return validateTrigger = void 0 === validateTrigger ? "change" : validateTrigger, 
                    toArray$1(validateTrigger);
                })), rulesRef = computed((() => {
                    let formRules = formContext.rules.value;
                    const selfRules = props2.rules, requiredRule = void 0 !== props2.required ? {
                        required: !!props2.required,
                        trigger: mergedValidateTrigger.value
                    } : [], prop = getPropByPath$1(formRules, namePath.value);
                    formRules = formRules ? prop.o[prop.k] || prop.v : [];
                    const rules2 = [].concat(selfRules || formRules || []);
                    return find(rules2, (rule => rule.required)) ? rules2 : rules2.concat(requiredRule);
                })), isRequired2 = computed((() => {
                    const rules2 = rulesRef.value;
                    let isRequired3 = !1;
                    return rules2 && rules2.length && rules2.every((rule => !rule.required || (isRequired3 = !0, 
                    !1))), isRequired3 || props2.required;
                })), validateState = shallowRef();
                watchEffect((() => {
                    validateState.value = props2.validateStatus;
                }));
                const messageVariables = computed((() => {
                    let variables = {};
                    return "string" == typeof props2.label ? variables.label = props2.label : props2.name && (variables.label = String(props2.name)), 
                    props2.messageVariables && (variables = _extends$1(_extends$1({}, variables), props2.messageVariables)), 
                    variables;
                })), validateRules$1 = options => {
                    if (0 === namePath.value.length) return;
                    const {validateFirst: validateFirst = !1} = props2, {triggerName: triggerName} = options || {};
                    let filteredRules = rulesRef.value;
                    if (triggerName && (filteredRules = filteredRules.filter((rule => {
                        const {trigger: trigger2} = rule;
                        if (!trigger2 && !mergedValidateTrigger.value.length) return !0;
                        return toArray$1(trigger2 || mergedValidateTrigger.value).includes(triggerName);
                    }))), !filteredRules.length) return Promise.resolve();
                    const promise = validateRules(namePath.value, fieldValue.value, filteredRules, _extends$1({
                        validateMessages: formContext.validateMessages.value
                    }, options), validateFirst, messageVariables.value);
                    return validateState.value = "validating", errors.value = [], promise.catch((e2 => e2)).then((function() {
                        let results = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        if ("validating" === validateState.value) {
                            const res = results.filter((result => result && result.errors.length));
                            validateState.value = res.length ? "error" : "success", errors.value = res.map((r2 => r2.errors)), 
                            formContext.onValidate(fieldName.value, !errors.value.length, errors.value.length ? toRaw(errors.value[0]) : null);
                        }
                    })), promise;
                }, onFieldBlur = () => {
                    validateRules$1({
                        triggerName: "blur"
                    });
                }, onFieldChange = () => {
                    validateDisabled.value ? validateDisabled.value = !1 : validateRules$1({
                        triggerName: "change"
                    });
                }, clearValidate = () => {
                    validateState.value = props2.validateStatus, validateDisabled.value = !1, errors.value = [];
                }, resetField = () => {
                    var _a;
                    validateState.value = props2.validateStatus, validateDisabled.value = !0, errors.value = [];
                    const model = formContext.model.value || {}, value = fieldValue.value, prop = getPropByPath$1(model, namePath.value, !0);
                    Array.isArray(value) ? prop.o[prop.k] = [].concat(null !== (_a = initialValue.value) && void 0 !== _a ? _a : []) : prop.o[prop.k] = initialValue.value, 
                    nextTick((() => {
                        validateDisabled.value = !1;
                    }));
                }, htmlFor = computed((() => void 0 === props2.htmlFor ? fieldId.value : props2.htmlFor)), onLabelClick = () => {
                    const id = htmlFor.value;
                    if (!id || !inputRef.value) return;
                    const control = inputRef.value.$el.querySelector(`[id="${id}"]`);
                    control && control.focus && control.focus();
                };
                expose({
                    onFieldBlur: onFieldBlur,
                    onFieldChange: onFieldChange,
                    clearValidate: clearValidate,
                    resetField: resetField
                }), useProvideFormItemContext({
                    id: fieldId,
                    onFieldBlur: () => {
                        props2.autoLink && onFieldBlur();
                    },
                    onFieldChange: () => {
                        props2.autoLink && onFieldChange();
                    },
                    clearValidate: clearValidate
                }, computed((() => !!(props2.autoLink && formContext.model.value && fieldName.value))));
                let registered = !1;
                watch(fieldName, (val => {
                    val ? registered || (registered = !0, formContext.addField(eventKey, {
                        fieldValue: fieldValue,
                        fieldId: fieldId,
                        fieldName: fieldName,
                        resetField: resetField,
                        clearValidate: clearValidate,
                        namePath: namePath,
                        validateRules: validateRules$1,
                        rules: rulesRef
                    })) : (registered = !1, formContext.removeField(eventKey));
                }), {
                    immediate: !0
                }), onBeforeUnmount((() => {
                    formContext.removeField(eventKey);
                }));
                const debounceErrors = useDebounce(errors), mergedValidateStatus = computed((() => void 0 !== props2.validateStatus ? props2.validateStatus : debounceErrors.value.length ? "error" : validateState.value)), itemClassName = computed((() => ({
                    [`${prefixCls.value}-item`]: !0,
                    [hashId.value]: !0,
                    [`${prefixCls.value}-item-has-feedback`]: mergedValidateStatus.value && props2.hasFeedback,
                    [`${prefixCls.value}-item-has-success`]: "success" === mergedValidateStatus.value,
                    [`${prefixCls.value}-item-has-warning`]: "warning" === mergedValidateStatus.value,
                    [`${prefixCls.value}-item-has-error`]: "error" === mergedValidateStatus.value,
                    [`${prefixCls.value}-item-is-validating`]: "validating" === mergedValidateStatus.value,
                    [`${prefixCls.value}-item-hidden`]: props2.hidden
                }))), formItemInputContext = reactive({});
                FormItemInputContext.useProvide(formItemInputContext), watchEffect((() => {
                    let feedbackIcon;
                    if (props2.hasFeedback) {
                        const IconNode = mergedValidateStatus.value && iconMap[mergedValidateStatus.value];
                        feedbackIcon = IconNode ? createVNode("span", {
                            class: classNames(`${prefixCls.value}-item-feedback-icon`, `${prefixCls.value}-item-feedback-icon-${mergedValidateStatus.value}`)
                        }, [ createVNode(IconNode, null, null) ]) : null;
                    }
                    _extends$1(formItemInputContext, {
                        status: mergedValidateStatus.value,
                        hasFeedback: props2.hasFeedback,
                        feedbackIcon: feedbackIcon,
                        isFormItemInput: !0
                    });
                }));
                const marginBottom = shallowRef(null), showMarginOffset = shallowRef(!1), updateMarginBottom = () => {
                    if (itemRef.value) {
                        const itemStyle = getComputedStyle(itemRef.value);
                        marginBottom.value = parseInt(itemStyle.marginBottom, 10);
                    }
                };
                onMounted((() => {
                    watch(showMarginOffset, (() => {
                        showMarginOffset.value && updateMarginBottom();
                    }), {
                        flush: "post",
                        immediate: !0
                    });
                }));
                const onErrorVisibleChanged = nextVisible => {
                    nextVisible || (marginBottom.value = null);
                };
                return () => {
                    var _a, _b;
                    if (props2.noStyle) return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                    const help = null !== (_b = props2.help) && void 0 !== _b ? _b : slots.help ? filterEmpty(slots.help()) : null, withHelp = !!(null != help && Array.isArray(help) && help.length || debounceErrors.value.length);
                    return showMarginOffset.value = withHelp, wrapSSR(createVNode("div", {
                        class: [ itemClassName.value, withHelp ? `${prefixCls.value}-item-with-help` : "", attrs.class ],
                        ref: itemRef
                    }, [ createVNode(ARow, _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: `${prefixCls.value}-item-row`,
                        key: "row"
                    }), {
                        default: () => {
                            var _a2, _b2;
                            return createVNode(Fragment, null, [ createVNode(FormItemLabel, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
                                htmlFor: htmlFor.value,
                                required: isRequired2.value,
                                requiredMark: formContext.requiredMark.value,
                                prefixCls: prefixCls.value,
                                onClick: onLabelClick,
                                label: props2.label
                            }), {
                                label: slots.label,
                                tooltip: slots.tooltip
                            }), createVNode(FormItemInput, _objectSpread2$1(_objectSpread2$1({}, props2), {}, {
                                errors: null != help ? toArray$1(help) : debounceErrors.value,
                                marginBottom: marginBottom.value,
                                prefixCls: prefixCls.value,
                                status: mergedValidateStatus.value,
                                ref: inputRef,
                                help: help,
                                extra: null !== (_a2 = props2.extra) && void 0 !== _a2 ? _a2 : null === (_b2 = slots.extra) || void 0 === _b2 ? void 0 : _b2.call(slots),
                                onErrorVisibleChanged: onErrorVisibleChanged
                            }), {
                                default: slots.default
                            }) ]);
                        }
                    }), !!marginBottom.value && createVNode("div", {
                        class: `${prefixCls.value}-margin-offset`,
                        style: {
                            marginBottom: `-${marginBottom.value}px`
                        }
                    }, null) ]));
                };
            }
        });
        function allPromiseFinish(promiseList) {
            let hasError = !1, count = promiseList.length;
            const results = [];
            return promiseList.length ? new Promise(((resolve2, reject) => {
                promiseList.forEach(((promise, index2) => {
                    promise.catch((e2 => (hasError = !0, e2))).then((result => {
                        count -= 1, results[index2] = result, count > 0 || (hasError && reject(results), 
                        resolve2(results));
                    }));
                }));
            })) : Promise.resolve([]);
        }
        function isRequired(rules2) {
            let isRequired2 = !1;
            return rules2 && rules2.length && rules2.every((rule => !rule.required || (isRequired2 = !0, 
            !1))), isRequired2;
        }
        function toArray(value) {
            return null == value ? [] : Array.isArray(value) ? value : [ value ];
        }
        function getPropByPath(obj, path, strict) {
            let tempObj = obj;
            const keyArr = (path = (path = path.replace(/\[(\w+)\]/g, ".$1")).replace(/^\./, "")).split(".");
            let i2 = 0;
            for (let len = keyArr.length; i2 < len - 1 && (tempObj || strict); ++i2) {
                const key2 = keyArr[i2];
                if (!(key2 in tempObj)) {
                    if (strict) throw new Error("please transfer a valid name path to validate!");
                    break;
                }
                tempObj = tempObj[key2];
            }
            return {
                o: tempObj,
                k: keyArr[i2],
                v: tempObj ? tempObj[keyArr[i2]] : null,
                isValid: tempObj && keyArr[i2] in tempObj
            };
        }
        function useForm(modelRef) {
            let rulesRef = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ref({}), options = arguments.length > 2 ? arguments[2] : void 0;
            const initialModel = cloneDeep(unref(modelRef)), validateInfos = reactive({}), rulesKeys = shallowRef([]), resetFields = newValues => {
                _extends$1(unref(modelRef), _extends$1(_extends$1({}, cloneDeep(initialModel)), newValues)), 
                nextTick((() => {
                    Object.keys(validateInfos).forEach((key2 => {
                        validateInfos[key2] = {
                            autoLink: !1,
                            required: isRequired(unref(rulesRef)[key2])
                        };
                    }));
                }));
            }, filterRules = function() {
                let rules2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], trigger2 = arguments.length > 1 ? arguments[1] : void 0;
                return trigger2.length ? rules2.filter((rule => {
                    const triggerList = toArray(rule.trigger || "change");
                    return intersection(triggerList, trigger2).length;
                })) : rules2;
            };
            let lastValidatePromise = null;
            const validateFields = function(names2) {
                let option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, strict = arguments.length > 2 ? arguments[2] : void 0;
                const promiseList = [], values = {};
                for (let i2 = 0; i2 < names2.length; i2++) {
                    const name = names2[i2], prop = getPropByPath(unref(modelRef), name, strict);
                    if (!prop.isValid) continue;
                    values[name] = prop.v;
                    const rules2 = filterRules(unref(rulesRef)[name], toArray(option && option.trigger));
                    rules2.length && promiseList.push(validateField(name, prop.v, rules2, option || {}).then((() => ({
                        name: name,
                        errors: [],
                        warnings: []
                    }))).catch((ruleErrors => {
                        const mergedErrors = [], mergedWarnings = [];
                        return ruleErrors.forEach((_ref => {
                            let {rule: {warningOnly: warningOnly}, errors: errors} = _ref;
                            warningOnly ? mergedWarnings.push(...errors) : mergedErrors.push(...errors);
                        })), mergedErrors.length ? Promise.reject({
                            name: name,
                            errors: mergedErrors,
                            warnings: mergedWarnings
                        }) : {
                            name: name,
                            errors: mergedErrors,
                            warnings: mergedWarnings
                        };
                    })));
                }
                const summaryPromise = allPromiseFinish(promiseList);
                lastValidatePromise = summaryPromise;
                const returnPromise = summaryPromise.then((() => lastValidatePromise === summaryPromise ? Promise.resolve(values) : Promise.reject([]))).catch((results => {
                    const errorList = results.filter((result => result && result.errors.length));
                    return errorList.length ? Promise.reject({
                        values: values,
                        errorFields: errorList,
                        outOfDate: lastValidatePromise !== summaryPromise
                    }) : Promise.resolve(values);
                }));
                return returnPromise.catch((e2 => e2)), returnPromise;
            }, validateField = function(name, value, rules2) {
                let option = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                const promise = validateRules([ name ], value, rules2, _extends$1({
                    validateMessages: defaultValidateMessages
                }, option), !!option.validateFirst);
                return validateInfos[name] ? (validateInfos[name].validateStatus = "validating", 
                promise.catch((e2 => e2)).then((function() {
                    let results = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    var _a;
                    if ("validating" === validateInfos[name].validateStatus) {
                        const res = results.filter((result => result && result.errors.length));
                        validateInfos[name].validateStatus = res.length ? "error" : "success", validateInfos[name].help = res.length ? res.map((r2 => r2.errors)) : null, 
                        null === (_a = null == options ? void 0 : options.onValidate) || void 0 === _a || _a.call(options, name, !res.length, res.length ? toRaw(validateInfos[name].help[0]) : null);
                    }
                })), promise) : promise.catch((e2 => e2));
            }, validate = (names2, option) => {
                let keys2 = [], strict = !0;
                names2 ? keys2 = Array.isArray(names2) ? names2 : [ names2 ] : (strict = !1, keys2 = rulesKeys.value);
                const promises = validateFields(keys2, option || {}, strict);
                return promises.catch((e2 => e2)), promises;
            }, clearValidate = names2 => {
                let keys2 = [];
                keys2 = names2 ? Array.isArray(names2) ? names2 : [ names2 ] : rulesKeys.value, 
                keys2.forEach((key2 => {
                    validateInfos[key2] && _extends$1(validateInfos[key2], {
                        validateStatus: "",
                        help: null
                    });
                }));
            }, mergeValidateInfo = items => {
                const info = {
                    autoLink: !1
                }, help = [], infos = Array.isArray(items) ? items : [ items ];
                for (let i2 = 0; i2 < infos.length; i2++) {
                    const arg = infos[i2];
                    "error" === (null == arg ? void 0 : arg.validateStatus) && (info.validateStatus = "error", 
                    arg.help && help.push(arg.help)), info.required = info.required || (null == arg ? void 0 : arg.required);
                }
                return info.help = help, info;
            };
            let oldModel = initialModel, isFirstTime = !0;
            const modelFn = model => {
                const names2 = [];
                rulesKeys.value.forEach((key2 => {
                    const prop = getPropByPath(model, key2, !1), oldProp = getPropByPath(oldModel, key2, !1);
                    !(isFirstTime && (null == options ? void 0 : options.immediate) && prop.isValid) && isEqual(prop.v, oldProp.v) || names2.push(key2);
                })), validate(names2, {
                    trigger: "change"
                }), isFirstTime = !1, oldModel = cloneDeep(toRaw(model));
            }, debounceOptions = null == options ? void 0 : options.debounce;
            let first = !0;
            return watch(rulesRef, (() => {
                rulesKeys.value = rulesRef ? Object.keys(unref(rulesRef)) : [], !first && options && options.validateOnRuleChange && validate(), 
                first = !1;
            }), {
                deep: !0,
                immediate: !0
            }), watch(rulesKeys, (() => {
                const newValidateInfos = {};
                rulesKeys.value.forEach((key2 => {
                    newValidateInfos[key2] = _extends$1({}, validateInfos[key2], {
                        autoLink: !1,
                        required: isRequired(unref(rulesRef)[key2])
                    }), delete validateInfos[key2];
                }));
                for (const key2 in validateInfos) Object.prototype.hasOwnProperty.call(validateInfos, key2) && delete validateInfos[key2];
                _extends$1(validateInfos, newValidateInfos);
            }), {
                immediate: !0
            }), watch(modelRef, debounceOptions && debounceOptions.wait ? debounce(modelFn, debounceOptions.wait, omit$1(debounceOptions, [ "wait" ])) : modelFn, {
                immediate: options && !!options.immediate,
                deep: !0
            }), {
                modelRef: modelRef,
                rulesRef: rulesRef,
                initialModel: initialModel,
                validateInfos: validateInfos,
                resetFields: resetFields,
                validate: validate,
                validateField: validateField,
                mergeValidateInfo: mergeValidateInfo,
                clearValidate: clearValidate
            };
        }
        function isEqualName(name1, name2) {
            return isEqual(toArray$1(name1), toArray$1(name2));
        }
        const Form = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "AForm",
            inheritAttrs: !1,
            props: initDefaultProps((() => ({
                layout: PropTypes.oneOf(tuple("horizontal", "inline", "vertical")),
                labelCol: objectType(),
                wrapperCol: objectType(),
                colon: booleanType(),
                labelAlign: stringType(),
                labelWrap: booleanType(),
                prefixCls: String,
                requiredMark: someType([ String, Boolean ]),
                hideRequiredMark: booleanType(),
                model: PropTypes.object,
                rules: objectType(),
                validateMessages: objectType(),
                validateOnRuleChange: booleanType(),
                scrollToFirstError: anyType(),
                onSubmit: functionType(),
                name: String,
                validateTrigger: someType([ String, Array ]),
                size: stringType(),
                disabled: booleanType(),
                onValuesChange: functionType(),
                onFieldsChange: functionType(),
                onFinish: functionType(),
                onFinishFailed: functionType(),
                onValidate: functionType()
            }))(), {
                layout: "horizontal",
                hideRequiredMark: !1,
                colon: !0
            }),
            Item: FormItem,
            useForm: useForm,
            setup(props2, _ref) {
                let {emit: emit2, slots: slots, expose: expose, attrs: attrs} = _ref;
                const {prefixCls: prefixCls, direction: direction, form: contextForm, size: size2, disabled: disabled} = useConfigInject("form", props2), requiredMark = computed((() => "" === props2.requiredMark || props2.requiredMark)), mergedRequiredMark = computed((() => {
                    var _a;
                    return void 0 !== requiredMark.value ? requiredMark.value : contextForm && void 0 !== (null === (_a = contextForm.value) || void 0 === _a ? void 0 : _a.requiredMark) ? contextForm.value.requiredMark : !props2.hideRequiredMark;
                }));
                useProviderSize(size2), useProviderDisabled(disabled);
                const mergedColon = computed((() => {
                    var _a, _b;
                    return null !== (_a = props2.colon) && void 0 !== _a ? _a : null === (_b = contextForm.value) || void 0 === _b ? void 0 : _b.colon;
                })), {validateMessages: globalValidateMessages} = useInjectGlobalForm(), validateMessages = computed((() => _extends$1(_extends$1(_extends$1({}, defaultValidateMessages), globalValidateMessages.value), props2.validateMessages))), [wrapSSR, hashId] = useStyle$5(prefixCls), formClassName = computed((() => classNames(prefixCls.value, {
                    [`${prefixCls.value}-${props2.layout}`]: !0,
                    [`${prefixCls.value}-hide-required-mark`]: !1 === mergedRequiredMark.value,
                    [`${prefixCls.value}-rtl`]: "rtl" === direction.value,
                    [`${prefixCls.value}-${size2.value}`]: size2.value
                }, hashId.value))), lastValidatePromise = ref(), fields = {}, addField = (eventKey, field) => {
                    fields[eventKey] = field;
                }, removeField = eventKey => {
                    delete fields[eventKey];
                }, getFieldsByNameList = nameList => {
                    const provideNameList = !!nameList, namePathList = provideNameList ? toArray$1(nameList).map(getNamePath) : [];
                    return provideNameList ? Object.values(fields).filter((field => namePathList.findIndex((namePath => isEqualName(namePath, field.fieldName.value))) > -1)) : Object.values(fields);
                }, handleFinishFailed = errorInfo => {
                    const {scrollToFirstError: scrollToFirstError} = props2;
                    if (emit2("finishFailed", errorInfo), scrollToFirstError && errorInfo.errorFields.length) {
                        let scrollToFieldOptions = {};
                        "object" == typeof scrollToFirstError && (scrollToFieldOptions = scrollToFirstError), 
                        scrollToField(errorInfo.errorFields[0].name, scrollToFieldOptions);
                    }
                }, validate = function() {
                    return validateField(...arguments);
                }, scrollToField = function(name) {
                    let options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const fields2 = getFieldsByNameList(name ? [ name ] : void 0);
                    if (fields2.length) {
                        const fieldId = fields2[0].fieldId.value, node2 = fieldId ? document.getElementById(fieldId) : null;
                        node2 && scrollIntoView(node2, _extends$1({
                            scrollMode: "if-needed",
                            block: "nearest"
                        }, options));
                    }
                }, getFieldsValue = function() {
                    let nameList = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    if (!0 === nameList) {
                        const allNameList = [];
                        return Object.values(fields).forEach((_ref2 => {
                            let {namePath: namePath} = _ref2;
                            allNameList.push(namePath.value);
                        })), cloneByNamePathList(props2.model, allNameList);
                    }
                    return cloneByNamePathList(props2.model, nameList);
                }, validateFields = (nameList, options) => {
                    if (!props2.model) return Promise.reject("Form `model` is required for validateFields to work.");
                    const provideNameList = !!nameList, namePathList = provideNameList ? toArray$1(nameList).map(getNamePath) : [], promiseList = [];
                    Object.values(fields).forEach((field => {
                        var _a;
                        if (provideNameList || namePathList.push(field.namePath.value), !(null === (_a = field.rules) || void 0 === _a ? void 0 : _a.value.length)) return;
                        const fieldNamePath = field.namePath.value;
                        if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
                            const promise = field.validateRules(_extends$1({
                                validateMessages: validateMessages.value
                            }, options));
                            promiseList.push(promise.then((() => ({
                                name: fieldNamePath,
                                errors: [],
                                warnings: []
                            }))).catch((ruleErrors => {
                                const mergedErrors = [], mergedWarnings = [];
                                return ruleErrors.forEach((_ref3 => {
                                    let {rule: {warningOnly: warningOnly}, errors: errors} = _ref3;
                                    warningOnly ? mergedWarnings.push(...errors) : mergedErrors.push(...errors);
                                })), mergedErrors.length ? Promise.reject({
                                    name: fieldNamePath,
                                    errors: mergedErrors,
                                    warnings: mergedWarnings
                                }) : {
                                    name: fieldNamePath,
                                    errors: mergedErrors,
                                    warnings: mergedWarnings
                                };
                            })));
                        }
                    }));
                    const summaryPromise = allPromiseFinish(promiseList);
                    lastValidatePromise.value = summaryPromise;
                    const returnPromise = summaryPromise.then((() => lastValidatePromise.value === summaryPromise ? Promise.resolve(getFieldsValue(namePathList)) : Promise.reject([]))).catch((results => {
                        const errorList = results.filter((result => result && result.errors.length));
                        return Promise.reject({
                            values: getFieldsValue(namePathList),
                            errorFields: errorList,
                            outOfDate: lastValidatePromise.value !== summaryPromise
                        });
                    }));
                    return returnPromise.catch((e2 => e2)), returnPromise;
                }, validateField = function() {
                    return validateFields(...arguments);
                }, handleSubmit = e2 => {
                    if (e2.preventDefault(), e2.stopPropagation(), emit2("submit", e2), props2.model) {
                        validateFields().then((values => {
                            emit2("finish", values);
                        })).catch((errors => {
                            handleFinishFailed(errors);
                        }));
                    }
                };
                return expose({
                    resetFields: name => {
                        props2.model && getFieldsByNameList(name).forEach((field => {
                            field.resetField();
                        }));
                    },
                    clearValidate: name => {
                        getFieldsByNameList(name).forEach((field => {
                            field.clearValidate();
                        }));
                    },
                    validateFields: validateFields,
                    getFieldsValue: getFieldsValue,
                    validate: validate,
                    scrollToField: scrollToField
                }), useProvideForm({
                    model: computed((() => props2.model)),
                    name: computed((() => props2.name)),
                    labelAlign: computed((() => props2.labelAlign)),
                    labelCol: computed((() => props2.labelCol)),
                    labelWrap: computed((() => props2.labelWrap)),
                    wrapperCol: computed((() => props2.wrapperCol)),
                    vertical: computed((() => "vertical" === props2.layout)),
                    colon: mergedColon,
                    requiredMark: mergedRequiredMark,
                    validateTrigger: computed((() => props2.validateTrigger)),
                    rules: computed((() => props2.rules)),
                    addField: addField,
                    removeField: removeField,
                    onValidate: (name, status, errors) => {
                        emit2("validate", name, status, errors);
                    },
                    validateMessages: validateMessages
                }), watch((() => props2.rules), (() => {
                    props2.validateOnRuleChange && validateFields();
                })), () => {
                    var _a;
                    return wrapSSR(createVNode("form", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        onSubmit: handleSubmit,
                        class: [ formClassName.value, attrs.class ]
                    }), [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]));
                };
            }
        });
        Form.useInjectFormItemContext = useInjectFormItemContext, Form.ItemRest = FormItemRest, 
        Form.install = function(app) {
            return app.component(Form.name, Form), app.component(Form.Item.name, Form.Item), 
            app.component(FormItemRest.name, FormItemRest), app;
        };
        let runtimeLocale = _extends$1({}, localeValues.Modal);
        function changeConfirmLocale(newLocale) {
            runtimeLocale = newLocale ? _extends$1(_extends$1({}, runtimeLocale), newLocale) : _extends$1({}, localeValues.Modal);
        }
        const ANT_MARK = "internalMark", LocaleProvider = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ALocaleProvider",
            props: {
                locale: {
                    type: Object
                },
                ANT_MARK__: String
            },
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                warning$2(props2.ANT_MARK__ === ANT_MARK);
                const state = reactive({
                    antLocale: _extends$1(_extends$1({}, props2.locale), {
                        exist: !0
                    }),
                    ANT_MARK__: ANT_MARK
                });
                return provide("localeData", state), watch((() => props2.locale), (locale2 => {
                    changeConfirmLocale(locale2 && locale2.Modal), state.antLocale = _extends$1(_extends$1({}, locale2), {
                        exist: !0
                    });
                }), {
                    immediate: !0
                }), () => {
                    var _a;
                    return null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots);
                };
            }
        });
        LocaleProvider.install = function(app) {
            return app.component(LocaleProvider.name, LocaleProvider), app;
        };
        const locale = withInstall(LocaleProvider), Notice = defineComponent({
            name: "Notice",
            inheritAttrs: !1,
            props: [ "prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible" ],
            setup(props2, _ref) {
                let closeTimer, {attrs: attrs, slots: slots} = _ref, isUnMounted = !1;
                const duration = computed((() => void 0 === props2.duration ? 4.5 : props2.duration)), startCloseTimer = () => {
                    duration.value && !isUnMounted && (closeTimer = setTimeout((() => {
                        close();
                    }), 1e3 * duration.value));
                }, clearCloseTimer = () => {
                    closeTimer && (clearTimeout(closeTimer), closeTimer = null);
                }, close = e2 => {
                    e2 && e2.stopPropagation(), clearCloseTimer();
                    const {onClose: onClose, noticeKey: noticeKey} = props2;
                    onClose && onClose(noticeKey);
                }, restartCloseTimer = () => {
                    clearCloseTimer(), startCloseTimer();
                };
                return onMounted((() => {
                    startCloseTimer();
                })), onUnmounted((() => {
                    isUnMounted = !0, clearCloseTimer();
                })), watch([ duration, () => props2.updateMark, () => props2.visible ], ((_ref2, _ref3) => {
                    let [preDuration, preUpdateMark, preVisible] = _ref2, [newDuration, newUpdateMark, newVisible] = _ref3;
                    (preDuration !== newDuration || preUpdateMark !== newUpdateMark || preVisible !== newVisible && newVisible) && restartCloseTimer();
                }), {
                    flush: "post"
                }), () => {
                    var _a, _b;
                    const {prefixCls: prefixCls, closable: closable, closeIcon: closeIcon = (null === (_a = slots.closeIcon) || void 0 === _a ? void 0 : _a.call(slots)), onClick: onClick, holder: holder} = props2, {class: className, style: style} = attrs, componentClass = `${prefixCls}-notice`, dataOrAriaAttributeProps = Object.keys(attrs).reduce(((acc, key2) => ((key2.startsWith("data-") || key2.startsWith("aria-") || "role" === key2) && (acc[key2] = attrs[key2]), 
                    acc)), {}), node2 = createVNode("div", _objectSpread2$1({
                        class: classNames(componentClass, className, {
                            [`${componentClass}-closable`]: closable
                        }),
                        style: style,
                        onMouseenter: clearCloseTimer,
                        onMouseleave: startCloseTimer,
                        onClick: onClick
                    }, dataOrAriaAttributeProps), [ createVNode("div", {
                        class: `${componentClass}-content`
                    }, [ null === (_b = slots.default) || void 0 === _b ? void 0 : _b.call(slots) ]), closable ? createVNode("a", {
                        tabindex: 0,
                        onClick: close,
                        class: `${componentClass}-close`
                    }, [ closeIcon || createVNode("span", {
                        class: `${componentClass}-close-x`
                    }, null) ]) : null ]);
                    return holder ? createVNode(Teleport, {
                        to: holder
                    }, {
                        default: () => node2
                    }) : node2;
                };
            }
        });
        var __rest$7 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        let seed$1 = 0;
        const now$1 = Date.now();
        function getUuid$1() {
            const id = seed$1;
            return seed$1 += 1, `rcNotification_${now$1}_${id}`;
        }
        const Notification$1 = defineComponent({
            name: "Notification",
            inheritAttrs: !1,
            props: [ "prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId" ],
            setup(props2, _ref) {
                let {attrs: attrs, expose: expose, slots: slots} = _ref;
                const hookRefs = new Map, notices = ref([]), transitionProps = computed((() => {
                    const {prefixCls: prefixCls, animation: animation = "fade"} = props2;
                    let name = props2.transitionName;
                    return !name && animation && (name = `${prefixCls}-${animation}`), getTransitionGroupProps(name);
                })), remove2 = removeKey => {
                    notices.value = notices.value.filter((_ref2 => {
                        let {notice: {key: key2, userPassKey: userPassKey}} = _ref2;
                        return (userPassKey || key2) !== removeKey;
                    }));
                };
                return expose({
                    add: (originNotice, holderCallback) => {
                        const key2 = originNotice.key || getUuid$1(), notice2 = _extends$1(_extends$1({}, originNotice), {
                            key: key2
                        }), {maxCount: maxCount2} = props2, noticeIndex = notices.value.map((v2 => v2.notice.key)).indexOf(key2), updatedNotices = notices.value.concat();
                        -1 !== noticeIndex ? updatedNotices.splice(noticeIndex, 1, {
                            notice: notice2,
                            holderCallback: holderCallback
                        }) : (maxCount2 && notices.value.length >= maxCount2 && (notice2.key = updatedNotices[0].notice.key, 
                        notice2.updateMark = getUuid$1(), notice2.userPassKey = key2, updatedNotices.shift()), 
                        updatedNotices.push({
                            notice: notice2,
                            holderCallback: holderCallback
                        })), notices.value = updatedNotices;
                    },
                    remove: remove2,
                    notices: notices
                }), () => {
                    var _a;
                    const {prefixCls: prefixCls, closeIcon: closeIcon = (null === (_a = slots.closeIcon) || void 0 === _a ? void 0 : _a.call(slots, {
                        prefixCls: prefixCls
                    }))} = props2, noticeNodes = notices.value.map(((_ref3, index2) => {
                        let {notice: notice2, holderCallback: holderCallback} = _ref3;
                        const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0, {key: key2, userPassKey: userPassKey} = notice2, {content: content} = notice2, noticeProps = _extends$1(_extends$1(_extends$1({
                            prefixCls: prefixCls,
                            closeIcon: "function" == typeof closeIcon ? closeIcon({
                                prefixCls: prefixCls
                            }) : closeIcon
                        }, notice2), notice2.props), {
                            key: key2,
                            noticeKey: userPassKey || key2,
                            updateMark: updateMark,
                            onClose: noticeKey => {
                                var _a2;
                                remove2(noticeKey), null === (_a2 = notice2.onClose) || void 0 === _a2 || _a2.call(notice2);
                            },
                            onClick: notice2.onClick
                        });
                        return holderCallback ? createVNode("div", {
                            key: key2,
                            class: `${prefixCls}-hook-holder`,
                            ref: div => {
                                void 0 !== key2 && (div ? (hookRefs.set(key2, div), holderCallback(div, noticeProps)) : hookRefs.delete(key2));
                            }
                        }, null) : createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
                            class: classNames(noticeProps.class, props2.hashId)
                        }), {
                            default: () => [ "function" == typeof content ? content({
                                prefixCls: prefixCls
                            }) : content ]
                        });
                    })), className = {
                        [prefixCls]: 1,
                        [attrs.class]: !!attrs.class,
                        [props2.hashId]: !0
                    };
                    return createVNode("div", {
                        class: className,
                        style: attrs.style || {
                            top: "65px",
                            left: "50%"
                        }
                    }, [ createVNode(TransitionGroup, _objectSpread2$1({
                        tag: "div"
                    }, transitionProps.value), {
                        default: () => [ noticeNodes ]
                    }) ]);
                };
            }
        });
        Notification$1.newInstance = function newNotificationInstance(properties, callback) {
            const _a = properties || {}, {name: name = "notification", getContainer: getContainer2, appContext: appContext, prefixCls: customizePrefixCls, rootPrefixCls: customRootPrefixCls, transitionName: customTransitionName, hasTransitionName: hasTransitionName2, useStyle: useStyle2} = _a, props2 = __rest$7(_a, [ "name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle" ]), div = document.createElement("div");
            if (getContainer2) {
                getContainer2().appendChild(div);
            } else document.body.appendChild(div);
            const Wrapper = defineComponent({
                compatConfig: {
                    MODE: 3
                },
                name: "NotificationWrapper",
                setup(_props, _ref4) {
                    let {attrs: attrs} = _ref4;
                    const notiRef = shallowRef(), prefixCls = computed((() => globalConfigForApi.getPrefixCls(name, customizePrefixCls))), [, hashId] = useStyle2(prefixCls);
                    return onMounted((() => {
                        callback({
                            notice(noticeProps) {
                                var _a2;
                                null === (_a2 = notiRef.value) || void 0 === _a2 || _a2.add(noticeProps);
                            },
                            removeNotice(key2) {
                                var _a2;
                                null === (_a2 = notiRef.value) || void 0 === _a2 || _a2.remove(key2);
                            },
                            destroy() {
                                render(null, div), div.parentNode && div.parentNode.removeChild(div);
                            },
                            component: notiRef
                        });
                    })), () => {
                        const global2 = globalConfigForApi, rootPrefixCls = global2.getRootPrefixCls(customRootPrefixCls, prefixCls.value), transitionName2 = hasTransitionName2 ? customTransitionName : `${prefixCls.value}-${customTransitionName}`;
                        return createVNode(ConfigProvider, _objectSpread2$1(_objectSpread2$1({}, global2), {}, {
                            prefixCls: rootPrefixCls
                        }), {
                            default: () => [ createVNode(Notification$1, _objectSpread2$1(_objectSpread2$1({
                                ref: notiRef
                            }, attrs), {}, {
                                prefixCls: prefixCls.value,
                                transitionName: transitionName2,
                                hashId: hashId.value
                            }), null) ]
                        });
                    };
                }
            }), vm = createVNode(Wrapper, props2);
            vm.appContext = appContext || vm.appContext, render(vm, div);
        };
        let seed = 0;
        const now = Date.now();
        function getUuid() {
            const id = seed;
            return seed += 1, `rcNotification_${now}_${id}`;
        }
        const HookNotification = defineComponent({
            name: "HookNotification",
            inheritAttrs: !1,
            props: [ "prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer" ],
            setup(props2, _ref) {
                let {attrs: attrs, slots: slots} = _ref;
                const hookRefs = new Map, notices = computed((() => props2.notices)), transitionProps = computed((() => {
                    let name = props2.transitionName;
                    if (!name && props2.animation) switch (typeof props2.animation) {
                      case "string":
                        name = props2.animation;
                        break;

                      case "function":
                        name = props2.animation().name;
                        break;

                      case "object":
                        name = props2.animation.name;
                        break;

                      default:
                        name = `${props2.prefixCls}-fade`;
                    }
                    return getTransitionGroupProps(name);
                })), remove2 = key2 => props2.remove(key2), placements2 = ref({});
                watch(notices, (() => {
                    const nextPlacements = {};
                    Object.keys(placements2.value).forEach((placement => {
                        nextPlacements[placement] = [];
                    })), props2.notices.forEach((config => {
                        const {placement: placement = "topRight"} = config.notice;
                        placement && (nextPlacements[placement] = nextPlacements[placement] || [], nextPlacements[placement].push(config));
                    })), placements2.value = nextPlacements;
                }));
                const placementList = computed((() => Object.keys(placements2.value)));
                return () => {
                    var _a;
                    const {prefixCls: prefixCls, closeIcon: closeIcon = (null === (_a = slots.closeIcon) || void 0 === _a ? void 0 : _a.call(slots, {
                        prefixCls: prefixCls
                    }))} = props2, noticeNodes = placementList.value.map((placement => {
                        var _a2, _b;
                        const noticesForPlacement = placements2.value[placement], classes = null === (_a2 = props2.getClassName) || void 0 === _a2 ? void 0 : _a2.call(props2, placement), styles = null === (_b = props2.getStyles) || void 0 === _b ? void 0 : _b.call(props2, placement), noticeNodesForPlacement = noticesForPlacement.map(((_ref2, index2) => {
                            let {notice: notice2, holderCallback: holderCallback} = _ref2;
                            const updateMark = index2 === notices.value.length - 1 ? notice2.updateMark : void 0, {key: key2, userPassKey: userPassKey} = notice2, {content: content} = notice2, noticeProps = _extends$1(_extends$1(_extends$1({
                                prefixCls: prefixCls,
                                closeIcon: "function" == typeof closeIcon ? closeIcon({
                                    prefixCls: prefixCls
                                }) : closeIcon
                            }, notice2), notice2.props), {
                                key: key2,
                                noticeKey: userPassKey || key2,
                                updateMark: updateMark,
                                onClose: noticeKey => {
                                    var _a3;
                                    remove2(noticeKey), null === (_a3 = notice2.onClose) || void 0 === _a3 || _a3.call(notice2);
                                },
                                onClick: notice2.onClick
                            });
                            return holderCallback ? createVNode("div", {
                                key: key2,
                                class: `${prefixCls}-hook-holder`,
                                ref: div => {
                                    void 0 !== key2 && (div ? (hookRefs.set(key2, div), holderCallback(div, noticeProps)) : hookRefs.delete(key2));
                                }
                            }, null) : createVNode(Notice, _objectSpread2$1(_objectSpread2$1({}, noticeProps), {}, {
                                class: classNames(noticeProps.class, props2.hashId)
                            }), {
                                default: () => [ "function" == typeof content ? content({
                                    prefixCls: prefixCls
                                }) : content ]
                            });
                        })), className = {
                            [prefixCls]: 1,
                            [`${prefixCls}-${placement}`]: 1,
                            [attrs.class]: !!attrs.class,
                            [props2.hashId]: !0,
                            [classes]: !!classes
                        };
                        function onAfterLeave() {
                            var _a3;
                            noticesForPlacement.length > 0 || (Reflect.deleteProperty(placements2.value, placement), 
                            null === (_a3 = props2.onAllRemoved) || void 0 === _a3 || _a3.call(props2));
                        }
                        return createVNode("div", {
                            key: placement,
                            class: className,
                            style: attrs.style || styles || {
                                top: "65px",
                                left: "50%"
                            }
                        }, [ createVNode(TransitionGroup, _objectSpread2$1(_objectSpread2$1({
                            tag: "div"
                        }, transitionProps.value), {}, {
                            onAfterLeave: onAfterLeave
                        }), {
                            default: () => [ noticeNodesForPlacement ]
                        }) ]);
                    }));
                    return createVNode(Portal$1, {
                        getContainer: props2.getContainer
                    }, {
                        default: () => [ noticeNodes ]
                    });
                };
            }
        });
        var __rest$6 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const defaultGetContainer$1 = () => document.body;
        let uniqueKey = 0;
        function mergeConfig() {
            const clone = {};
            for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) objList[_key] = arguments[_key];
            return objList.forEach((obj => {
                obj && Object.keys(obj).forEach((key2 => {
                    const val = obj[key2];
                    void 0 !== val && (clone[key2] = val);
                }));
            })), clone;
        }
        function useNotification$1() {
            let rootConfig = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {getContainer: getContainer2 = defaultGetContainer$1, motion: motion, prefixCls: prefixCls, maxCount: maxCount2, getClassName: getClassName, getStyles: getStyles, onAllRemoved: onAllRemoved} = rootConfig, shareConfig = __rest$6(rootConfig, [ "getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved" ]), notices = shallowRef([]), notificationsRef = shallowRef(), add2 = (originNotice, holderCallback) => {
                const key2 = originNotice.key || getUuid(), notice2 = _extends$1(_extends$1({}, originNotice), {
                    key: key2
                }), noticeIndex = notices.value.map((v2 => v2.notice.key)).indexOf(key2), updatedNotices = notices.value.concat();
                -1 !== noticeIndex ? updatedNotices.splice(noticeIndex, 1, {
                    notice: notice2,
                    holderCallback: holderCallback
                }) : (maxCount2 && notices.value.length >= maxCount2 && (notice2.key = updatedNotices[0].notice.key, 
                notice2.updateMark = getUuid(), notice2.userPassKey = key2, updatedNotices.shift()), 
                updatedNotices.push({
                    notice: notice2,
                    holderCallback: holderCallback
                })), notices.value = updatedNotices;
            }, removeNotice = removeKey => {
                notices.value = notices.value.filter((_ref => {
                    let {notice: {key: key2, userPassKey: userPassKey}} = _ref;
                    return (userPassKey || key2) !== removeKey;
                }));
            }, destroy = () => {
                notices.value = [];
            }, contextHolder = () => createVNode(HookNotification, {
                ref: notificationsRef,
                prefixCls: prefixCls,
                maxCount: maxCount2,
                notices: notices.value,
                remove: removeNotice,
                getClassName: getClassName,
                getStyles: getStyles,
                animation: motion,
                hashId: rootConfig.hashId,
                onAllRemoved: onAllRemoved,
                getContainer: getContainer2
            }, null), taskQueue = shallowRef([]), api2 = {
                open: config => {
                    const mergedConfig = mergeConfig(shareConfig, config);
                    null !== mergedConfig.key && void 0 !== mergedConfig.key || (mergedConfig.key = `vc-notification-${uniqueKey}`, 
                    uniqueKey += 1), taskQueue.value = [ ...taskQueue.value, {
                        type: "open",
                        config: mergedConfig
                    } ];
                },
                close: key2 => {
                    taskQueue.value = [ ...taskQueue.value, {
                        type: "close",
                        key: key2
                    } ];
                },
                destroy: () => {
                    taskQueue.value = [ ...taskQueue.value, {
                        type: "destroy"
                    } ];
                }
            };
            return watch(taskQueue, (() => {
                taskQueue.value.length && (taskQueue.value.forEach((task => {
                    switch (task.type) {
                      case "open":
                        add2(task.config);
                        break;

                      case "close":
                        removeNotice(task.key);
                        break;

                      case "destroy":
                        destroy();
                    }
                })), taskQueue.value = []);
            })), [ api2, contextHolder ];
        }
        const genMessageStyle = token2 => {
            const {componentCls: componentCls, iconCls: iconCls, boxShadowSecondary: boxShadowSecondary, colorBgElevated: colorBgElevated, colorSuccess: colorSuccess, colorError: colorError, colorWarning: colorWarning, colorInfo: colorInfo, fontSizeLG: fontSizeLG, motionEaseInOutCirc: motionEaseInOutCirc, motionDurationSlow: motionDurationSlow, marginXS: marginXS, paddingXS: paddingXS, borderRadiusLG: borderRadiusLG, zIndexPopup: zIndexPopup, messageNoticeContentPadding: messageNoticeContentPadding} = token2, messageMoveIn = new Keyframe("MessageMoveIn", {
                "0%": {
                    padding: 0,
                    transform: "translateY(-100%)",
                    opacity: 0
                },
                "100%": {
                    padding: paddingXS,
                    transform: "translateY(0)",
                    opacity: 1
                }
            }), messageMoveOut = new Keyframe("MessageMoveOut", {
                "0%": {
                    maxHeight: token2.height,
                    padding: paddingXS,
                    opacity: 1
                },
                "100%": {
                    maxHeight: 0,
                    padding: 0,
                    opacity: 0
                }
            });
            return [ {
                [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    position: "fixed",
                    top: marginXS,
                    left: "50%",
                    transform: "translateX(-50%)",
                    width: "100%",
                    pointerEvents: "none",
                    zIndex: zIndexPopup,
                    [`${componentCls}-move-up`]: {
                        animationFillMode: "forwards"
                    },
                    [`\n        ${componentCls}-move-up-appear,\n        ${componentCls}-move-up-enter\n      `]: {
                        animationName: messageMoveIn,
                        animationDuration: motionDurationSlow,
                        animationPlayState: "paused",
                        animationTimingFunction: motionEaseInOutCirc
                    },
                    [`\n        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,\n        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active\n      `]: {
                        animationPlayState: "running"
                    },
                    [`${componentCls}-move-up-leave`]: {
                        animationName: messageMoveOut,
                        animationDuration: motionDurationSlow,
                        animationPlayState: "paused",
                        animationTimingFunction: motionEaseInOutCirc
                    },
                    [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
                        animationPlayState: "running"
                    },
                    "&-rtl": {
                        direction: "rtl",
                        span: {
                            direction: "rtl"
                        }
                    }
                })
            }, {
                [`${componentCls}-notice`]: {
                    padding: paddingXS,
                    textAlign: "center",
                    [iconCls]: {
                        verticalAlign: "text-bottom",
                        marginInlineEnd: marginXS,
                        fontSize: fontSizeLG
                    },
                    [`${componentCls}-notice-content`]: {
                        display: "inline-block",
                        padding: messageNoticeContentPadding,
                        background: colorBgElevated,
                        borderRadius: borderRadiusLG,
                        boxShadow: boxShadowSecondary,
                        pointerEvents: "all"
                    },
                    [`${componentCls}-success ${iconCls}`]: {
                        color: colorSuccess
                    },
                    [`${componentCls}-error ${iconCls}`]: {
                        color: colorError
                    },
                    [`${componentCls}-warning ${iconCls}`]: {
                        color: colorWarning
                    },
                    [`\n        ${componentCls}-info ${iconCls},\n        ${componentCls}-loading ${iconCls}`]: {
                        color: colorInfo
                    }
                }
            }, {
                [`${componentCls}-notice-pure-panel`]: {
                    padding: 0,
                    textAlign: "start"
                }
            } ];
        }, useStyle$4 = genComponentStyleHook("Message", (token2 => {
            const combinedToken = merge(token2, {
                messageNoticeContentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
            });
            return [ genMessageStyle(combinedToken) ];
        }), (token2 => ({
            height: 150,
            zIndexPopup: token2.zIndexPopupBase + 10
        }))), TypeIcon = {
            info: createVNode(InfoCircleFilled, null, null),
            success: createVNode(CheckCircleFilled, null, null),
            error: createVNode(CloseCircleFilled, null, null),
            warning: createVNode(ExclamationCircleFilled, null, null),
            loading: createVNode(LoadingOutlined, null, null)
        }, PureContent$1 = defineComponent({
            name: "PureContent",
            inheritAttrs: !1,
            props: [ "prefixCls", "type", "icon" ],
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                return () => {
                    var _a;
                    return createVNode("div", {
                        class: classNames(`${props2.prefixCls}-custom-content`, `${props2.prefixCls}-${props2.type}`)
                    }, [ props2.icon || TypeIcon[props2.type], createVNode("span", null, [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]) ]);
                };
            }
        });
        var __rest$5 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const DEFAULT_OFFSET$1 = 8, DEFAULT_DURATION$1 = 3, Holder$1 = defineComponent({
            name: "Holder",
            inheritAttrs: !1,
            props: [ "top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved" ],
            setup(props2, _ref) {
                let {expose: expose} = _ref;
                var _a, _b;
                const {getPrefixCls: getPrefixCls, getPopupContainer: getPopupContainer} = useConfigInject("message", props2), prefixCls = computed((() => getPrefixCls("message", props2.prefixCls))), [, hashId] = useStyle$4(prefixCls), getStyles = () => {
                    var _a2;
                    const top = null !== (_a2 = props2.top) && void 0 !== _a2 ? _a2 : DEFAULT_OFFSET$1;
                    return {
                        left: "50%",
                        transform: "translateX(-50%)",
                        top: "number" == typeof top ? `${top}px` : top
                    };
                }, getClassName = () => classNames(hashId.value, props2.rtl ? `${prefixCls.value}-rtl` : ""), getNotificationMotion = () => {
                    var _a2;
                    return getMotion$1({
                        prefixCls: prefixCls.value,
                        animation: null !== (_a2 = props2.animation) && void 0 !== _a2 ? _a2 : "move-up",
                        transitionName: props2.transitionName
                    });
                }, mergedCloseIcon = createVNode("span", {
                    class: `${prefixCls.value}-close-x`
                }, [ createVNode(CloseOutlined, {
                    class: `${prefixCls.value}-close-icon`
                }, null) ]), [api2, holder] = useNotification$1({
                    getStyles: getStyles,
                    prefixCls: prefixCls.value,
                    getClassName: getClassName,
                    motion: getNotificationMotion,
                    closable: !1,
                    closeIcon: mergedCloseIcon,
                    duration: null !== (_a = props2.duration) && void 0 !== _a ? _a : DEFAULT_DURATION$1,
                    getContainer: null !== (_b = props2.staticGetContainer) && void 0 !== _b ? _b : getPopupContainer.value,
                    maxCount: props2.maxCount,
                    onAllRemoved: props2.onAllRemoved
                });
                return expose(_extends$1(_extends$1({}, api2), {
                    prefixCls: prefixCls,
                    hashId: hashId
                })), holder;
            }
        });
        let keyIndex = 0;
        function useInternalMessage(messageConfig) {
            const holderRef = shallowRef(null), holderKey = Symbol("messageHolderKey"), close = key2 => {
                var _a;
                null === (_a = holderRef.value) || void 0 === _a || _a.close(key2);
            }, open2 = config => {
                if (!holderRef.value) {
                    const fakeResult = () => {};
                    return fakeResult.then = () => {}, fakeResult;
                }
                const {open: originOpen, prefixCls: prefixCls, hashId: hashId} = holderRef.value, noticePrefixCls = `${prefixCls}-notice`, {content: content, icon: icon, type: type, key: key2, class: className, onClose: onClose} = config, restConfig = __rest$5(config, [ "content", "icon", "type", "key", "class", "onClose" ]);
                let mergedKey = key2;
                return null == mergedKey && (keyIndex += 1, mergedKey = `antd-message-${keyIndex}`), 
                wrapPromiseFn((resolve2 => (originOpen(_extends$1(_extends$1({}, restConfig), {
                    key: mergedKey,
                    content: () => createVNode(PureContent$1, {
                        prefixCls: prefixCls,
                        type: type,
                        icon: "function" == typeof icon ? icon() : icon
                    }, {
                        default: () => [ "function" == typeof content ? content() : content ]
                    }),
                    placement: "top",
                    class: classNames(type && `${noticePrefixCls}-${type}`, hashId, className),
                    onClose: () => {
                        null == onClose || onClose(), resolve2();
                    }
                })), () => {
                    close(mergedKey);
                })));
            }, wrapAPI = {
                open: open2,
                destroy: key2 => {
                    var _a;
                    void 0 !== key2 ? close(key2) : null === (_a = holderRef.value) || void 0 === _a || _a.destroy();
                }
            };
            return [ "info", "success", "warning", "error", "loading" ].forEach((type => {
                const typeOpen = (jointContent, duration, onClose) => {
                    let config, mergedDuration, mergedOnClose;
                    config = jointContent && "object" == typeof jointContent && "content" in jointContent ? jointContent : {
                        content: jointContent
                    }, "function" == typeof duration ? mergedOnClose = duration : (mergedDuration = duration, 
                    mergedOnClose = onClose);
                    const mergedConfig = _extends$1(_extends$1({
                        onClose: mergedOnClose,
                        duration: mergedDuration
                    }, config), {
                        type: type
                    });
                    return open2(mergedConfig);
                };
                wrapAPI[type] = typeOpen;
            })), [ wrapAPI, () => createVNode(Holder$1, _objectSpread2$1(_objectSpread2$1({
                key: holderKey
            }, messageConfig), {}, {
                ref: holderRef
            }), null) ];
        }
        function useMessage(messageConfig) {
            return useInternalMessage(messageConfig);
        }
        let defaultTop$1, messageInstance, maxCount$1, defaultDuration$1 = 3, key = 1, localPrefixCls = "", transitionName = "move-up", hasTransitionName = !1, getContainer = () => document.body, rtl$1 = !1;
        function getKeyThenIncreaseKey() {
            return key++;
        }
        function setMessageConfig(options) {
            void 0 !== options.top && (defaultTop$1 = options.top, messageInstance = null), 
            void 0 !== options.duration && (defaultDuration$1 = options.duration), void 0 !== options.prefixCls && (localPrefixCls = options.prefixCls), 
            void 0 !== options.getContainer && (getContainer = options.getContainer, messageInstance = null), 
            void 0 !== options.transitionName && (transitionName = options.transitionName, messageInstance = null, 
            hasTransitionName = !0), void 0 !== options.maxCount && (maxCount$1 = options.maxCount, 
            messageInstance = null), void 0 !== options.rtl && (rtl$1 = options.rtl);
        }
        function getMessageInstance(args, callback) {
            messageInstance ? callback(messageInstance) : Notification$1.newInstance({
                appContext: args.appContext,
                prefixCls: args.prefixCls || localPrefixCls,
                rootPrefixCls: args.rootPrefixCls,
                transitionName: transitionName,
                hasTransitionName: hasTransitionName,
                style: {
                    top: defaultTop$1
                },
                getContainer: getContainer || args.getPopupContainer,
                maxCount: maxCount$1,
                name: "message",
                useStyle: useStyle$4
            }, (instance => {
                messageInstance ? callback(messageInstance) : (messageInstance = instance, callback(instance));
            }));
        }
        const typeToIcon$2 = {
            info: InfoCircleFilled,
            success: CheckCircleFilled,
            error: CloseCircleFilled,
            warning: ExclamationCircleFilled,
            loading: LoadingOutlined
        }, typeList = Object.keys(typeToIcon$2);
        function notice$1(args) {
            const duration = void 0 !== args.duration ? args.duration : defaultDuration$1, target = args.key || getKeyThenIncreaseKey(), closePromise = new Promise((resolve2 => {
                const callback = () => ("function" == typeof args.onClose && args.onClose(), resolve2(!0));
                getMessageInstance(args, (instance => {
                    instance.notice({
                        key: target,
                        duration: duration,
                        style: args.style || {},
                        class: args.class,
                        content: _ref => {
                            let {prefixCls: prefixCls} = _ref;
                            const Icon2 = typeToIcon$2[args.type], iconNode = Icon2 ? createVNode(Icon2, null, null) : "", messageClass = classNames(`${prefixCls}-custom-content`, {
                                [`${prefixCls}-${args.type}`]: args.type,
                                [`${prefixCls}-rtl`]: !0 === rtl$1
                            });
                            return createVNode("div", {
                                class: messageClass
                            }, [ "function" == typeof args.icon ? args.icon() : args.icon || iconNode, createVNode("span", null, [ "function" == typeof args.content ? args.content() : args.content ]) ]);
                        },
                        onClose: callback,
                        onClick: args.onClick
                    });
                }));
            })), result = () => {
                messageInstance && messageInstance.removeNotice(target);
            };
            return result.then = (filled, rejected) => closePromise.then(filled, rejected), 
            result.promise = closePromise, result;
        }
        function isArgsProps(content) {
            return "[object Object]" === Object.prototype.toString.call(content) && !!content.content;
        }
        const api$1 = {
            open: notice$1,
            config: setMessageConfig,
            destroy(messageKey) {
                if (messageInstance) if (messageKey) {
                    const {removeNotice: removeNotice} = messageInstance;
                    removeNotice(messageKey);
                } else {
                    const {destroy: destroy} = messageInstance;
                    destroy(), messageInstance = null;
                }
            }
        };
        function attachTypeApi(originalApi, type) {
            originalApi[type] = (content, duration, onClose) => isArgsProps(content) ? originalApi.open(_extends$1(_extends$1({}, content), {
                type: type
            })) : ("function" == typeof duration && (onClose = duration, duration = void 0), 
            originalApi.open({
                content: content,
                duration: duration,
                type: type,
                onClose: onClose
            }));
        }
        typeList.forEach((type => attachTypeApi(api$1, type))), api$1.warn = api$1.warning, 
        api$1.useMessage = useMessage;
        const genNotificationPlacementStyle = token2 => {
            const {componentCls: componentCls, width: width, notificationMarginEdge: notificationMarginEdge} = token2, notificationTopFadeIn = new Keyframe("antNotificationTopFadeIn", {
                "0%": {
                    marginTop: "-100%",
                    opacity: 0
                },
                "100%": {
                    marginTop: 0,
                    opacity: 1
                }
            }), notificationBottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
                "0%": {
                    marginBottom: "-100%",
                    opacity: 0
                },
                "100%": {
                    marginBottom: 0,
                    opacity: 1
                }
            }), notificationLeftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
                "0%": {
                    right: {
                        _skip_check_: !0,
                        value: width
                    },
                    opacity: 0
                },
                "100%": {
                    right: {
                        _skip_check_: !0,
                        value: 0
                    },
                    opacity: 1
                }
            });
            return {
                [`&${componentCls}-top, &${componentCls}-bottom`]: {
                    marginInline: 0
                },
                [`&${componentCls}-top`]: {
                    [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
                        animationName: notificationTopFadeIn
                    }
                },
                [`&${componentCls}-bottom`]: {
                    [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
                        animationName: notificationBottomFadeIn
                    }
                },
                [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
                    marginInlineEnd: 0,
                    marginInlineStart: notificationMarginEdge,
                    [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
                        animationName: notificationLeftFadeIn
                    }
                }
            };
        }, genNotificationStyle = token2 => {
            const {iconCls: iconCls, componentCls: componentCls, boxShadowSecondary: boxShadowSecondary, fontSizeLG: fontSizeLG, notificationMarginBottom: notificationMarginBottom, borderRadiusLG: borderRadiusLG, colorSuccess: colorSuccess, colorInfo: colorInfo, colorWarning: colorWarning, colorError: colorError, colorTextHeading: colorTextHeading, notificationBg: notificationBg, notificationPadding: notificationPadding, notificationMarginEdge: notificationMarginEdge, motionDurationMid: motionDurationMid, motionEaseInOut: motionEaseInOut, fontSize: fontSize, lineHeight: lineHeight, width: width, notificationIconSize: notificationIconSize} = token2, noticeCls = `${componentCls}-notice`, notificationFadeIn = new Keyframe("antNotificationFadeIn", {
                "0%": {
                    left: {
                        _skip_check_: !0,
                        value: width
                    },
                    opacity: 0
                },
                "100%": {
                    left: {
                        _skip_check_: !0,
                        value: 0
                    },
                    opacity: 1
                }
            }), notificationFadeOut = new Keyframe("antNotificationFadeOut", {
                "0%": {
                    maxHeight: token2.animationMaxHeight,
                    marginBottom: notificationMarginBottom,
                    opacity: 1
                },
                "100%": {
                    maxHeight: 0,
                    marginBottom: 0,
                    paddingTop: 0,
                    paddingBottom: 0,
                    opacity: 0
                }
            });
            return [ {
                [componentCls]: _extends$1(_extends$1(_extends$1(_extends$1({}, resetComponent(token2)), {
                    position: "fixed",
                    zIndex: token2.zIndexPopup,
                    marginInlineEnd: notificationMarginEdge,
                    [`${componentCls}-hook-holder`]: {
                        position: "relative"
                    },
                    [`&${componentCls}-top, &${componentCls}-bottom`]: {
                        [`${componentCls}-notice`]: {
                            marginInline: "auto auto"
                        }
                    },
                    [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
                        [`${componentCls}-notice`]: {
                            marginInlineEnd: "auto",
                            marginInlineStart: 0
                        }
                    },
                    [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
                        animationDuration: token2.motionDurationMid,
                        animationTimingFunction: motionEaseInOut,
                        animationFillMode: "both",
                        opacity: 0,
                        animationPlayState: "paused"
                    },
                    [`${componentCls}-fade-leave`]: {
                        animationTimingFunction: motionEaseInOut,
                        animationFillMode: "both",
                        animationDuration: motionDurationMid,
                        animationPlayState: "paused"
                    },
                    [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
                        animationName: notificationFadeIn,
                        animationPlayState: "running"
                    },
                    [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
                        animationName: notificationFadeOut,
                        animationPlayState: "running"
                    }
                }), genNotificationPlacementStyle(token2)), {
                    "&-rtl": {
                        direction: "rtl",
                        [`${componentCls}-notice-btn`]: {
                            float: "left"
                        }
                    }
                })
            }, {
                [noticeCls]: {
                    position: "relative",
                    width: width,
                    maxWidth: `calc(100vw - ${2 * notificationMarginEdge}px)`,
                    marginBottom: notificationMarginBottom,
                    marginInlineStart: "auto",
                    padding: notificationPadding,
                    overflow: "hidden",
                    lineHeight: lineHeight,
                    wordWrap: "break-word",
                    background: notificationBg,
                    borderRadius: borderRadiusLG,
                    boxShadow: boxShadowSecondary,
                    [`${componentCls}-close-icon`]: {
                        fontSize: fontSize,
                        cursor: "pointer"
                    },
                    [`${noticeCls}-message`]: {
                        marginBottom: token2.marginXS,
                        color: colorTextHeading,
                        fontSize: fontSizeLG,
                        lineHeight: token2.lineHeightLG
                    },
                    [`${noticeCls}-description`]: {
                        fontSize: fontSize
                    },
                    [`&${noticeCls}-closable ${noticeCls}-message`]: {
                        paddingInlineEnd: token2.paddingLG
                    },
                    [`${noticeCls}-with-icon ${noticeCls}-message`]: {
                        marginBottom: token2.marginXS,
                        marginInlineStart: token2.marginSM + notificationIconSize,
                        fontSize: fontSizeLG
                    },
                    [`${noticeCls}-with-icon ${noticeCls}-description`]: {
                        marginInlineStart: token2.marginSM + notificationIconSize,
                        fontSize: fontSize
                    },
                    [`${noticeCls}-icon`]: {
                        position: "absolute",
                        fontSize: notificationIconSize,
                        lineHeight: 0,
                        [`&-success${iconCls}`]: {
                            color: colorSuccess
                        },
                        [`&-info${iconCls}`]: {
                            color: colorInfo
                        },
                        [`&-warning${iconCls}`]: {
                            color: colorWarning
                        },
                        [`&-error${iconCls}`]: {
                            color: colorError
                        }
                    },
                    [`${noticeCls}-close`]: {
                        position: "absolute",
                        top: token2.notificationPaddingVertical,
                        insetInlineEnd: token2.notificationPaddingHorizontal,
                        color: token2.colorIcon,
                        outline: "none",
                        width: token2.notificationCloseButtonSize,
                        height: token2.notificationCloseButtonSize,
                        borderRadius: token2.borderRadiusSM,
                        transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        "&:hover": {
                            color: token2.colorIconHover,
                            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent
                        }
                    },
                    [`${noticeCls}-btn`]: {
                        float: "right",
                        marginTop: token2.marginSM
                    }
                }
            }, {
                [`${noticeCls}-pure-panel`]: {
                    margin: 0
                }
            } ];
        }, useStyle$3 = genComponentStyleHook("Notification", (token2 => {
            const notificationPaddingVertical = token2.paddingMD, notificationPaddingHorizontal = token2.paddingLG, notificationToken = merge(token2, {
                notificationBg: token2.colorBgElevated,
                notificationPaddingVertical: notificationPaddingVertical,
                notificationPaddingHorizontal: notificationPaddingHorizontal,
                notificationPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`,
                notificationMarginBottom: token2.margin,
                notificationMarginEdge: token2.marginLG,
                animationMaxHeight: 150,
                notificationIconSize: token2.fontSizeLG * token2.lineHeightLG,
                notificationCloseButtonSize: .55 * token2.controlHeightLG
            });
            return [ genNotificationStyle(notificationToken) ];
        }), (token2 => ({
            zIndexPopup: token2.zIndexPopupBase + 50,
            width: 384
        })));
        function getCloseIcon(prefixCls, closeIcon) {
            return closeIcon || createVNode("span", {
                class: `${prefixCls}-close-x`
            }, [ createVNode(CloseOutlined, {
                class: `${prefixCls}-close-icon`
            }, null) ]);
        }
        createVNode(InfoCircleFilled, null, null), createVNode(CheckCircleFilled, null, null), 
        createVNode(CloseCircleFilled, null, null), createVNode(ExclamationCircleFilled, null, null), 
        createVNode(LoadingOutlined, null, null);
        const typeToIcon$1 = {
            success: CheckCircleFilled,
            info: InfoCircleFilled,
            error: CloseCircleFilled,
            warning: ExclamationCircleFilled
        };
        function PureContent(_ref) {
            let {prefixCls: prefixCls, icon: icon, type: type, message: message, description: description, btn: btn} = _ref, iconNode = null;
            if (icon) iconNode = createVNode("span", {
                class: `${prefixCls}-icon`
            }, [ renderHelper(icon) ]); else if (type) {
                const Icon2 = typeToIcon$1[type];
                iconNode = createVNode(Icon2, {
                    class: `${prefixCls}-icon ${prefixCls}-icon-${type}`
                }, null);
            }
            return createVNode("div", {
                class: classNames({
                    [`${prefixCls}-with-icon`]: iconNode
                }),
                role: "alert"
            }, [ iconNode, createVNode("div", {
                class: `${prefixCls}-message`
            }, [ message ]), createVNode("div", {
                class: `${prefixCls}-description`
            }, [ description ]), btn && createVNode("div", {
                class: `${prefixCls}-btn`
            }, [ btn ]) ]);
        }
        function getPlacementStyle(placement, top, bottom) {
            let style;
            switch (top = "number" == typeof top ? `${top}px` : top, bottom = "number" == typeof bottom ? `${bottom}px` : bottom, 
            placement) {
              case "top":
                style = {
                    left: "50%",
                    transform: "translateX(-50%)",
                    right: "auto",
                    top: top,
                    bottom: "auto"
                };
                break;

              case "topLeft":
                style = {
                    left: 0,
                    top: top,
                    bottom: "auto"
                };
                break;

              case "topRight":
                style = {
                    right: 0,
                    top: top,
                    bottom: "auto"
                };
                break;

              case "bottom":
                style = {
                    left: "50%",
                    transform: "translateX(-50%)",
                    right: "auto",
                    top: "auto",
                    bottom: bottom
                };
                break;

              case "bottomLeft":
                style = {
                    left: 0,
                    top: "auto",
                    bottom: bottom
                };
                break;

              default:
                style = {
                    right: 0,
                    top: "auto",
                    bottom: bottom
                };
            }
            return style;
        }
        function getMotion(prefixCls) {
            return {
                name: `${prefixCls}-fade`
            };
        }
        var __rest$4 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const DEFAULT_OFFSET = 24, DEFAULT_DURATION = 4.5, Holder = defineComponent({
            name: "Holder",
            inheritAttrs: !1,
            props: [ "prefixCls", "class", "type", "icon", "content", "onAllRemoved" ],
            setup(props2, _ref) {
                let {expose: expose} = _ref;
                const {getPrefixCls: getPrefixCls, getPopupContainer: getPopupContainer} = useConfigInject("notification", props2), prefixCls = computed((() => props2.prefixCls || getPrefixCls("notification"))), getStyles = placement => {
                    var _a, _b;
                    return getPlacementStyle(placement, null !== (_a = props2.top) && void 0 !== _a ? _a : DEFAULT_OFFSET, null !== (_b = props2.bottom) && void 0 !== _b ? _b : DEFAULT_OFFSET);
                }, [, hashId] = useStyle$3(prefixCls), getClassName = () => classNames(hashId.value, {
                    [`${prefixCls.value}-rtl`]: props2.rtl
                }), getNotificationMotion = () => getMotion(prefixCls.value), [api2, holder] = useNotification$1({
                    prefixCls: prefixCls.value,
                    getStyles: getStyles,
                    getClassName: getClassName,
                    motion: getNotificationMotion,
                    closable: !0,
                    closeIcon: getCloseIcon(prefixCls.value),
                    duration: DEFAULT_DURATION,
                    getContainer: () => {
                        var _a, _b;
                        return (null === (_a = props2.getPopupContainer) || void 0 === _a ? void 0 : _a.call(props2)) || (null === (_b = getPopupContainer.value) || void 0 === _b ? void 0 : _b.call(getPopupContainer)) || document.body;
                    },
                    maxCount: props2.maxCount,
                    hashId: hashId.value,
                    onAllRemoved: props2.onAllRemoved
                });
                return expose(_extends$1(_extends$1({}, api2), {
                    prefixCls: prefixCls.value,
                    hashId: hashId
                })), holder;
            }
        });
        function useInternalNotification(notificationConfig) {
            const holderRef = shallowRef(null), holderKey = Symbol("notificationHolderKey"), open2 = config => {
                if (!holderRef.value) return;
                const {open: originOpen, prefixCls: prefixCls, hashId: hashId} = holderRef.value, noticePrefixCls = `${prefixCls}-notice`, {message: message, description: description, icon: icon, type: type, btn: btn, class: className} = config;
                return originOpen(_extends$1(_extends$1({
                    placement: "topRight"
                }, __rest$4(config, [ "message", "description", "icon", "type", "btn", "class" ])), {
                    content: () => createVNode(PureContent, {
                        prefixCls: noticePrefixCls,
                        icon: "function" == typeof icon ? icon() : icon,
                        type: type,
                        message: "function" == typeof message ? message() : message,
                        description: "function" == typeof description ? description() : description,
                        btn: "function" == typeof btn ? btn() : btn
                    }, null),
                    class: classNames(type && `${noticePrefixCls}-${type}`, hashId, className)
                }));
            }, wrapAPI = {
                open: open2,
                destroy: key2 => {
                    var _a, _b;
                    void 0 !== key2 ? null === (_a = holderRef.value) || void 0 === _a || _a.close(key2) : null === (_b = holderRef.value) || void 0 === _b || _b.destroy();
                }
            };
            return [ "success", "info", "warning", "error" ].forEach((type => {
                wrapAPI[type] = config => open2(_extends$1(_extends$1({}, config), {
                    type: type
                }));
            })), [ wrapAPI, () => createVNode(Holder, _objectSpread2$1(_objectSpread2$1({
                key: holderKey
            }, notificationConfig), {}, {
                ref: holderRef
            }), null) ];
        }
        function useNotification(notificationConfig) {
            return useInternalNotification(notificationConfig);
        }
        const notificationInstance = {};
        let maxCount, defaultDuration = 4.5, defaultTop = "24px", defaultBottom = "24px", defaultPrefixCls$1 = "", defaultPlacement = "topRight", defaultGetContainer = () => document.body, defaultCloseIcon = null, rtl = !1;
        function setNotificationConfig(options) {
            const {duration: duration, placement: placement, bottom: bottom, top: top, getContainer: getContainer2, closeIcon: closeIcon, prefixCls: prefixCls} = options;
            void 0 !== prefixCls && (defaultPrefixCls$1 = prefixCls), void 0 !== duration && (defaultDuration = duration), 
            void 0 !== placement && (defaultPlacement = placement), void 0 !== bottom && (defaultBottom = "number" == typeof bottom ? `${bottom}px` : bottom), 
            void 0 !== top && (defaultTop = "number" == typeof top ? `${top}px` : top), void 0 !== getContainer2 && (defaultGetContainer = getContainer2), 
            void 0 !== closeIcon && (defaultCloseIcon = closeIcon), void 0 !== options.rtl && (rtl = options.rtl), 
            void 0 !== options.maxCount && (maxCount = options.maxCount);
        }
        function getNotificationInstance(_ref, callback) {
            let {prefixCls: customizePrefixCls, placement: placement = defaultPlacement, getContainer: getContainer2 = defaultGetContainer, top: top, bottom: bottom, closeIcon: closeIcon = defaultCloseIcon, appContext: appContext} = _ref;
            const {getPrefixCls: getPrefixCls} = globalConfig(), prefixCls = getPrefixCls("notification", customizePrefixCls || defaultPrefixCls$1), cacheKey = `${prefixCls}-${placement}-${rtl}`, cacheInstance = notificationInstance[cacheKey];
            if (cacheInstance) return void Promise.resolve(cacheInstance).then((instance => {
                callback(instance);
            }));
            const notificationClass = classNames(`${prefixCls}-${placement}`, {
                [`${prefixCls}-rtl`]: !0 === rtl
            });
            Notification$1.newInstance({
                name: "notification",
                prefixCls: customizePrefixCls || defaultPrefixCls$1,
                useStyle: useStyle$3,
                class: notificationClass,
                style: getPlacementStyle(placement, null != top ? top : defaultTop, null != bottom ? bottom : defaultBottom),
                appContext: appContext,
                getContainer: getContainer2,
                closeIcon: _ref2 => {
                    let {prefixCls: prefixCls2} = _ref2;
                    return createVNode("span", {
                        class: `${prefixCls2}-close-x`
                    }, [ renderHelper(closeIcon, {}, createVNode(CloseOutlined, {
                        class: `${prefixCls2}-close-icon`
                    }, null)) ]);
                },
                maxCount: maxCount,
                hasTransitionName: !0
            }, (notification => {
                notificationInstance[cacheKey] = notification, callback(notification);
            }));
        }
        const typeToIcon = {
            success: CheckCircleOutlined,
            info: InfoCircleOutlined,
            error: CloseCircleOutlined,
            warning: ExclamationCircleOutlined
        };
        function notice(args) {
            const {icon: icon, type: type, description: description, message: message, btn: btn} = args, duration = void 0 === args.duration ? defaultDuration : args.duration;
            getNotificationInstance(args, (notification => {
                notification.notice({
                    content: _ref3 => {
                        let {prefixCls: outerPrefixCls} = _ref3;
                        const prefixCls = `${outerPrefixCls}-notice`;
                        let iconNode = null;
                        if (icon) iconNode = () => createVNode("span", {
                            class: `${prefixCls}-icon`
                        }, [ renderHelper(icon) ]); else if (type) {
                            const Icon2 = typeToIcon[type];
                            iconNode = () => createVNode(Icon2, {
                                class: `${prefixCls}-icon ${prefixCls}-icon-${type}`
                            }, null);
                        }
                        return createVNode("div", {
                            class: iconNode ? `${prefixCls}-with-icon` : ""
                        }, [ iconNode && iconNode(), createVNode("div", {
                            class: `${prefixCls}-message`
                        }, [ !description && iconNode ? createVNode("span", {
                            class: `${prefixCls}-message-single-line-auto-margin`
                        }, null) : null, renderHelper(message) ]), createVNode("div", {
                            class: `${prefixCls}-description`
                        }, [ renderHelper(description) ]), btn ? createVNode("span", {
                            class: `${prefixCls}-btn`
                        }, [ renderHelper(btn) ]) : null ]);
                    },
                    duration: duration,
                    closable: !0,
                    onClose: args.onClose,
                    onClick: args.onClick,
                    key: args.key,
                    style: args.style || {},
                    class: args.class
                });
            }));
        }
        const api = {
            open: notice,
            close(key2) {
                Object.keys(notificationInstance).forEach((cacheKey => Promise.resolve(notificationInstance[cacheKey]).then((instance => {
                    instance.removeNotice(key2);
                }))));
            },
            config: setNotificationConfig,
            destroy() {
                Object.keys(notificationInstance).forEach((cacheKey => {
                    Promise.resolve(notificationInstance[cacheKey]).then((instance => {
                        instance.destroy();
                    })), delete notificationInstance[cacheKey];
                }));
            }
        };
        [ "success", "info", "warning", "error" ].forEach((type => {
            api[type] = args => api.open(_extends$1(_extends$1({}, args), {
                type: type
            }));
        })), api.warn = api.warning, api.useNotification = useNotification;
        const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
        function getStyle(globalPrefixCls, theme) {
            const variables = {}, formatColor = (color, updater) => {
                let clone = color.clone();
                return clone = (null == updater ? void 0 : updater(clone)) || clone, clone.toRgbString();
            }, fillColor = (colorVal, type) => {
                const baseColor = new TinyColor(colorVal), colorPalettes = generate$1(baseColor.toRgbString());
                variables[`${type}-color`] = formatColor(baseColor), variables[`${type}-color-disabled`] = colorPalettes[1], 
                variables[`${type}-color-hover`] = colorPalettes[4], variables[`${type}-color-active`] = colorPalettes[6], 
                variables[`${type}-color-outline`] = baseColor.clone().setAlpha(.2).toRgbString(), 
                variables[`${type}-color-deprecated-bg`] = colorPalettes[0], variables[`${type}-color-deprecated-border`] = colorPalettes[2];
            };
            if (theme.primaryColor) {
                fillColor(theme.primaryColor, "primary");
                const primaryColor = new TinyColor(theme.primaryColor), primaryColors = generate$1(primaryColor.toRgbString());
                primaryColors.forEach(((color, index2) => {
                    variables[`primary-${index2 + 1}`] = color;
                })), variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2 => c2.lighten(35))), 
                variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2 => c2.lighten(20))), 
                variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2 => c2.tint(20))), 
                variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2 => c2.tint(50))), 
                variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2 => c2.setAlpha(.12 * c2.getAlpha())));
                const primaryActiveColor = new TinyColor(primaryColors[0]);
                variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2 => c2.setAlpha(.3 * c2.getAlpha()))), 
                variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2 => c2.darken(2)));
            }
            theme.successColor && fillColor(theme.successColor, "success"), theme.warningColor && fillColor(theme.warningColor, "warning"), 
            theme.errorColor && fillColor(theme.errorColor, "error"), theme.infoColor && fillColor(theme.infoColor, "info");
            return `\n  :root {\n    ${Object.keys(variables).map((key2 => `--${globalPrefixCls}-${key2}: ${variables[key2]};`)).join("\n")}\n  }\n  `.trim();
        }
        function registerTheme(globalPrefixCls, theme) {
            const style = getStyle(globalPrefixCls, theme);
            canUseDom$1() && updateCSS$1(style, `${dynamicStyleMark}-dynamic-theme`);
        }
        const useStyle$2 = iconPrefixCls => {
            const [theme, token2] = useToken();
            return useStyleRegister(computed((() => ({
                theme: theme.value,
                token: token2.value,
                hashId: "",
                path: [ "ant-design-icons", iconPrefixCls.value ]
            }))), (() => [ {
                [`.${iconPrefixCls.value}`]: _extends$1(_extends$1({}, resetIcon()), {
                    [`.${iconPrefixCls.value} .${iconPrefixCls.value}-icon`]: {
                        display: "block"
                    }
                })
            } ]));
        };
        function useTheme(theme, parentTheme) {
            const themeConfig = computed((() => (null == theme ? void 0 : theme.value) || {})), parentThemeConfig = computed((() => !1 !== themeConfig.value.inherit && (null == parentTheme ? void 0 : parentTheme.value) ? parentTheme.value : defaultConfig));
            return computed((() => {
                if (!(null == theme ? void 0 : theme.value)) return null == parentTheme ? void 0 : parentTheme.value;
                const mergedComponents = _extends$1({}, parentThemeConfig.value.components);
                return Object.keys(theme.value.components || {}).forEach((componentName => {
                    mergedComponents[componentName] = _extends$1(_extends$1({}, mergedComponents[componentName]), theme.value.components[componentName]);
                })), _extends$1(_extends$1(_extends$1({}, parentThemeConfig.value), themeConfig.value), {
                    token: _extends$1(_extends$1({}, parentThemeConfig.value.token), themeConfig.value.token),
                    components: mergedComponents
                });
            }));
        }
        var __rest$3 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const defaultPrefixCls = "ant";
        function getGlobalPrefixCls() {
            return globalConfigForApi.prefixCls || defaultPrefixCls;
        }
        function getGlobalIconPrefixCls() {
            return globalConfigForApi.iconPrefixCls || defaultIconPrefixCls;
        }
        const globalConfigBySet = reactive({}), globalConfigForApi = reactive({});
        let stopWatchEffect;
        watchEffect((() => {
            _extends$1(globalConfigForApi, globalConfigBySet), globalConfigForApi.prefixCls = getGlobalPrefixCls(), 
            globalConfigForApi.iconPrefixCls = getGlobalIconPrefixCls(), globalConfigForApi.getPrefixCls = (suffixCls, customizePrefixCls) => customizePrefixCls || (suffixCls ? `${globalConfigForApi.prefixCls}-${suffixCls}` : globalConfigForApi.prefixCls), 
            globalConfigForApi.getRootPrefixCls = () => globalConfigForApi.prefixCls ? globalConfigForApi.prefixCls : getGlobalPrefixCls();
        }));
        const setGlobalConfig = params => {
            stopWatchEffect && stopWatchEffect(), stopWatchEffect = watchEffect((() => {
                _extends$1(globalConfigBySet, reactive(params)), _extends$1(globalConfigForApi, reactive(params));
            })), params.theme && registerTheme(getGlobalPrefixCls(), params.theme);
        }, globalConfig = () => ({
            getPrefixCls: (suffixCls, customizePrefixCls) => customizePrefixCls || (suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls()),
            getIconPrefixCls: getGlobalIconPrefixCls,
            getRootPrefixCls: () => globalConfigForApi.prefixCls ? globalConfigForApi.prefixCls : getGlobalPrefixCls()
        }), ConfigProvider = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "AConfigProvider",
            inheritAttrs: !1,
            props: configProviderProps(),
            setup(props2, _ref) {
                let {slots: slots} = _ref;
                const parentContext = useConfigContextInject(), getPrefixCls = (suffixCls, customizePrefixCls) => {
                    const {prefixCls: prefixCls = "ant"} = props2;
                    if (customizePrefixCls) return customizePrefixCls;
                    const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
                    return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
                }, iconPrefixCls = computed((() => props2.iconPrefixCls || parentContext.iconPrefixCls.value || defaultIconPrefixCls)), shouldWrapSSR = computed((() => iconPrefixCls.value !== parentContext.iconPrefixCls.value)), csp = computed((() => {
                    var _a;
                    return props2.csp || (null === (_a = parentContext.csp) || void 0 === _a ? void 0 : _a.value);
                })), wrapSSR = useStyle$2(iconPrefixCls), mergedTheme = useTheme(computed((() => props2.theme)), computed((() => {
                    var _a;
                    return null === (_a = parentContext.theme) || void 0 === _a ? void 0 : _a.value;
                }))), renderEmptyComponent = name => (props2.renderEmpty || slots.renderEmpty || parentContext.renderEmpty || renderEmpty)(name), autoInsertSpaceInButton = computed((() => {
                    var _a, _b;
                    return null !== (_a = props2.autoInsertSpaceInButton) && void 0 !== _a ? _a : null === (_b = parentContext.autoInsertSpaceInButton) || void 0 === _b ? void 0 : _b.value;
                })), locale$12 = computed((() => {
                    var _a;
                    return props2.locale || (null === (_a = parentContext.locale) || void 0 === _a ? void 0 : _a.value);
                }));
                watch(locale$12, (() => {
                    globalConfigBySet.locale = locale$12.value;
                }), {
                    immediate: !0
                });
                const direction = computed((() => {
                    var _a;
                    return props2.direction || (null === (_a = parentContext.direction) || void 0 === _a ? void 0 : _a.value);
                })), space = computed((() => {
                    var _a, _b;
                    return null !== (_a = props2.space) && void 0 !== _a ? _a : null === (_b = parentContext.space) || void 0 === _b ? void 0 : _b.value;
                })), virtual = computed((() => {
                    var _a, _b;
                    return null !== (_a = props2.virtual) && void 0 !== _a ? _a : null === (_b = parentContext.virtual) || void 0 === _b ? void 0 : _b.value;
                })), dropdownMatchSelectWidth = computed((() => {
                    var _a, _b;
                    return null !== (_a = props2.dropdownMatchSelectWidth) && void 0 !== _a ? _a : null === (_b = parentContext.dropdownMatchSelectWidth) || void 0 === _b ? void 0 : _b.value;
                })), getTargetContainer = computed((() => {
                    var _a;
                    return void 0 !== props2.getTargetContainer ? props2.getTargetContainer : null === (_a = parentContext.getTargetContainer) || void 0 === _a ? void 0 : _a.value;
                })), getPopupContainer = computed((() => {
                    var _a;
                    return void 0 !== props2.getPopupContainer ? props2.getPopupContainer : null === (_a = parentContext.getPopupContainer) || void 0 === _a ? void 0 : _a.value;
                })), pageHeader = computed((() => {
                    var _a;
                    return void 0 !== props2.pageHeader ? props2.pageHeader : null === (_a = parentContext.pageHeader) || void 0 === _a ? void 0 : _a.value;
                })), input = computed((() => {
                    var _a;
                    return void 0 !== props2.input ? props2.input : null === (_a = parentContext.input) || void 0 === _a ? void 0 : _a.value;
                })), pagination = computed((() => {
                    var _a;
                    return void 0 !== props2.pagination ? props2.pagination : null === (_a = parentContext.pagination) || void 0 === _a ? void 0 : _a.value;
                })), form = computed((() => {
                    var _a;
                    return void 0 !== props2.form ? props2.form : null === (_a = parentContext.form) || void 0 === _a ? void 0 : _a.value;
                })), select = computed((() => {
                    var _a;
                    return void 0 !== props2.select ? props2.select : null === (_a = parentContext.select) || void 0 === _a ? void 0 : _a.value;
                })), componentSize = computed((() => props2.componentSize)), componentDisabled = computed((() => props2.componentDisabled)), wave = computed((() => {
                    var _a, _b;
                    return null !== (_a = props2.wave) && void 0 !== _a ? _a : null === (_b = parentContext.wave) || void 0 === _b ? void 0 : _b.value;
                })), configProvider = {
                    csp: csp,
                    autoInsertSpaceInButton: autoInsertSpaceInButton,
                    locale: locale$12,
                    direction: direction,
                    space: space,
                    virtual: virtual,
                    dropdownMatchSelectWidth: dropdownMatchSelectWidth,
                    getPrefixCls: getPrefixCls,
                    iconPrefixCls: iconPrefixCls,
                    theme: computed((() => {
                        var _a, _b;
                        return null !== (_a = mergedTheme.value) && void 0 !== _a ? _a : null === (_b = parentContext.theme) || void 0 === _b ? void 0 : _b.value;
                    })),
                    renderEmpty: renderEmptyComponent,
                    getTargetContainer: getTargetContainer,
                    getPopupContainer: getPopupContainer,
                    pageHeader: pageHeader,
                    input: input,
                    pagination: pagination,
                    form: form,
                    select: select,
                    componentSize: componentSize,
                    componentDisabled: componentDisabled,
                    transformCellText: computed((() => props2.transformCellText)),
                    wave: wave
                }, memoTheme = computed((() => {
                    const _a = mergedTheme.value || {}, {algorithm: algorithm, token: token2} = _a, rest = __rest$3(_a, [ "algorithm", "token" ]), themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
                    return _extends$1(_extends$1({}, rest), {
                        theme: themeObj,
                        token: _extends$1(_extends$1({}, seedToken), token2)
                    });
                })), validateMessagesRef = computed((() => {
                    var _a, _b;
                    let validateMessages = {};
                    return locale$12.value && (validateMessages = (null === (_a = locale$12.value.Form) || void 0 === _a ? void 0 : _a.defaultValidateMessages) || (null === (_b = localeValues.Form) || void 0 === _b ? void 0 : _b.defaultValidateMessages) || {}), 
                    props2.form && props2.form.validateMessages && (validateMessages = _extends$1(_extends$1({}, validateMessages), props2.form.validateMessages)), 
                    validateMessages;
                }));
                useConfigContextProvider(configProvider), useProvideGlobalForm({
                    validateMessages: validateMessagesRef
                }), useProviderSize(componentSize), useProviderDisabled(componentDisabled);
                const renderProvider = legacyLocale => {
                    var _a, _b;
                    let childNode = shouldWrapSSR.value ? wrapSSR(null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots)) : null === (_b = slots.default) || void 0 === _b ? void 0 : _b.call(slots);
                    if (props2.theme) {
                        const _childNode = function() {
                            return childNode;
                        }();
                        childNode = createVNode(DesignTokenProvider, {
                            value: memoTheme.value
                        }, {
                            default: () => [ _childNode ]
                        });
                    }
                    return createVNode(locale, {
                        locale: locale$12.value || legacyLocale,
                        ANT_MARK__: ANT_MARK
                    }, {
                        default: () => [ childNode ]
                    });
                };
                return watchEffect((() => {
                    direction.value && (api$1.config({
                        rtl: "rtl" === direction.value
                    }), api.config({
                        rtl: "rtl" === direction.value
                    }));
                })), () => createVNode(LocaleReceiver, {
                    children: (_2, __, legacyLocale) => renderProvider(legacyLocale)
                }, null);
            }
        });
        ConfigProvider.config = setGlobalConfig, ConfigProvider.install = function(app) {
            app.component(ConfigProvider.name, ConfigProvider);
        };
        const genTagStatusStyle = (token2, status, cssVariableType) => {
            const capitalizedCssVariableType = capitalize(cssVariableType);
            return {
                [`${token2.componentCls}-${status}`]: {
                    color: token2[`color${cssVariableType}`],
                    background: token2[`color${capitalizedCssVariableType}Bg`],
                    borderColor: token2[`color${capitalizedCssVariableType}Border`],
                    [`&${token2.componentCls}-borderless`]: {
                        borderColor: "transparent"
                    }
                }
            };
        }, genPresetStyle = token2 => genPresetColor(token2, ((colorKey, _ref) => {
            let {textColor: textColor, lightBorderColor: lightBorderColor, lightColor: lightColor, darkColor: darkColor} = _ref;
            return {
                [`${token2.componentCls}-${colorKey}`]: {
                    color: textColor,
                    background: lightColor,
                    borderColor: lightBorderColor,
                    "&-inverse": {
                        color: token2.colorTextLightSolid,
                        background: darkColor,
                        borderColor: darkColor
                    },
                    [`&${token2.componentCls}-borderless`]: {
                        borderColor: "transparent"
                    }
                }
            };
        })), genBaseStyle = token2 => {
            const {paddingXXS: paddingXXS, lineWidth: lineWidth, tagPaddingHorizontal: tagPaddingHorizontal, componentCls: componentCls} = token2, paddingInline = tagPaddingHorizontal - lineWidth, iconMarginInline = paddingXXS - lineWidth;
            return {
                [componentCls]: _extends$1(_extends$1({}, resetComponent(token2)), {
                    display: "inline-block",
                    height: "auto",
                    marginInlineEnd: token2.marginXS,
                    paddingInline: paddingInline,
                    fontSize: token2.tagFontSize,
                    lineHeight: `${token2.tagLineHeight}px`,
                    whiteSpace: "nowrap",
                    background: token2.tagDefaultBg,
                    border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
                    borderRadius: token2.borderRadiusSM,
                    opacity: 1,
                    transition: `all ${token2.motionDurationMid}`,
                    textAlign: "start",
                    [`&${componentCls}-rtl`]: {
                        direction: "rtl"
                    },
                    "&, a, a:hover": {
                        color: token2.tagDefaultColor
                    },
                    [`${componentCls}-close-icon`]: {
                        marginInlineStart: iconMarginInline,
                        color: token2.colorTextDescription,
                        fontSize: token2.tagIconSize,
                        cursor: "pointer",
                        transition: `all ${token2.motionDurationMid}`,
                        "&:hover": {
                            color: token2.colorTextHeading
                        }
                    },
                    [`&${componentCls}-has-color`]: {
                        borderColor: "transparent",
                        [`&, a, a:hover, ${token2.iconCls}-close, ${token2.iconCls}-close:hover`]: {
                            color: token2.colorTextLightSolid
                        }
                    },
                    "&-checkable": {
                        backgroundColor: "transparent",
                        borderColor: "transparent",
                        cursor: "pointer",
                        [`&:not(${componentCls}-checkable-checked):hover`]: {
                            color: token2.colorPrimary,
                            backgroundColor: token2.colorFillSecondary
                        },
                        "&:active, &-checked": {
                            color: token2.colorTextLightSolid
                        },
                        "&-checked": {
                            backgroundColor: token2.colorPrimary,
                            "&:hover": {
                                backgroundColor: token2.colorPrimaryHover
                            }
                        },
                        "&:active": {
                            backgroundColor: token2.colorPrimaryActive
                        }
                    },
                    "&-hidden": {
                        display: "none"
                    },
                    [`> ${token2.iconCls} + span, > span + ${token2.iconCls}`]: {
                        marginInlineStart: paddingInline
                    }
                }),
                [`${componentCls}-borderless`]: {
                    borderColor: "transparent",
                    background: token2.tagBorderlessBg
                }
            };
        }, useStyle$1 = genComponentStyleHook("Tag", (token2 => {
            const {fontSize: fontSize, lineHeight: lineHeight, lineWidth: lineWidth, fontSizeIcon: fontSizeIcon} = token2, tagHeight = Math.round(fontSize * lineHeight), tagToken = merge(token2, {
                tagFontSize: token2.fontSizeSM,
                tagLineHeight: tagHeight - 2 * lineWidth,
                tagDefaultBg: token2.colorFillAlter,
                tagDefaultColor: token2.colorText,
                tagIconSize: fontSizeIcon - 2 * lineWidth,
                tagPaddingHorizontal: 8,
                tagBorderlessBg: token2.colorFillTertiary
            });
            return [ genBaseStyle(tagToken), genPresetStyle(tagToken), genTagStatusStyle(tagToken, "success", "Success"), genTagStatusStyle(tagToken, "processing", "Info"), genTagStatusStyle(tagToken, "error", "Error"), genTagStatusStyle(tagToken, "warning", "Warning") ];
        })), CheckableTag = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ACheckableTag",
            inheritAttrs: !1,
            props: (() => ({
                prefixCls: String,
                checked: {
                    type: Boolean,
                    default: void 0
                },
                onChange: {
                    type: Function
                },
                onClick: {
                    type: Function
                },
                "onUpdate:checked": Function
            }))(),
            setup(props2, _ref) {
                let {slots: slots, emit: emit2, attrs: attrs} = _ref;
                const {prefixCls: prefixCls} = useConfigInject("tag", props2), [wrapSSR, hashId] = useStyle$1(prefixCls), handleClick = e2 => {
                    const {checked: checked} = props2;
                    emit2("update:checked", !checked), emit2("change", !checked), emit2("click", e2);
                }, cls = computed((() => classNames(prefixCls.value, hashId.value, {
                    [`${prefixCls.value}-checkable`]: !0,
                    [`${prefixCls.value}-checkable-checked`]: props2.checked
                })));
                return () => {
                    var _a;
                    return wrapSSR(createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: [ cls.value, attrs.class ],
                        onClick: handleClick
                    }), [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]));
                };
            }
        }), Tag = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ATag",
            inheritAttrs: !1,
            props: (() => ({
                prefixCls: String,
                color: {
                    type: String
                },
                closable: {
                    type: Boolean,
                    default: !1
                },
                closeIcon: PropTypes.any,
                visible: {
                    type: Boolean,
                    default: void 0
                },
                onClose: {
                    type: Function
                },
                onClick: eventType(),
                "onUpdate:visible": Function,
                icon: PropTypes.any,
                bordered: {
                    type: Boolean,
                    default: !0
                }
            }))(),
            slots: Object,
            setup(props2, _ref) {
                let {slots: slots, emit: emit2, attrs: attrs} = _ref;
                const {prefixCls: prefixCls, direction: direction} = useConfigInject("tag", props2), [wrapSSR, hashId] = useStyle$1(prefixCls), visible = shallowRef(!0);
                watchEffect((() => {
                    void 0 !== props2.visible && (visible.value = props2.visible);
                }));
                const handleCloseClick = e2 => {
                    e2.stopPropagation(), emit2("update:visible", !1), emit2("close", e2), e2.defaultPrevented || void 0 === props2.visible && (visible.value = !1);
                }, isInternalColor = computed((() => isPresetColor(props2.color) || isPresetStatusColor(props2.color))), tagClassName = computed((() => classNames(prefixCls.value, hashId.value, {
                    [`${prefixCls.value}-${props2.color}`]: isInternalColor.value,
                    [`${prefixCls.value}-has-color`]: props2.color && !isInternalColor.value,
                    [`${prefixCls.value}-hidden`]: !visible.value,
                    [`${prefixCls.value}-rtl`]: "rtl" === direction.value,
                    [`${prefixCls.value}-borderless`]: !props2.bordered
                }))), handleClick = e2 => {
                    emit2("click", e2);
                };
                return () => {
                    var _a, _b, _c;
                    const {icon: icon = (null === (_a = slots.icon) || void 0 === _a ? void 0 : _a.call(slots)), color: color, closeIcon: closeIcon = (null === (_b = slots.closeIcon) || void 0 === _b ? void 0 : _b.call(slots)), closable: closable = !1} = props2, renderCloseIcon = () => closable ? closeIcon ? createVNode("span", {
                        class: `${prefixCls.value}-close-icon`,
                        onClick: handleCloseClick
                    }, [ closeIcon ]) : createVNode(CloseOutlined, {
                        class: `${prefixCls.value}-close-icon`,
                        onClick: handleCloseClick
                    }, null) : null, tagStyle = {
                        backgroundColor: color && !isInternalColor.value ? color : void 0
                    }, iconNode = icon || null, children = null === (_c = slots.default) || void 0 === _c ? void 0 : _c.call(slots), kids = iconNode ? createVNode(Fragment, null, [ iconNode, createVNode("span", null, [ children ]) ]) : children, isNeedWave = void 0 !== props2.onClick, tagNode = createVNode("span", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        onClick: handleClick,
                        class: [ tagClassName.value, attrs.class ],
                        style: [ tagStyle, attrs.style ]
                    }), [ kids, renderCloseIcon() ]);
                    return wrapSSR(isNeedWave ? createVNode(Wave, null, {
                        default: () => [ tagNode ]
                    }) : tagNode);
                };
            }
        });
        Tag.CheckableTag = CheckableTag, Tag.install = function(app) {
            return app.component(Tag.name, Tag), app.component(CheckableTag.name, CheckableTag), 
            app;
        };
        const props = () => ({
            prefixCls: String,
            width: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
            height: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
            style: {
                type: Object,
                default: void 0
            },
            class: String,
            rootClassName: String,
            rootStyle: objectType(),
            placement: {
                type: String
            },
            wrapperClassName: String,
            level: {
                type: [ String, Array ]
            },
            levelMove: {
                type: [ Number, Function, Array ]
            },
            duration: String,
            ease: String,
            showMask: {
                type: Boolean,
                default: void 0
            },
            maskClosable: {
                type: Boolean,
                default: void 0
            },
            maskStyle: {
                type: Object,
                default: void 0
            },
            afterVisibleChange: Function,
            keyboard: {
                type: Boolean,
                default: void 0
            },
            contentWrapperStyle: arrayType(),
            autofocus: {
                type: Boolean,
                default: void 0
            },
            open: {
                type: Boolean,
                default: void 0
            },
            motion: functionType(),
            maskMotion: objectType()
        }), drawerProps$1 = () => _extends$1(_extends$1({}, props()), {
            forceRender: {
                type: Boolean,
                default: void 0
            },
            getContainer: PropTypes.oneOfType([ PropTypes.string, PropTypes.func, PropTypes.object, PropTypes.looseBool ])
        }), drawerChildProps = () => _extends$1(_extends$1({}, props()), {
            getContainer: Function,
            getOpenCount: Function,
            scrollLocker: PropTypes.any,
            inline: Boolean
        });
        function dataToArray(vars) {
            return Array.isArray(vars) ? vars : [ vars ];
        }
        const transitionEndObject = {
            transition: "transitionend",
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend"
        };
        Object.keys(transitionEndObject).filter((key2 => {
            if ("undefined" == typeof document) return !1;
            const html = document.getElementsByTagName("html")[0];
            return key2 in (html ? html.style : {});
        }))[0];
        const windowIsUndefined = !("undefined" != typeof window && window.document && window.document.createElement);
        var __rest$2 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const DrawerChild = defineComponent({
            compatConfig: {
                MODE: 3
            },
            inheritAttrs: !1,
            props: drawerChildProps(),
            emits: [ "close", "handleClick", "change" ],
            setup(props2, _ref) {
                let {emit: emit2, slots: slots} = _ref;
                const contentWrapper = shallowRef(), dom = shallowRef(), maskDom = shallowRef(), handlerDom = shallowRef(), contentDom = shallowRef();
                let levelDom = [];
                Number((Date.now() + Math.random()).toString().replace(".", Math.round(9 * Math.random()).toString())).toString(16), 
                onMounted((() => {
                    nextTick((() => {
                        var _a;
                        const {open: open2, getContainer: getContainer2, showMask: showMask, autofocus: autofocus} = props2, container = null == getContainer2 ? void 0 : getContainer2();
                        getLevelDom(props2), open2 && (container && (container.parentNode, document.body), 
                        nextTick((() => {
                            autofocus && domFocus();
                        })), showMask && (null === (_a = props2.scrollLocker) || void 0 === _a || _a.lock()));
                    }));
                })), watch((() => props2.level), (() => {
                    getLevelDom(props2);
                }), {
                    flush: "post"
                }), watch((() => props2.open), (() => {
                    const {open: open2, getContainer: getContainer2, scrollLocker: scrollLocker, showMask: showMask, autofocus: autofocus} = props2, container = null == getContainer2 ? void 0 : getContainer2();
                    container && (container.parentNode, document.body), open2 ? (autofocus && domFocus(), 
                    showMask && (null == scrollLocker || scrollLocker.lock())) : null == scrollLocker || scrollLocker.unLock();
                }), {
                    flush: "post"
                }), onUnmounted((() => {
                    var _a;
                    const {open: open2} = props2;
                    open2 && (document.body.style.touchAction = ""), null === (_a = props2.scrollLocker) || void 0 === _a || _a.unLock();
                })), watch((() => props2.placement), (val => {
                    val && (contentDom.value = null);
                }));
                const domFocus = () => {
                    var _a, _b;
                    null === (_b = null === (_a = dom.value) || void 0 === _a ? void 0 : _a.focus) || void 0 === _b || _b.call(_a);
                }, onClose = e2 => {
                    emit2("close", e2);
                }, onKeyDown = e2 => {
                    e2.keyCode === KeyCode.ESC && (e2.stopPropagation(), onClose(e2));
                }, onAfterVisibleChange = () => {
                    const {open: open2, afterVisibleChange: afterVisibleChange} = props2;
                    afterVisibleChange && afterVisibleChange(!!open2);
                }, getLevelDom = _ref2 => {
                    let {level: level, getContainer: getContainer2} = _ref2;
                    if (windowIsUndefined) return;
                    const container = null == getContainer2 ? void 0 : getContainer2(), parent2 = container ? container.parentNode : null;
                    if (levelDom = [], "all" === level) {
                        (parent2 ? Array.prototype.slice.call(parent2.children) : []).forEach((child => {
                            "SCRIPT" !== child.nodeName && "STYLE" !== child.nodeName && "LINK" !== child.nodeName && child !== container && levelDom.push(child);
                        }));
                    } else level && dataToArray(level).forEach((key2 => {
                        document.querySelectorAll(key2).forEach((item => {
                            levelDom.push(item);
                        }));
                    }));
                }, onHandleClick = e2 => {
                    emit2("handleClick", e2);
                }, canOpen = shallowRef(!1);
                return watch(dom, (() => {
                    nextTick((() => {
                        canOpen.value = !0;
                    }));
                })), () => {
                    var _a, _b;
                    const {width: width, height: height, open: $open, prefixCls: prefixCls, placement: placement, level: level, levelMove: levelMove, ease: ease, duration: duration, getContainer: getContainer2, onChange: onChange, afterVisibleChange: afterVisibleChange, showMask: showMask, maskClosable: maskClosable, maskStyle: maskStyle, keyboard: keyboard, getOpenCount: getOpenCount, scrollLocker: scrollLocker, contentWrapperStyle: contentWrapperStyle, style: style, class: className, rootClassName: rootClassName, rootStyle: rootStyle, maskMotion: maskMotion, motion: motion, inline: inline} = props2, otherProps = __rest$2(props2, [ "width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class", "rootClassName", "rootStyle", "maskMotion", "motion", "inline" ]), open2 = $open && canOpen.value, wrapperClassName = classNames(prefixCls, {
                        [`${prefixCls}-${placement}`]: !0,
                        [`${prefixCls}-open`]: open2,
                        [`${prefixCls}-inline`]: inline,
                        "no-mask": !showMask,
                        [rootClassName]: !0
                    }), motionProps = "function" == typeof motion ? motion(placement) : motion;
                    return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, omit(otherProps, [ "autofocus" ])), {}, {
                        tabindex: -1,
                        class: wrapperClassName,
                        style: rootStyle,
                        ref: dom,
                        onKeydown: open2 && keyboard ? onKeyDown : void 0
                    }), [ createVNode(Transition, maskMotion, {
                        default: () => [ showMask && withDirectives(createVNode("div", {
                            class: `${prefixCls}-mask`,
                            onClick: maskClosable ? onClose : void 0,
                            style: maskStyle,
                            ref: maskDom
                        }, null), [ [ vShow, open2 ] ]) ]
                    }), createVNode(Transition, _objectSpread2$1(_objectSpread2$1({}, motionProps), {}, {
                        onAfterEnter: onAfterVisibleChange,
                        onAfterLeave: onAfterVisibleChange
                    }), {
                        default: () => [ withDirectives(createVNode("div", {
                            class: `${prefixCls}-content-wrapper`,
                            style: [ contentWrapperStyle ],
                            ref: contentWrapper
                        }, [ createVNode("div", {
                            class: [ `${prefixCls}-content`, className ],
                            style: style,
                            ref: contentDom
                        }, [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]), slots.handler ? createVNode("div", {
                            onClick: onHandleClick,
                            ref: handlerDom
                        }, [ null === (_b = slots.handler) || void 0 === _b ? void 0 : _b.call(slots) ]) : null ]), [ [ vShow, open2 ] ]) ]
                    }) ]);
                };
            }
        });
        var __rest$1 = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const DrawerWrapper = defineComponent({
            compatConfig: {
                MODE: 3
            },
            inheritAttrs: !1,
            props: initDefaultProps(drawerProps$1(), {
                prefixCls: "drawer",
                placement: "left",
                getContainer: "body",
                level: "all",
                duration: ".3s",
                ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
                afterVisibleChange: () => {},
                showMask: !0,
                maskClosable: !0,
                maskStyle: {},
                wrapperClassName: "",
                keyboard: !0,
                forceRender: !1,
                autofocus: !0
            }),
            emits: [ "handleClick", "close" ],
            setup(props2, _ref) {
                let {emit: emit2, slots: slots} = _ref;
                const dom = ref(null), onHandleClick = e2 => {
                    emit2("handleClick", e2);
                }, onClose = e2 => {
                    emit2("close", e2);
                };
                return () => {
                    const {getContainer: getContainer2, wrapperClassName: wrapperClassName, rootClassName: rootClassName, rootStyle: rootStyle, forceRender: forceRender} = props2, otherProps = __rest$1(props2, [ "getContainer", "wrapperClassName", "rootClassName", "rootStyle", "forceRender" ]);
                    let portal = null;
                    if (!getContainer2) return createVNode(DrawerChild, _objectSpread2$1(_objectSpread2$1({}, otherProps), {}, {
                        rootClassName: rootClassName,
                        rootStyle: rootStyle,
                        open: props2.open,
                        onClose: onClose,
                        onHandleClick: onHandleClick,
                        inline: !0
                    }), slots);
                    const $forceRender = !!slots.handler || forceRender;
                    return ($forceRender || props2.open || dom.value) && (portal = createVNode(Portal, {
                        autoLock: !0,
                        visible: props2.open,
                        forceRender: $forceRender,
                        getContainer: getContainer2,
                        wrapperClassName: wrapperClassName
                    }, {
                        default: _a => {
                            var {visible: visible, afterClose: afterClose} = _a, rest = __rest$1(_a, [ "visible", "afterClose" ]);
                            return createVNode(DrawerChild, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
                                ref: dom
                            }, otherProps), rest), {}, {
                                rootClassName: rootClassName,
                                rootStyle: rootStyle,
                                open: void 0 !== visible ? visible : props2.open,
                                afterVisibleChange: void 0 !== afterClose ? afterClose : props2.afterVisibleChange,
                                onClose: onClose,
                                onHandleClick: onHandleClick
                            }), slots);
                        }
                    })), portal;
                };
            }
        }), genMotionStyle = token2 => {
            const {componentCls: componentCls, motionDurationSlow: motionDurationSlow} = token2, sharedPanelMotion = {
                "&-enter, &-appear, &-leave": {
                    "&-start": {
                        transition: "none"
                    },
                    "&-active": {
                        transition: `all ${motionDurationSlow}`
                    }
                }
            };
            return {
                [componentCls]: {
                    [`${componentCls}-mask-motion`]: {
                        "&-enter, &-appear, &-leave": {
                            "&-active": {
                                transition: `all ${motionDurationSlow}`
                            }
                        },
                        "&-enter, &-appear": {
                            opacity: 0,
                            "&-active": {
                                opacity: 1
                            }
                        },
                        "&-leave": {
                            opacity: 1,
                            "&-active": {
                                opacity: 0
                            }
                        }
                    },
                    [`${componentCls}-panel-motion`]: {
                        "&-left": [ sharedPanelMotion, {
                            "&-enter, &-appear": {
                                "&-start": {
                                    transform: "translateX(-100%) !important"
                                },
                                "&-active": {
                                    transform: "translateX(0)"
                                }
                            },
                            "&-leave": {
                                transform: "translateX(0)",
                                "&-active": {
                                    transform: "translateX(-100%)"
                                }
                            }
                        } ],
                        "&-right": [ sharedPanelMotion, {
                            "&-enter, &-appear": {
                                "&-start": {
                                    transform: "translateX(100%) !important"
                                },
                                "&-active": {
                                    transform: "translateX(0)"
                                }
                            },
                            "&-leave": {
                                transform: "translateX(0)",
                                "&-active": {
                                    transform: "translateX(100%)"
                                }
                            }
                        } ],
                        "&-top": [ sharedPanelMotion, {
                            "&-enter, &-appear": {
                                "&-start": {
                                    transform: "translateY(-100%) !important"
                                },
                                "&-active": {
                                    transform: "translateY(0)"
                                }
                            },
                            "&-leave": {
                                transform: "translateY(0)",
                                "&-active": {
                                    transform: "translateY(-100%)"
                                }
                            }
                        } ],
                        "&-bottom": [ sharedPanelMotion, {
                            "&-enter, &-appear": {
                                "&-start": {
                                    transform: "translateY(100%) !important"
                                },
                                "&-active": {
                                    transform: "translateY(0)"
                                }
                            },
                            "&-leave": {
                                transform: "translateY(0)",
                                "&-active": {
                                    transform: "translateY(100%)"
                                }
                            }
                        } ]
                    }
                }
            };
        }, genDrawerStyle = token2 => {
            const {componentCls: componentCls, zIndexPopup: zIndexPopup, colorBgMask: colorBgMask, colorBgElevated: colorBgElevated, motionDurationSlow: motionDurationSlow, motionDurationMid: motionDurationMid, padding: padding, paddingLG: paddingLG, fontSizeLG: fontSizeLG, lineHeightLG: lineHeightLG, lineWidth: lineWidth, lineType: lineType, colorSplit: colorSplit, marginSM: marginSM, colorIcon: colorIcon, colorIconHover: colorIconHover, colorText: colorText, fontWeightStrong: fontWeightStrong, drawerFooterPaddingVertical: drawerFooterPaddingVertical, drawerFooterPaddingHorizontal: drawerFooterPaddingHorizontal} = token2, wrapperCls = `${componentCls}-content-wrapper`;
            return {
                [componentCls]: {
                    position: "fixed",
                    inset: 0,
                    zIndex: zIndexPopup,
                    pointerEvents: "none",
                    "&-pure": {
                        position: "relative",
                        background: colorBgElevated,
                        [`&${componentCls}-left`]: {
                            boxShadow: token2.boxShadowDrawerLeft
                        },
                        [`&${componentCls}-right`]: {
                            boxShadow: token2.boxShadowDrawerRight
                        },
                        [`&${componentCls}-top`]: {
                            boxShadow: token2.boxShadowDrawerUp
                        },
                        [`&${componentCls}-bottom`]: {
                            boxShadow: token2.boxShadowDrawerDown
                        }
                    },
                    "&-inline": {
                        position: "absolute"
                    },
                    [`${componentCls}-mask`]: {
                        position: "absolute",
                        inset: 0,
                        zIndex: zIndexPopup,
                        background: colorBgMask,
                        pointerEvents: "auto"
                    },
                    [wrapperCls]: {
                        position: "absolute",
                        zIndex: zIndexPopup,
                        transition: `all ${motionDurationSlow}`,
                        "&-hidden": {
                            display: "none"
                        }
                    },
                    [`&-left > ${wrapperCls}`]: {
                        top: 0,
                        bottom: 0,
                        left: {
                            _skip_check_: !0,
                            value: 0
                        },
                        boxShadow: token2.boxShadowDrawerLeft
                    },
                    [`&-right > ${wrapperCls}`]: {
                        top: 0,
                        right: {
                            _skip_check_: !0,
                            value: 0
                        },
                        bottom: 0,
                        boxShadow: token2.boxShadowDrawerRight
                    },
                    [`&-top > ${wrapperCls}`]: {
                        top: 0,
                        insetInline: 0,
                        boxShadow: token2.boxShadowDrawerUp
                    },
                    [`&-bottom > ${wrapperCls}`]: {
                        bottom: 0,
                        insetInline: 0,
                        boxShadow: token2.boxShadowDrawerDown
                    },
                    [`${componentCls}-content`]: {
                        width: "100%",
                        height: "100%",
                        overflow: "auto",
                        background: colorBgElevated,
                        pointerEvents: "auto"
                    },
                    [`${componentCls}-wrapper-body`]: {
                        display: "flex",
                        flexDirection: "column",
                        width: "100%",
                        height: "100%"
                    },
                    [`${componentCls}-header`]: {
                        display: "flex",
                        flex: 0,
                        alignItems: "center",
                        padding: `${padding}px ${paddingLG}px`,
                        fontSize: fontSizeLG,
                        lineHeight: lineHeightLG,
                        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
                        "&-title": {
                            display: "flex",
                            flex: 1,
                            alignItems: "center",
                            minWidth: 0,
                            minHeight: 0
                        }
                    },
                    [`${componentCls}-extra`]: {
                        flex: "none"
                    },
                    [`${componentCls}-close`]: {
                        display: "inline-block",
                        marginInlineEnd: marginSM,
                        color: colorIcon,
                        fontWeight: fontWeightStrong,
                        fontSize: fontSizeLG,
                        fontStyle: "normal",
                        lineHeight: 1,
                        textAlign: "center",
                        textTransform: "none",
                        textDecoration: "none",
                        background: "transparent",
                        border: 0,
                        outline: 0,
                        cursor: "pointer",
                        transition: `color ${motionDurationMid}`,
                        textRendering: "auto",
                        "&:focus, &:hover": {
                            color: colorIconHover,
                            textDecoration: "none"
                        }
                    },
                    [`${componentCls}-title`]: {
                        flex: 1,
                        margin: 0,
                        color: colorText,
                        fontWeight: token2.fontWeightStrong,
                        fontSize: fontSizeLG,
                        lineHeight: lineHeightLG
                    },
                    [`${componentCls}-body`]: {
                        flex: 1,
                        minWidth: 0,
                        minHeight: 0,
                        padding: paddingLG,
                        overflow: "auto"
                    },
                    [`${componentCls}-footer`]: {
                        flexShrink: 0,
                        padding: `${drawerFooterPaddingVertical}px ${drawerFooterPaddingHorizontal}px`,
                        borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
                    },
                    "&-rtl": {
                        direction: "rtl"
                    }
                }
            };
        }, useStyle = genComponentStyleHook("Drawer", (token2 => {
            const drawerToken = merge(token2, {
                drawerFooterPaddingVertical: token2.paddingXS,
                drawerFooterPaddingHorizontal: token2.padding
            });
            return [ genDrawerStyle(drawerToken), genMotionStyle(drawerToken) ];
        }), (token2 => ({
            zIndexPopup: token2.zIndexPopupBase
        })));
        var __rest = function(s2, e2) {
            var t2 = {};
            for (var p2 in s2) Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s2[p2]);
            if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
                var i2 = 0;
                for (p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]) && (t2[p2[i2]] = s2[p2[i2]]);
            }
            return t2;
        };
        const PlacementTypes = [ "top", "right", "bottom", "left" ], defaultPushState = {
            distance: 180
        }, Drawer$1 = withInstall(defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ADrawer",
            inheritAttrs: !1,
            props: initDefaultProps((() => ({
                autofocus: {
                    type: Boolean,
                    default: void 0
                },
                closable: {
                    type: Boolean,
                    default: void 0
                },
                closeIcon: PropTypes.any,
                destroyOnClose: {
                    type: Boolean,
                    default: void 0
                },
                forceRender: {
                    type: Boolean,
                    default: void 0
                },
                getContainer: {
                    type: [ String, Function, Boolean, Object ],
                    default: void 0
                },
                maskClosable: {
                    type: Boolean,
                    default: void 0
                },
                mask: {
                    type: Boolean,
                    default: void 0
                },
                maskStyle: objectType(),
                rootClassName: String,
                rootStyle: objectType(),
                size: {
                    type: String
                },
                drawerStyle: objectType(),
                headerStyle: objectType(),
                bodyStyle: objectType(),
                contentWrapperStyle: {
                    type: Object,
                    default: void 0
                },
                title: PropTypes.any,
                visible: {
                    type: Boolean,
                    default: void 0
                },
                open: {
                    type: Boolean,
                    default: void 0
                },
                width: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
                height: PropTypes.oneOfType([ PropTypes.string, PropTypes.number ]),
                zIndex: Number,
                prefixCls: String,
                push: PropTypes.oneOfType([ PropTypes.looseBool, {
                    type: Object
                } ]),
                placement: PropTypes.oneOf(PlacementTypes),
                keyboard: {
                    type: Boolean,
                    default: void 0
                },
                extra: PropTypes.any,
                footer: PropTypes.any,
                footerStyle: objectType(),
                level: PropTypes.any,
                levelMove: {
                    type: [ Number, Array, Function ]
                },
                handle: PropTypes.any,
                afterVisibleChange: Function,
                onAfterVisibleChange: Function,
                onAfterOpenChange: Function,
                "onUpdate:visible": Function,
                "onUpdate:open": Function,
                onClose: Function
            }))(), {
                closable: !0,
                placement: "right",
                maskClosable: !0,
                mask: !0,
                level: null,
                keyboard: !0,
                push: defaultPushState
            }),
            slots: Object,
            setup(props2, _ref) {
                let {emit: emit2, slots: slots, attrs: attrs} = _ref;
                const sPush = shallowRef(!1), destroyClose = shallowRef(!1), vcDrawer = shallowRef(null), load = shallowRef(!1), visible = shallowRef(!1), mergedOpen = computed((() => {
                    var _a;
                    return null !== (_a = props2.open) && void 0 !== _a ? _a : props2.visible;
                }));
                watch(mergedOpen, (() => {
                    mergedOpen.value ? load.value = !0 : visible.value = !1;
                }), {
                    immediate: !0
                }), watch([ mergedOpen, load ], (() => {
                    mergedOpen.value && load.value && (visible.value = !0);
                }), {
                    immediate: !0
                });
                const parentDrawerOpts = inject("parentDrawerOpts", null), {prefixCls: prefixCls, getPopupContainer: getPopupContainer, direction: direction} = useConfigInject("drawer", props2), [wrapSSR, hashId] = useStyle(prefixCls), getContainer2 = computed((() => void 0 === props2.getContainer && (null == getPopupContainer ? void 0 : getPopupContainer.value) ? () => getPopupContainer.value(document.body) : props2.getContainer));
                devWarning(!props2.afterVisibleChange, "Drawer", "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead");
                provide("parentDrawerOpts", {
                    setPush: () => {
                        sPush.value = !0;
                    },
                    setPull: () => {
                        sPush.value = !1, nextTick((() => {
                            domFocus();
                        }));
                    }
                }), onMounted((() => {
                    mergedOpen.value && parentDrawerOpts && parentDrawerOpts.setPush();
                })), onUnmounted((() => {
                    parentDrawerOpts && parentDrawerOpts.setPull();
                })), watch(visible, (() => {
                    parentDrawerOpts && (visible.value ? parentDrawerOpts.setPush() : parentDrawerOpts.setPull());
                }), {
                    flush: "post"
                });
                const domFocus = () => {
                    var _a, _b;
                    null === (_b = null === (_a = vcDrawer.value) || void 0 === _a ? void 0 : _a.domFocus) || void 0 === _b || _b.call(_a);
                }, close = e2 => {
                    emit2("update:visible", !1), emit2("update:open", !1), emit2("close", e2);
                }, afterVisibleChange = open2 => {
                    var _a;
                    open2 || (!1 === destroyClose.value && (destroyClose.value = !0), props2.destroyOnClose && (load.value = !1)), 
                    null === (_a = props2.afterVisibleChange) || void 0 === _a || _a.call(props2, open2), 
                    emit2("afterVisibleChange", open2), emit2("afterOpenChange", open2);
                }, pushTransform = computed((() => {
                    const {push: push, placement: placement} = props2;
                    let distance;
                    return distance = "boolean" == typeof push ? push ? defaultPushState.distance : 0 : push.distance, 
                    distance = parseFloat(String(distance || 0)), "left" === placement || "right" === placement ? `translateX(${"left" === placement ? distance : -distance}px)` : "top" === placement || "bottom" === placement ? `translateY(${"top" === placement ? distance : -distance}px)` : null;
                })), mergedWidth = computed((() => {
                    var _a;
                    return null !== (_a = props2.width) && void 0 !== _a ? _a : "large" === props2.size ? 736 : 378;
                })), mergedHeight = computed((() => {
                    var _a;
                    return null !== (_a = props2.height) && void 0 !== _a ? _a : "large" === props2.size ? 736 : 378;
                })), offsetStyle = computed((() => {
                    const {mask: mask, placement: placement} = props2;
                    if (!visible.value && !mask) return {};
                    const val = {};
                    return "left" === placement || "right" === placement ? val.width = isNumeric(mergedWidth.value) ? `${mergedWidth.value}px` : mergedWidth.value : val.height = isNumeric(mergedHeight.value) ? `${mergedHeight.value}px` : mergedHeight.value, 
                    val;
                })), wrapperStyle = computed((() => {
                    const {zIndex: zIndex, contentWrapperStyle: contentWrapperStyle} = props2, val = offsetStyle.value;
                    return [ {
                        zIndex: zIndex,
                        transform: sPush.value ? pushTransform.value : void 0
                    }, _extends$1({}, contentWrapperStyle), val ];
                })), renderHeader = prefixCls2 => {
                    const {closable: closable, headerStyle: headerStyle} = props2, extra = getPropsSlot(slots, props2, "extra"), title = getPropsSlot(slots, props2, "title");
                    return title || closable ? createVNode("div", {
                        class: classNames(`${prefixCls2}-header`, {
                            [`${prefixCls2}-header-close-only`]: closable && !title && !extra
                        }),
                        style: headerStyle
                    }, [ createVNode("div", {
                        class: `${prefixCls2}-header-title`
                    }, [ renderCloseIcon(prefixCls2), title && createVNode("div", {
                        class: `${prefixCls2}-title`
                    }, [ title ]) ]), extra && createVNode("div", {
                        class: `${prefixCls2}-extra`
                    }, [ extra ]) ]) : null;
                }, renderCloseIcon = prefixCls2 => {
                    var _a;
                    const {closable: closable} = props2, $closeIcon = slots.closeIcon ? null === (_a = slots.closeIcon) || void 0 === _a ? void 0 : _a.call(slots) : props2.closeIcon;
                    return closable && createVNode("button", {
                        key: "closer",
                        onClick: close,
                        "aria-label": "Close",
                        class: `${prefixCls2}-close`
                    }, [ void 0 === $closeIcon ? createVNode(CloseOutlined, null, null) : $closeIcon ]);
                }, renderBody = prefixCls2 => {
                    var _a;
                    if (destroyClose.value && !props2.forceRender && !load.value) return null;
                    const {bodyStyle: bodyStyle, drawerStyle: drawerStyle} = props2;
                    return createVNode("div", {
                        class: `${prefixCls2}-wrapper-body`,
                        style: drawerStyle
                    }, [ renderHeader(prefixCls2), createVNode("div", {
                        key: "body",
                        class: `${prefixCls2}-body`,
                        style: bodyStyle
                    }, [ null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots) ]), renderFooter(prefixCls2) ]);
                }, renderFooter = prefixCls2 => {
                    const footer = getPropsSlot(slots, props2, "footer");
                    if (!footer) return null;
                    return createVNode("div", {
                        class: `${prefixCls2}-footer`,
                        style: props2.footerStyle
                    }, [ footer ]);
                }, drawerClassName = computed((() => classNames({
                    "no-mask": !props2.mask,
                    [`${prefixCls.value}-rtl`]: "rtl" === direction.value
                }, props2.rootClassName, hashId.value))), maskMotion = computed((() => getTransitionProps(getTransitionName(prefixCls.value, "mask-motion")))), panelMotion = motionPlacement => getTransitionProps(getTransitionName(prefixCls.value, `panel-motion-${motionPlacement}`));
                return () => {
                    const {width: width, height: height, placement: placement, mask: mask, forceRender: forceRender} = props2, rest = __rest(props2, [ "width", "height", "placement", "mask", "forceRender" ]), vcDrawerProps = _extends$1(_extends$1(_extends$1({}, attrs), omit(rest, [ "size", "closeIcon", "closable", "destroyOnClose", "drawerStyle", "headerStyle", "bodyStyle", "title", "push", "onAfterVisibleChange", "onClose", "onUpdate:visible", "onUpdate:open", "visible" ])), {
                        forceRender: forceRender,
                        onClose: close,
                        afterVisibleChange: afterVisibleChange,
                        handler: !1,
                        prefixCls: prefixCls.value,
                        open: visible.value,
                        showMask: mask,
                        placement: placement,
                        ref: vcDrawer
                    });
                    return wrapSSR(createVNode(NoCompactStyle, null, {
                        default: () => [ createVNode(DrawerWrapper, _objectSpread2$1(_objectSpread2$1({}, vcDrawerProps), {}, {
                            maskMotion: maskMotion.value,
                            motion: panelMotion,
                            width: mergedWidth.value,
                            height: mergedHeight.value,
                            getContainer: getContainer2.value,
                            rootClassName: drawerClassName.value,
                            rootStyle: props2.rootStyle,
                            contentWrapperStyle: wrapperStyle.value
                        }), {
                            handler: props2.handle ? () => props2.handle : slots.handle,
                            default: () => renderBody(prefixCls.value)
                        }) ]
                    }));
                };
            }
        })), spaceSize = {
            small: 8,
            middle: 16,
            large: 24
        };
        function getNumberSize(size2) {
            return "string" == typeof size2 ? spaceSize[size2] : size2 || 0;
        }
        const Space = defineComponent({
            compatConfig: {
                MODE: 3
            },
            name: "ASpace",
            inheritAttrs: !1,
            props: (() => ({
                prefixCls: String,
                size: {
                    type: [ String, Number, Array ]
                },
                direction: PropTypes.oneOf(tuple("horizontal", "vertical")).def("horizontal"),
                align: PropTypes.oneOf(tuple("start", "end", "center", "baseline")),
                wrap: booleanType()
            }))(),
            slots: Object,
            setup(props2, _ref) {
                let {slots: slots, attrs: attrs} = _ref;
                const {prefixCls: prefixCls, space: space, direction: directionConfig} = useConfigInject("space", props2), [wrapSSR, hashId] = useStyle$a(prefixCls), supportFlexGap = useFlexGapSupport(), size2 = computed((() => {
                    var _a, _b, _c;
                    return null !== (_c = null !== (_a = props2.size) && void 0 !== _a ? _a : null === (_b = null == space ? void 0 : space.value) || void 0 === _b ? void 0 : _b.size) && void 0 !== _c ? _c : "small";
                })), horizontalSize = ref(), verticalSize = ref();
                watch(size2, (() => {
                    [horizontalSize.value, verticalSize.value] = (Array.isArray(size2.value) ? size2.value : [ size2.value, size2.value ]).map((item => getNumberSize(item)));
                }), {
                    immediate: !0
                });
                const mergedAlign = computed((() => void 0 === props2.align && "horizontal" === props2.direction ? "center" : props2.align)), cn = computed((() => classNames(prefixCls.value, hashId.value, `${prefixCls.value}-${props2.direction}`, {
                    [`${prefixCls.value}-rtl`]: "rtl" === directionConfig.value,
                    [`${prefixCls.value}-align-${mergedAlign.value}`]: mergedAlign.value
                }))), marginDirection = computed((() => "rtl" === directionConfig.value ? "marginLeft" : "marginRight")), style = computed((() => {
                    const gapStyle = {};
                    return supportFlexGap.value && (gapStyle.columnGap = `${horizontalSize.value}px`, 
                    gapStyle.rowGap = `${verticalSize.value}px`), _extends$1(_extends$1({}, gapStyle), props2.wrap && {
                        flexWrap: "wrap",
                        marginBottom: -verticalSize.value + "px"
                    });
                }));
                return () => {
                    var _a, _b;
                    const {wrap: wrap, direction: direction = "horizontal"} = props2, children = null === (_a = slots.default) || void 0 === _a ? void 0 : _a.call(slots), items = filterEmpty(children), len = items.length;
                    if (0 === len) return null;
                    const split = null === (_b = slots.split) || void 0 === _b ? void 0 : _b.call(slots), itemClassName = `${prefixCls.value}-item`, horizontalSizeVal = horizontalSize.value, latestIndex = len - 1;
                    return createVNode("div", _objectSpread2$1(_objectSpread2$1({}, attrs), {}, {
                        class: [ cn.value, attrs.class ],
                        style: [ style.value, attrs.style ]
                    }), [ items.map(((child, index2) => {
                        let originIndex = children.indexOf(child);
                        -1 === originIndex && (originIndex = `$$space-${index2}`);
                        let itemStyle = {};
                        return supportFlexGap.value || ("vertical" === direction ? index2 < latestIndex && (itemStyle = {
                            marginBottom: horizontalSizeVal / (split ? 2 : 1) + "px"
                        }) : itemStyle = _extends$1(_extends$1({}, index2 < latestIndex && {
                            [marginDirection.value]: horizontalSizeVal / (split ? 2 : 1) + "px"
                        }), wrap && {
                            paddingBottom: `${verticalSize.value}px`
                        })), wrapSSR(createVNode(Fragment, {
                            key: originIndex
                        }, [ createVNode("div", {
                            class: itemClassName,
                            style: itemStyle
                        }, [ child ]), index2 < latestIndex && split && createVNode("span", {
                            class: `${itemClassName}-split`,
                            style: itemStyle
                        }, [ split ]) ]));
                    })) ]);
                };
            }
        });
        Space.Compact = Compact, Space.install = function(app) {
            return app.component(Space.name, Space), app.component(Compact.name, Compact), app;
        };
        var DeleteOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"
                    }
                } ]
            },
            name: "delete",
            theme: "outlined"
        };
        function _objectSpread$2(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$2(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$2(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var DeleteOutlined = function DeleteOutlined2(props2, context) {
            var p2 = _objectSpread$2({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$2({}, p2, {
                icon: DeleteOutlined$1
            }), null);
        };
        DeleteOutlined.displayName = "DeleteOutlined", DeleteOutlined.inheritAttrs = !1;
        var ArrowDownOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M862 465.3h-81c-4.6 0-9 2-12.1 5.5L550 723.1V160c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v563.1L255.1 470.8c-3-3.5-7.4-5.5-12.1-5.5h-81c-6.8 0-10.5 8.1-6 13.2L487.9 861a31.96 31.96 0 0048.3 0L868 478.5c4.5-5.2.8-13.2-6-13.2z"
                    }
                } ]
            },
            name: "arrow-down",
            theme: "outlined"
        };
        function _objectSpread$1(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty$1(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty$1(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var ArrowDownOutlined = function ArrowDownOutlined2(props2, context) {
            var p2 = _objectSpread$1({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread$1({}, p2, {
                icon: ArrowDownOutlined$1
            }), null);
        };
        ArrowDownOutlined.displayName = "ArrowDownOutlined", ArrowDownOutlined.inheritAttrs = !1;
        var ArrowUpOutlined$1 = {
            icon: {
                tag: "svg",
                attrs: {
                    viewBox: "64 64 896 896",
                    focusable: "false"
                },
                children: [ {
                    tag: "path",
                    attrs: {
                        d: "M868 545.5L536.1 163a31.96 31.96 0 00-48.3 0L156 545.5a7.97 7.97 0 006 13.2h81c4.6 0 9-2 12.1-5.5L474 300.9V864c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V300.9l218.9 252.3c3 3.5 7.4 5.5 12.1 5.5h81c6.8 0 10.5-8 6-13.2z"
                    }
                } ]
            },
            name: "arrow-up",
            theme: "outlined"
        };
        function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = null != arguments[i2] ? Object(arguments[i2]) : {}, ownKeys2 = Object.keys(source);
                "function" == typeof Object.getOwnPropertySymbols && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                    return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                })))), ownKeys2.forEach((function(key2) {
                    _defineProperty(target, key2, source[key2]);
                }));
            }
            return target;
        }
        function _defineProperty(obj, key2, value) {
            return key2 in obj ? Object.defineProperty(obj, key2, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key2] = value, obj;
        }
        var ArrowUpOutlined = function ArrowUpOutlined2(props2, context) {
            var p2 = _objectSpread({}, props2, context.attrs);
            return createVNode(Icon, _objectSpread({}, p2, {
                icon: ArrowUpOutlined$1
            }), null);
        };
        ArrowUpOutlined.displayName = "ArrowUpOutlined", ArrowUpOutlined.inheritAttrs = !1;
        const _export_sfc = (sfc, props2) => {
            const target = sfc.__vccOpts || sfc;
            for (const [key2, val] of props2) target[key2] = val;
            return target;
        }, _sfc_main$1 = {}, _hoisted_1$1 = {
            class: "icon",
            style: {
                width: "1em",
                height: "1em",
                "vertical-align": "middle",
                fill: "currentColor",
                overflow: "hidden"
            },
            viewBox: "0 0 1024 1024",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg"
        }, _hoisted_16 = [ createBaseVNode("path", {
            d: "M496 809.6c22.4 9.6 41.6 16 60.8 20.8-6.4 33.6-12.8 67.2-17.6 100.8-3.2 17.6-19.2 28.8-36.8 27.2-17.6-3.2-28.8-19.2-27.2-36.8 4.8-36.8 12.8-75.2 20.8-112z",
            fill: "#FFFFFF",
            "p-id": "770"
        }, null, -1), createBaseVNode("path", {
            d: "M467.2 859.2c-4.8-28.8-9.6-59.2-16-89.6 19.2-4.8 38.4-12.8 57.6-24 4.8 20.8 9.6 40 14.4 60.8-20.8 19.2-38.4 36.8-56 52.8z",
            fill: "#FFFFFF",
            "p-id": "771"
        }, null, -1), createBaseVNode("path", {
            d: "M539.2 924.8c1.6 17.6-12.8 33.6-30.4 33.6-17.6 1.6-33.6-12.8-33.6-30.4-22.4-337.6 115.2-816 131.2-808 16 6.4-89.6 475.2-67.2 804.8z",
            fill: "#3A8230",
            "p-id": "772"
        }, null, -1), createBaseVNode("path", {
            d: "M540.8 398.4c-40 192-60.8 380.8-49.6 529.6 0 9.6 8 16 17.6 14.4 9.6 0 16-8 14.4-17.6-4.8-72-3.2-155.2 1.6-248 6.4-89.6 16-184 30.4-289.6 3.2-28.8 12.8-86.4 19.2-131.2-11.2 43.2-22.4 91.2-33.6 142.4z m14.4 524.8c1.6 27.2-17.6 49.6-44.8 51.2-27.2 1.6-49.6-17.6-51.2-44.8-9.6-152 9.6-342.4 51.2-537.6 16-75.2 33.6-145.6 49.6-200 8-24 14.4-44.8 19.2-57.6 3.2-8 4.8-12.8 8-17.6 1.6-3.2 3.2-4.8 4.8-6.4 4.8-4.8 11.2-8 19.2-3.2 12.8 3.2 12.8 9.6 11.2 36.8-1.6 12.8-3.2 30.4-8 57.6 1.6-8-20.8 139.2-27.2 190.4-14.4 105.6-24 198.4-30.4 288-6.4 91.2-6.4 171.2-1.6 243.2z",
            fill: "#333333",
            "p-id": "773"
        }, null, -1), createBaseVNode("path", {
            d: "M539.2 928c-1.6 17.6-16 30.4-33.6 30.4-17.6-1.6-30.4-16-30.4-33.6 17.6-305.6-110.4-846.4-92.8-851.2 16-8 174.4 540.8 156.8 854.4z",
            fill: "#3A8230",
            "p-id": "774"
        }, null, -1), createBaseVNode("path", {
            d: "M443.2 382.4c12.8 78.4 22.4 148.8 30.4 216 16 131.2 20.8 240 16 326.4 0 9.6 6.4 16 14.4 17.6 9.6 0 16-6.4 17.6-14.4 8-137.6-17.6-332.8-65.6-544-12.8-56-25.6-110.4-40-158.4 11.2 52.8 22.4 123.2 27.2 156.8z m112 547.2c-1.6 27.2-24 46.4-51.2 44.8-27.2-1.6-46.4-24-44.8-51.2 4.8-84.8-1.6-192-16-321.6-8-67.2-17.6-136-30.4-214.4-9.6-59.2-38.4-235.2-36.8-220.8-4.8-32-8-52.8-9.6-67.2-3.2-33.6-3.2-36.8 9.6-43.2 20.8-8 28.8 8 54.4 97.6 19.2 60.8 40 139.2 57.6 222.4 48 214.4 75.2 412.8 67.2 553.6z",
            fill: "#333333",
            "p-id": "775"
        }, null, -1), createBaseVNode("path", {
            d: "M476.8 928c1.6 17.6 16 30.4 33.6 30.4 17.6-1.6 30.4-16 30.4-33.6-17.6-305.6-1.6-846.4-19.2-851.2-16-8-62.4 540.8-44.8 854.4z",
            fill: "#3A8230",
            "p-id": "776"
        }, null, -1), createBaseVNode("path", {
            d: "M515.2 380.8c0 112 0 156.8 1.6 219.2 1.6 134.4 3.2 240 8 324.8 0 9.6-6.4 16-14.4 17.6s-16-6.4-17.6-14.4c-8-140.8-3.2-342.4 9.6-545.6 3.2-54.4 8-107.2 11.2-152 1.6 35.2 1.6 81.6 1.6 150.4z m-54.4 548.8c1.6 27.2 24 46.4 51.2 44.8 27.2-1.6 46.4-24 44.8-51.2-4.8-83.2-8-188.8-8-323.2 0-62.4 0-107.2-1.6-219.2 0-323.2 0-316.8-19.2-323.2-9.6-3.2-16 0-20.8 6.4-1.6 1.6-3.2 4.8-3.2 8-1.6 4.8-3.2 11.2-4.8 19.2-3.2 16-6.4 38.4-9.6 65.6-6.4 57.6-12.8 136-19.2 222.4-12.8 203.2-17.6 408-9.6 550.4z",
            fill: "#333333",
            "p-id": "777"
        }, null, -1), createBaseVNode("path", {
            d: "M539.2 923.2c1.6 17.6-11.2 33.6-28.8 33.6-17.6 1.6-33.6-11.2-33.6-28.8C448 584 201.6 128 214.4 115.2S512 566.4 539.2 923.2z",
            fill: "#64B059",
            "p-id": "778"
        }, null, -1), createBaseVNode("path", {
            d: "M467.2 859.2c-4.8-28.8-9.6-59.2-16-89.6 19.2-4.8 38.4-12.8 57.6-24 4.8 20.8 9.6 40 14.4 60.8-20.8 19.2-38.4 36.8-56 52.8z",
            fill: "#E0F2D1",
            "p-id": "779"
        }, null, -1), createBaseVNode("path", {
            d: "M360 430.4c38.4 97.6 68.8 190.4 91.2 276.8 20.8 80 33.6 153.6 38.4 219.2 0 9.6 8 16 17.6 14.4 9.6 0 16-8 14.4-17.6-11.2-155.2-73.6-344-166.4-537.6-24-48-48-96-70.4-137.6 33.6 76.8 52.8 121.6 75.2 182.4z m195.2 492.8c1.6 27.2-17.6 49.6-44.8 51.2s-49.6-17.6-51.2-44.8c-4.8-64-17.6-136-38.4-214.4-22.4-86.4-52.8-176-89.6-273.6-27.2-72-49.6-123.2-94.4-224-17.6-38.4-24-54.4-28.8-68.8-12.8-32-14.4-36.8-3.2-46.4 6.4-6.4 14.4-4.8 20.8-1.6 1.6 1.6 4.8 3.2 6.4 4.8 3.2 3.2 8 8 12.8 16 9.6 12.8 22.4 32 36.8 56 33.6 54.4 70.4 123.2 105.6 195.2 92.8 196.8 155.2 390.4 168 550.4z",
            fill: "#333333",
            "p-id": "780"
        }, null, -1), createBaseVNode("path", {
            d: "M537.6 931.2c-3.2 17.6-19.2 28.8-36.8 27.2-17.6-3.2-28.8-19.2-27.2-36.8C540.8 492.8 747.2 68.8 761.6 80s-158.4 432-224 851.2z",
            fill: "#64B059",
            "p-id": "781"
        }, null, -1), createBaseVNode("path", {
            d: "M496 809.6c22.4 9.6 41.6 16 60.8 20.8-8 33.6-12.8 67.2-19.2 100.8-3.2 17.6-19.2 28.8-36.8 27.2-17.6-3.2-28.8-19.2-27.2-36.8 6.4-36.8 14.4-75.2 22.4-112z",
            fill: "#E0F2D1",
            "p-id": "782"
        }, null, -1), createBaseVNode("path", {
            d: "M745.6 83.2z m-92.8 259.2C579.2 531.2 520 736 491.2 924.8c-1.6 8 4.8 17.6 12.8 17.6 8 1.6 17.6-4.8 17.6-12.8 0-4.8 1.6-8 1.6-12.8 20.8-134.4 54.4-276.8 97.6-430.4 25.6-91.2 44.8-152 86.4-280-16 40-35.2 86.4-54.4 136z m-99.2 592c-4.8 25.6-28.8 44.8-54.4 40-25.6-4.8-44.8-28.8-40-54.4 28.8-192 89.6-396.8 163.2-588.8 28.8-73.6 57.6-140.8 83.2-190.4 11.2-22.4 20.8-40 28.8-52.8 3.2-6.4 8-11.2 9.6-14.4l6.4-6.4c6.4-3.2 12.8-4.8 19.2 0 11.2 8 11.2 14.4 0 51.2-4.8 17.6-12.8 40-27.2 86.4-43.2 136-62.4 196.8-89.6 289.6-43.2 152-76.8 292.8-97.6 425.6 0 4.8 0 9.6-1.6 14.4z",
            fill: "#333333",
            "p-id": "783"
        }, null, -1) ];
        function _sfc_render(_ctx, _cache) {
            return openBlock(), createElementBlock("svg", _hoisted_1$1, _hoisted_16);
        }
        const IconLeek = _export_sfc(_sfc_main$1, [ [ "render", _sfc_render ] ]);
        class LimitedSet {
            constructor(value, maxSize = 20) {
                __publicField(this, "maxSize"), __publicField(this, "set"), this.maxSize = maxSize, 
                this.set = new Set(value);
            }
            add(...values) {
                for (values.forEach((value => this.set.add(value))); this.set.size > this.maxSize; ) {
                    const firstValue = this.set.values().next().value;
                    this.set.delete(firstValue);
                }
            }
            has(value) {
                return this.set.has(value);
            }
            delete(value) {
                return this.set.delete(value);
            }
            clear() {
                this.set.clear();
            }
            size() {
                return this.set.size;
            }
            values() {
                return this.set.values();
            }
            toArray() {
                return Array.from(this.set);
            }
        }
        const _hoisted_1 = {
            class: "leek-count"
        }, _hoisted_2 = {
            class: "leek-search"
        }, _hoisted_3 = {
            class: "leek-search-sticky"
        }, _hoisted_4 = {
            class: "leek-select-item"
        }, _hoisted_5 = {
            class: "leek-select-item-label"
        }, _hoisted_6 = {
            class: "leek-search-history"
        }, _hoisted_7 = {
            class: "leek-search-history-title"
        }, _hoisted_8 = createBaseVNode("h4", null, "历史搜索", -1), _hoisted_9 = {
            class: "leek-search-history-clear"
        }, _hoisted_10 = {
            class: "leek-search-history-content"
        }, _hoisted_11 = {
            class: "leek-select-item"
        }, _hoisted_12 = {
            class: "leek-select-item-label"
        }, MaxSelectCount = 5, allItemsInfoLabel = "所有外观";
        createApp(defineComponent({
            __name: "App",
            setup(__props) {
                ConfigProvider.config({
                    prefixCls: "antVue"
                });
                const sandboxWindow = "undefined" != typeof unsafeWindow ? unsafeWindow : window, leekCachesString = sessionStorage.getItem("leekCaches") || "{}";
                function getLocal() {
                    try {
                        return JSON.parse(leekCachesString);
                    } catch (error) {
                        return {};
                    }
                }
                function setLocal(key2, json) {
                    isEqual(leekCaches[key2], json) || (leekCaches[key2] = json, sessionStorage.setItem("leekCaches", JSON.stringify(leekCaches)));
                }
                let leekCaches = getLocal();
                const isInitRef = ref(!1), historyItemsRef = ref(new LimitedSet([], 10)), formRef = ref(null), formModel = reactive({}), formInfo = reactive([]), orderRef = ref("price-1"), allItemsInfo = ref({
                    label: allItemsInfoLabel,
                    options: []
                }), dataMap = {}, openRef = ref(!1), onClose = () => {
                    openRef.value = !1;
                }, onOpen = () => {
                    /(\/buyer.*t=skin)|localhost/.test(window.location.href) ? (check(), openRef.value = !0) : api$1.error('只能在"买外观"页面使用');
                };
                function init() {
                    fetch("https://www.aijx3.cn/api/wblwg/basedata/getSearchData", {
                        method: "POST"
                    }).then((response => {
                        if (!response.ok) throw new Error("Network response was not ok " + response.statusText);
                        return response.json();
                    })).then((data => {
                        isInitRef.value = !0;
                        const itemCategory = data.data;
                        let info = [];
                        itemCategory.map((item => {
                            formModel[item.typeName] || (formModel[item.typeName] = []);
                            const options = item.dataModels.map((i2 => {
                                dataMap[i2.showName] = i2;
                                const {name: name, showName: showName, typeName: typeName, searchDescType: searchDescType, searchId: searchId} = i2;
                                return {
                                    label: `${name}(${showName})`,
                                    value: showName,
                                    typeName: typeName,
                                    searchDescType: searchDescType,
                                    searchId: searchId
                                };
                            }));
                            info.push({
                                label: item.typeName,
                                options: options
                            }), allItemsInfo.value.options.push(...options);
                        })), formInfo.push(...info), sandboxSelect([]), allItems.value = leekCaches.selectedItems || [], 
                        orderRef.value = leekCaches.order || "price-1", historyTagsAdd(leekCaches.historyItems || []);
                    })).catch((error => {}));
                }
                init();
                const allItems = computed({
                    get: () => {
                        const _all = [];
                        return Object.keys(formModel).map((key2 => {
                            formModel[key2] && _all.push(...formModel[key2]);
                        })), _all;
                    },
                    set: vals => {
                        const _formModel = {};
                        null == vals || vals.map((val => {
                            const {typeName: typeName} = dataMap[val] || {};
                            typeName && (_formModel[typeName] || (_formModel[typeName] = []), _formModel[typeName].push(val));
                        })), Object.keys(formModel).map((key2 => {
                            key2 !== allItemsInfoLabel && (formModel[key2] = _formModel[key2] || []);
                        }));
                    }
                }), onChange = name => (value, _options) => {
                    allItems.value.length > MaxSelectCount && (api$1.error(`同时最大可选物品数量 ${MaxSelectCount}`), 
                    name !== allItemsInfoLabel ? formModel[name] = value.slice(0, value.length - 1) : allItems.value = value.slice(0, value.length - 1));
                }, onReset = () => {
                    orderRef.value = "price-1", Object.keys(formModel).map((key2 => {
                        formModel[key2] = [];
                    }));
                }, onSearch = () => {
                    var _a, _b;
                    openRef.value = !1, null == (_b = null == (_a = null == sandboxWindow ? void 0 : sandboxWindow.searchButton) ? void 0 : _a.props) || _b.onClick();
                };
                function check() {
                    setLocal("selectedItems", allItems.value), syncSort(), sandboxSelect(allItems.value);
                }
                watch(formModel, (() => {
                    check();
                }), {
                    deep: !0
                });
                const remainingMaxCount = computed((() => MaxSelectCount - allItems.value.length));
                function sandboxSelect(values) {
                    var _a, _b, _c;
                    (null == (_a = null == sandboxWindow ? void 0 : sandboxWindow.buyerFilter) ? void 0 : _a.selectedList) && (sandboxWindow.buyerFilter.selectedList = values.map((name => ({
                        name: name
                    })))), null == (_c = null == (_b = null == sandboxWindow ? void 0 : sandboxWindow.buyerFilter) ? void 0 : _b.roleFilterStore) || _c.setCurrentAppearance(values, !1);
                }
                function selectFilter(inputValue, option) {
                    return option.search = inputValue, option.label.toLowerCase().indexOf(inputValue.toLowerCase()) >= 0;
                }
                function selectSelect(value) {
                    historyTagsAdd(value);
                }
                function syncSort() {
                    var _a, _b;
                    const [sortType, sortOrder] = orderRef.value.split("-");
                    null == (_a = null == sandboxWindow ? void 0 : sandboxWindow.buyerStore) || _a.setSortType(sortType), 
                    null == (_b = null == sandboxWindow ? void 0 : sandboxWindow.buyerStore) || _b.setSortOrder(sortOrder), 
                    setLocal("order", orderRef.value);
                }
                function historyTagsAdd(value) {
                    historyItemsRef.value.add(...[].concat(value)), setLocal("historyItems", historyItemsRef.value.toArray());
                }
                function historyTagsClose(text) {
                    historyItemsRef.value.delete(text), setLocal("historyItems", historyItemsRef.value.toArray());
                }
                function historyTagsClick(text) {
                    if (allItems.value.includes(text)) api$1.error(`${text} 已存在`); else if (allItems.value.length >= MaxSelectCount) api$1.error(`同时最大可选物品数量 ${MaxSelectCount}`); else {
                        const items = [ ...allItems.value ];
                        items.push(text), allItems.value = items;
                    }
                }
                function historyTagsClear() {
                    historyItemsRef.value.clear(), setLocal("historyItems", historyItemsRef.value.toArray());
                }
                function historyTagTransform(tag) {
                    const {name: name, showName: showName} = dataMap[tag];
                    return `${name}(${showName})`;
                }
                return watch((() => orderRef.value), (() => {
                    syncSort();
                }), {}), (_ctx, _cache) => (openBlock(), createElementBlock(Fragment, null, [ (openBlock(), 
                createBlock(Teleport, {
                    to: "body"
                }, [ createBaseVNode("div", {
                    class: normalizeClass([ "leek-btn-start", {
                        "leek-fly-out": openRef.value,
                        "leek-growing": !openRef.value
                    } ]),
                    onClick: onOpen
                }, [ createVNode(IconLeek) ], 2) ])), createVNode(unref(Drawer$1), {
                    width: 480,
                    open: openRef.value,
                    onClose: onClose
                }, {
                    title: withCtx((() => [ createTextVNode(" 外观可选数量 "), createBaseVNode("span", _hoisted_1, "(" + toDisplayString(remainingMaxCount.value) + ")", 1) ])),
                    extra: withCtx((() => [ createVNode(unref(Space), null, {
                        default: withCtx((() => [ createVNode(unref(Button), {
                            onClick: onReset
                        }, {
                            default: withCtx((() => [ createTextVNode("重置") ])),
                            _: 1
                        }), createVNode(unref(Button), {
                            type: "primary",
                            onClick: onSearch
                        }, {
                            default: withCtx((() => [ createTextVNode("查询") ])),
                            _: 1
                        }) ])),
                        _: 1
                    }) ])),
                    default: withCtx((() => [ createBaseVNode("section", _hoisted_2, [ createVNode(unref(Form), {
                        ref_key: "formRef",
                        ref: formRef,
                        model: formModel
                    }, {
                        default: withCtx((() => [ createBaseVNode("div", _hoisted_3, [ (openBlock(), createBlock(unref(FormItem), {
                            key: "排序方式",
                            label: "排序方式",
                            name: "order"
                        }, {
                            default: withCtx((() => [ createVNode(unref(RadioGroup), {
                                value: orderRef.value,
                                "onUpdate:value": _cache[0] || (_cache[0] = $event => orderRef.value = $event),
                                "button-style": "solid"
                            }, {
                                default: withCtx((() => [ createVNode(unref(RadioButton), {
                                    value: "price-1"
                                }, {
                                    default: withCtx((() => [ createTextVNode(" 价格 "), createVNode(unref(ArrowUpOutlined)) ])),
                                    _: 1
                                }), createVNode(unref(RadioButton), {
                                    value: "price-0"
                                }, {
                                    default: withCtx((() => [ createTextVNode("价格 "), createVNode(unref(ArrowDownOutlined)) ])),
                                    _: 1
                                }), createVNode(unref(RadioButton), {
                                    value: "followed_num-1"
                                }, {
                                    default: withCtx((() => [ createTextVNode("关注 "), createVNode(unref(ArrowUpOutlined)) ])),
                                    _: 1
                                }), createVNode(unref(RadioButton), {
                                    value: "followed_num-0"
                                }, {
                                    default: withCtx((() => [ createTextVNode("关注 "), createVNode(unref(ArrowDownOutlined)) ])),
                                    _: 1
                                }) ])),
                                _: 1
                            }, 8, [ "value" ]) ])),
                            _: 1
                        })), (openBlock(), createBlock(unref(FormItem), {
                            key: allItemsInfo.value.label,
                            label: allItemsInfo.value.label,
                            name: "allItemsInfo.label"
                        }, {
                            default: withCtx((() => [ createVNode(unref(Select), {
                                class: "leek-search-select",
                                "popup-class-name": "leek-search-select-popup",
                                onChange: _cache[1] || (_cache[1] = (value, options) => onChange(allItemsInfo.value.label)(value, options)),
                                onSelect: selectSelect,
                                options: allItemsInfo.value.options,
                                mode: "multiple",
                                "show-search": "",
                                "allow-clear": "",
                                "filter-option": selectFilter,
                                value: allItems.value,
                                "onUpdate:value": _cache[2] || (_cache[2] = $event => allItems.value = $event),
                                "max-tag-count": 0
                            }, {
                                option: withCtx((({label: label, searchDescType: searchDescType}) => [ createBaseVNode("div", _hoisted_4, [ createBaseVNode("span", _hoisted_5, toDisplayString(label), 1), createVNode(unref(Tag), {
                                    class: "leek-select-item-tag",
                                    color: "default"
                                }, {
                                    default: withCtx((() => [ createTextVNode(toDisplayString(searchDescType), 1) ])),
                                    _: 2
                                }, 1024) ]) ])),
                                _: 1
                            }, 8, [ "options", "value" ]) ])),
                            _: 1
                        }, 8, [ "label" ])), withDirectives(createBaseVNode("div", _hoisted_6, [ createBaseVNode("div", _hoisted_7, [ _hoisted_8, createBaseVNode("div", _hoisted_9, [ createVNode(unref(DeleteOutlined), {
                            onClick: historyTagsClear
                        }) ]) ]), createBaseVNode("div", _hoisted_10, [ createVNode(unref(Space), {
                            size: [ 0, "small" ],
                            wrap: ""
                        }, {
                            default: withCtx((() => [ (openBlock(!0), createElementBlock(Fragment, null, renderList(historyItemsRef.value.toArray(), (tag => (openBlock(), 
                            createBlock(unref(Tag), {
                                class: "leek-search-history-tag",
                                key: tag,
                                bordered: !1,
                                closable: "",
                                onClick: $event => historyTagsClick(tag),
                                onClose: $event => historyTagsClose(tag)
                            }, {
                                default: withCtx((() => [ createTextVNode(toDisplayString(historyTagTransform(tag)), 1) ])),
                                _: 2
                            }, 1032, [ "onClick", "onClose" ])))), 128)) ])),
                            _: 1
                        }) ]) ], 512), [ [ vShow, historyItemsRef.value.size() ] ]) ]), (openBlock(!0), 
                        createElementBlock(Fragment, null, renderList(formInfo, (item => (openBlock(), createBlock(unref(FormItem), {
                            key: item.label,
                            label: item.label,
                            name: item.label
                        }, {
                            default: withCtx((() => [ createVNode(unref(Select), {
                                class: "leek-search-select",
                                "popup-class-name": "leek-search-select-popup",
                                onChange: (value, options) => onChange(item.label)(value, options),
                                onSelect: selectSelect,
                                options: item.options,
                                mode: "multiple",
                                "show-search": "",
                                "allow-clear": "",
                                "filter-option": selectFilter,
                                value: formModel[item.label],
                                "onUpdate:value": $event => formModel[item.label] = $event
                            }, {
                                option: withCtx((({label: label, searchDescType: searchDescType}) => [ createBaseVNode("div", _hoisted_11, [ createBaseVNode("span", _hoisted_12, toDisplayString(label), 1), createVNode(unref(Tag), {
                                    class: "leek-select-item-tag",
                                    color: "default"
                                }, {
                                    default: withCtx((() => [ createTextVNode(toDisplayString(searchDescType), 1) ])),
                                    _: 2
                                }, 1024) ]) ])),
                                _: 2
                            }, 1032, [ "onChange", "options", "value", "onUpdate:value" ]) ])),
                            _: 2
                        }, 1032, [ "label", "name" ])))), 128)) ])),
                        _: 1
                    }, 8, [ "model" ]) ]) ])),
                    _: 1
                }, 8, [ "open" ]) ], 64));
            }
        })).mount("#leek-app");
    }
});

 require_index();


  }



})();
